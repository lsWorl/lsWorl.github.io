<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构-排序, LsWorld">
    <meta name="description" content="



排序的基本概念排序算法的稳定性：若进行排序算法后，关键字相同的元素在排序之后相对位置保持不变，就称算法是稳定的，反之为不稳定。

如图1-1，若3的元素相对位置发生改变即为不稳定。
插入排序插入排序的基本思想是每次将一个待排序的记录">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>数据结构-排序 | LsWorld</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">LsWorld</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">LsWorld</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/lsWorl/lsWorl.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/lsWorl/lsWorl.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据结构-排序</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                <span class="chip bg-color">数据结构</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-category">
                                数据结构
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-11-03
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-11-11
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.1k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <meta name="referrer" content="no-referrer"/>



<h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><p>排序算法的稳定性：若进行排序算法后，关键字相同的元素在排序之后相对位置保持不变，就称算法是稳定的，反之为不稳定。</p>
<p><img src="https://img-blog.csdnimg.cn/b6dac648225d4117a08aae43cf3ecc8b.png" alt="1-1"></p>
<p>如图1-1，若3的元素相对位置发生改变即为不稳定。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的基本思想是每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部插入完成。</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>直接插入排序算法就是，就是一个个从左往右比较大小，将大的放在后面，小的放在前面。</p>
<p>算法实现代码：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">//若后一位小于前一位则交换位置</span>
            temp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token comment">//检查排好序中是否有更大的数</span>
                A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>直接插入排序的空间复杂度为O(1)，最坏情况下时间复杂度为$O(n^2)$。</p>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>由于结构是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可同一地向后移动元素。</p>
<p>代码实现：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//该算法空出A[0]作为哨兵，A[0]不存放元素</span>
<span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">//一次将A[2]~A[n]插入前面的已排序序列</span>
        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//将要排序的元素暂存到A[0]</span>
        low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>				<span class="token comment">//设置折半查找的范围</span>
        high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span>			<span class="token comment">//默认递增，从i后的数进行排序</span>
        <span class="token comment">//折半查找核心代码，仅当low小于high时进行循环</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>	<span class="token comment">//取中间点</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>			<span class="token comment">//在左半边查找</span>
                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>					<span class="token comment">//在右半边查找</span>
                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>		
            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//统一后移元素，空出插入位置</span>
            <span class="token punctuation">&#125;</span>
            A<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//插入操作</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当low&gt;high时，折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]赋值到low所指位置。当A[mid]&#x3D;&#x3D;A[0]时，为了保证算法的”稳定性”，应继续在mid所指位置右边寻找插入位置。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序的基本思想是：先将待排序表分割成若干形如$L[i,i+d,i+2,\dots,i+kd]$的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已经是“基本有序”时，再对全体记录进行一次直接插入排序。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/75c0fd11c0274597bf3a5ddabc3ef111.png" alt="1-2"></p>
<p>若想将图1-2进行排序，设第一趟的，$d_1&#x3D;n&#x2F;2&#x3D;4$（n为表长，0不算做元素，为暂存单元）。则可将相离为$d_1&#x3D;4$的看为同一个子表，即49和76为同一子表，38和13为同一子表，65和27为同一子表，97和49为同一子表。</p>
<p><img src="https://img-blog.csdnimg.cn/b7b540a8b89449e08b74b87374ee429e.png" alt="1-3"></p>
<p>然后再对各个子表进行字节插入排序，可得图1-4：</p>
<p><img src="https://img-blog.csdnimg.cn/d620be4cb6234a3a939013cfab84d575.png" alt="1-4"></p>
<p>最后再放回原先表中。</p>
<p><img src="https://img-blog.csdnimg.cn/9dc192f5b977493f8e45913f2b09fab9.png" alt="1-5"></p>
<p>再进行第二趟的处理，在原先基础上$d_2&#x3D;d_1&#x2F;2&#x3D;4&#x2F;2&#x3D;2$，第二趟每个元素相隔2个元素，即49、27、76、65为同一子表，13、49、38、97为同一子表。然后再对子表进行直接插入排序，排序后可得图1-6。</p>
<p><img src="https://img-blog.csdnimg.cn/ba06cdd5ce2f4205b16b4ce854624cf9.png" alt="1-6"></p>
<p>后再放回原表中。</p>
<p><img src="https://img-blog.csdnimg.cn/5b1fcc0097ee437889e91a46ebe21521.png" alt="1-7"></p>
<p>再进行第三趟，此时$d_3&#x3D;d_2&#x2F;2&#x3D;1$，则每个元素间隔为1为一个子表，显然就是无序再拆分表，而直接对整个表进行直接插入排序。</p>
<p><img src="https://img-blog.csdnimg.cn/1126f27c142f48b8a59ca5480daacee4.png" alt="1-8"></p>
<p>最后就成功获得一个全局有序的递增排序的表。</p>
<p><strong>希尔排序代码实现</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> dk<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>						<span class="token comment">//dk为增量</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>dk<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>dk<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>dk<span class="token operator">=</span>dk<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">//假设dk=n/2为每次的缩小增量</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>dk<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span>dk<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">//将A[i]插入到有序增量子表中</span>
                A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//暂存再A[0]</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>dk<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">-=</span>dk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//记录后移，查找插入的位置</span>
                <span class="token punctuation">&#125;</span>
                A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//插入</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>希尔排序算法性能分析</strong>：</p>
<p>空间效率：仅使用了常数个辅助单元，空间复杂度为O(1)。</p>
<p>时间效率：当n在某个特定范围内，希尔排序的时间复杂度约为$O(n^{1.3})$。在最坏情况下希尔排序的时间复杂度为$O(n^2)$。</p>
<p>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变他们之间的相对次序，因此希尔排序是一种不稳定排序方法。</p>
<p>适用性：希尔排序算法仅适用于线性表为顺序存储的情况。</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序的基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换他们，直到排序比较完。称这样过程为“一趟”冒泡排序。</p>
<p><strong>冒泡排序算法实现：</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        bool flag <span class="token operator">=</span> false<span class="token punctuation">;</span>			<span class="token comment">//表示本趟冒泡是否发生交换的标志</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">//一趟冒泡过程</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">//若后值比前置小，则交换</span>
                ElemType temp <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span>false<span class="token punctuation">)</span>		<span class="token comment">//若没有进行交换，则说明表已经有序</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>



<p><strong>冒泡排序性能分析</strong>：</p>
<p>空间复杂度：O(1)。</p>
<p>时间复杂度：在最坏情况下（所有值都为逆序）则需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较。则<br>$$<br>比较次数&#x3D;\sum^{n-1}<em>{i&#x3D;1}(n-i)&#x3D;\frac{n(n-1)}{2}，移动次数&#x3D;\sum^{n-1}</em>{i&#x3D;1}3(n-i)&#x3D;\frac{3n(n-1)}{2}<br>$$<br>因此，最坏时间复杂度为$O(n^2)$，平均时间复杂度为$O(n^2)$ .</p>
<p>稳定性：由于i&gt;j且A[i]&#x3D;A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序方法。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序的基本思想是基于分治法：在待排序表$L[1\dots n]$中任取一个元素pivot作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分$L[1\dots k-1]$和$L[k+1\dots n]$，使得$L[1\dots k-1]$中的所有元素小于pivot，$L[k+1\dots n]$中的所有元素大于或等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次划分。然后重复上述过程，直至每部分内只有一个元素或空为止。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/8d5bede523df42df92e7e4326207cba4.png" alt="2-1"></p>
<p>在图2-1中，将49设为枢轴，要将其他小于49的放在49的左半部分，大于的放在49的右半部分，从而完成一次划分。</p>
<p><img src="https://img-blog.csdnimg.cn/895fac2429fa43598d08ceb6a8a6a45c.png" alt="2-2"></p>
<p>通过low和high指针来进行，保证high指针的右边都是大于等于枢轴49的值，low指针左边都是小于枢轴49的值。</p>
<p>此时high指针所指元素为49，等于枢轴元素，所以high指针往左移，移到27。</p>
<p><img src="https://img-blog.csdnimg.cn/ca9db0246f1a443494dd2687dab70340.png" alt="2-3"></p>
<p>而27要小于枢轴元素49，则需要放在low所指为止，即0为27，且low指针往右移。</p>
<p><img src="https://img-blog.csdnimg.cn/760b56f8610541549a6a947fe511f272.png" alt="2-4"></p>
<p>显然此时low所指元素38也小于基准元素49，则low指针再次右移，到指向65的元素，而65要大于基准元素49，则需放到high所指位置（即6），后high指针向左移。</p>
<p><img src="https://img-blog.csdnimg.cn/1d3611c62aac47c982b03459e5422eb2.png" alt="2-5"></p>
<p>此时high所指元素13要小于基准49，则放到low所指位置，然后low指针右移。</p>
<p><img src="https://img-blog.csdnimg.cn/71c4936156734629999aa3dadf3f4fee.png" alt="2-6"></p>
<p>而low所指元素97要大于基准49，需将97放到high所指位置，后high左移到76元素位置，而76元素也大于49，则high指针继续左移。</p>
<p><img src="https://img-blog.csdnimg.cn/bba1a596b9f34f36a38278df9420a56b.png" alt="2-7"></p>
<p>当low&#x3D;high时，说明元素已经排序完成，可以将基准元素49放到low所指的位置。此时就完成了一次划分。接下来就是对左子表和右子表进行划分，过程基本相同，就不再过多赘述。</p>
<p><strong>快速排序代码实现</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">//递归结束条件</span>
        <span class="token keyword">int</span> pivotpos <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//Partition()就是划分操作，将表A划分为满足上述条件的两个子表</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>pivotpos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//依次对两个子表进行递归排序</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>pivotpos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">//一趟划分</span>
    ElemType pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//将当前表中第一个元素设置为枢轴，对表进行划分</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>			<span class="token comment">//循环跳出条件</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">>=</span>pivot<span class="token punctuation">)</span> <span class="token operator">--</span>high<span class="token punctuation">;</span>
        A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//将比枢轴小的元素移动到左端</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>low <span class="token operator">&lt;=</span> pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>low<span class="token punctuation">;</span>
        A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//将比枢轴大的元素移动到右端</span>
    <span class="token punctuation">&#125;</span>
    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>				<span class="token comment">//枢轴元素存放到最终位置</span>
    <span class="token keyword">return</span> low<span class="token punctuation">;</span>					<span class="token comment">//返回存放枢轴的最终位置</span>
<span class="token punctuation">&#125;</span></code></pre>



<p><strong>快速排序算法性能分析</strong>：</p>
<p>空间效率：快排需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的深度一致。最好情况下为$O(log_2n)$；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O（n）；平均情况下，栈的深度为$O(log_2n)$。</p>
<p>时间效率：快排的运行时间与划分是否对称有关，快排最坏情况下，对应区域基本不对称，时间复杂度为$O(n^2)$。快排的时间复杂度和递归深度息息相关，若<code>Partition()</code>可能做道最平衡的划分，得到两个子问题的大小都不可能大于n&#x2F;2，这种情况下，平均时间复杂度为$O(nlog_2n)$。</p>
<p>稳定性：在划分算法中，有可能会将两个相同的值的相对位置发生变化，即快排是一种不稳定的排序算法。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>简单选择排序的思想：假设排序表为$L[1\dots n]$，第i趟排序即从$L[i\dots n]$中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可以使得整个排序表有序。</p>
<p><strong>简单选择排序代码实现</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">//一共进行n-1趟</span>
        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>				<span class="token comment">//记录最小元素位置</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>	<span class="token comment">//在[i..n-1]中选择最小的元素</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> min<span class="token operator">=</span>j<span class="token punctuation">;</span>	<span class="token comment">//更新最小元素位置</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>				<span class="token comment">//若当前位置的元素和最小值不同就移动位置</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
            A<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>



<p><strong>简单选择排序效率</strong>：</p>
<p>空间效率：仅使用常熟个辅助单元，故空间效率为O(1)。</p>
<p>时间效率：在简单排序过程中不会超过3(n-1)次。但元素间比较的次数与序列的初始状态无关，始终是n(n-1)&#x2F;2次，因此时间复杂度始终是$O(n^2)$。</p>
<p>稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发生改变。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆的定义如下，n个关键字序列$L[1\dots n]$称为堆，当且仅当该序列满足：</p>
<ol>
<li>$L(i)\geq L(2i)且L(i)\geq L(2i+1)$  （大根堆）或</li>
<li>$L(i)\leq L(2i)且L(i) \leq L(2i+1)$ （小根堆） $(1\leq i \leq [n&#x2F;2])$</li>
</ol>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/8d0b9a7d3da948bd8a66a3bac5d4704f.png" alt="3-1"></p>
<p>如图3-1，若大根堆中$i&#x3D;1，则L(1)&#x3D;87 \geq L(2)&#x3D;45且L(1)&#x3D;87 \geq L(2+1)&#x3D;78 $，小根堆同理。</p>
<p>堆数据结构可以视为一棵完全二叉树用顺序存储后的结果，如图3-2所示</p>
<p><img src="https://img-blog.csdnimg.cn/1bec03e5c49a452195f3795e8354dde5.png" alt="3-2"></p>
<p>大根堆以完全二叉树视角来看，即$根\geq 左、右$。小根堆则相反，$根\leq 左、右$</p>
<p><strong>堆排序的思路</strong>：</p>
<p>首先将存放在L[1…n]中的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆低元素送入堆顶，此时根节点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再继续输出堆顶元素。如此反复。</p>
<p>而堆排序的关键就是构造初始堆。</p>
<h5 id="堆构造"><a href="#堆构造" class="headerlink" title="堆构造"></a>堆构造</h5><p>以大根堆为例，若有图3-3这一初始序列$L(53,17,78,9,45,65,87,32)$，并将序列以二叉树形式展示。</p>
<p><img src="https://img-blog.csdnimg.cn/0dbfa1185bea4314a30f313b645e5e87.png" alt="3-3"></p>
<p>思路：把所有非终端结点都检查一遍，看是否满足大根堆的要求（根大于左右子树的值），不满足则进行调整，而在顺序存储的完全二叉树中，非终端结点编号$i\leq [n&#x2F;2]$，图上则i&#x3D;[8&#x2F;2]&#x3D;4。即对53，17，78，09进行检查，从右往左进行检查，从而从i&#x3D;4，即09开始判断。</p>
<p><img src="https://img-blog.csdnimg.cn/fc0cc4b6f68042f48e695c20097b0b27.png" alt="3-4"></p>
<p>获取09的左孩子通过完全二叉树的性质也得左孩子&#x3D;2i&#x3D;2*4&#x3D;8，即以8为下标的位置为09的左孩子，即32。要保证大根堆的特性，所以要将根结点和左孩子进行交换。</p>
<p><img src="https://img-blog.csdnimg.cn/a549de1a2da3408d984cbb774bbebebb.png" alt="3-5"></p>
<p>然后再检查i&#x3D;3（结点78），根据完全二叉树的性质，左孩子&#x3D;2i&#x3D;2*3&#x3D;6（结点65），右孩子&#x3D;2i+1&#x3D;6+1&#x3D;7（结点87）。后再将根节点分别与左右孩子进行比较。将最大的（右孩子结点87）值与根节点交换。</p>
<p><img src="https://img-blog.csdnimg.cn/67f8b11492164ee7b8d71590846c626a.png" alt="3-6"></p>
<p>同样的，最后就可以将i&#x3D;1和i&#x3D;2进行以大根堆性质的交换，可得最后结果。</p>
<p><img src="https://img-blog.csdnimg.cn/cd2b801791984698a46dcb1b12e88a75.png" alt="3-7"></p>
<p>而此时导致以53为根的子树不满足大根堆的特性，以此要再次对53为根的子树进行调整。</p>
<p><img src="https://img-blog.csdnimg.cn/7cb8546e7a654570a9746a0ceee04655.png" alt="3-8"></p>
<p>最后调整完成即可使整个树符合大根堆特性。</p>
<p><strong>建立大根堆代码实现</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//建立大根堆</span>
<span class="token keyword">void</span> <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>		<span class="token comment">//从i=[n/2]~1 反复调整堆</span>
        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//将以k为根的子树调整为大根堆</span>
<span class="token keyword">void</span> <span class="token function">HeadAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>						<span class="token comment">//A[0]暂存子树的根节点</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">//每次都将i赋值为左孩子</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">//左孩子比右孩子小，就用右孩子和根进行比较</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>		<span class="token comment">//根比左右孩子都大，就无需交换</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//将左右孩子大的值调整到双亲结点上</span>
            k <span class="token operator">=</span> i<span class="token punctuation">;</span>			<span class="token comment">//修改k的值，以便继续向下筛选</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>	<span class="token comment">//for循环结束</span>
    
    A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//被筛选结点的值放入最终位置</span>
<span class="token punctuation">&#125;</span></code></pre>



<p><strong>堆排序算法实现</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//初始建堆</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">//n-1趟交换堆顶元素和堆底元素位置以及建堆过程</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//堆顶元素和堆底元素交换</span>
        A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//交换后再对剩下的i-1个元素整理成堆</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>



<p><strong>算法效率分析</strong>：</p>
<p>空间效率：仅使用了常数个辅助单元，所以空间复杂度尾O(1)。</p>
<p>时间效率：</p>
<p>设树高为h，某结点再第i层，则将这个结点向下调整最多只需要“下坠”h-i层，关键字对比次数不超过2(h-i)次，而n个结点的完全二叉树树高$h&#x3D;[log_2n]+1$。</p>
<p>第i层最多有$2^{i-1}$个结点，而只有第1~(h-1)层的结点才有可能需要“下坠”调整（最后一层无需调整），将整棵树调整为大根堆，关键字对比次数不超过<br>$$<br>\sum^{1}<em>{i&#x3D;h-1}2^{i-1}2(h-i)&#x3D;\sum^{1}</em>{i&#x3D;h-1}2^{i}(h-i)&#x3D;\sum^{h-1}_{j&#x3D;1}2^{h-j}j<br>$$<br>将高度$h&#x3D;[log_2n]+1$带入第三式子中，得<br>$$<br>\sum2^{[log_2n]+1-j}j&#x3D;\sum2^{[log_2n]+1}2^{-j}j\leq \sum2^{log_2n}2^{1-j}j&#x3D;\sum 2n2^{-j}j\leq 4n<br>$$<br>所以**建堆时间复杂度为O(n)**，而每次调整的时间复杂度为O(h)，n-1趟的总时间复杂度为$O(nlog_2n)$，故平均的情况下，堆排序的时间复杂度为$O(nlog_2n)$。</p>
<p>稳定性：进行筛选时，有可能会调整值相同的元素，所以堆排序是不稳定的排序方法。</p>
<h5 id="在堆中插入新元素"><a href="#在堆中插入新元素" class="headerlink" title="在堆中插入新元素"></a>在堆中插入新元素</h5><p>以小根堆为例，若想在堆中插入元素，会先将新元素放到表尾，与父节点对比，若新元素比父节点更小，则两者互换。再一路向上与根结点比较，直至到无法继续上升位置。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/42d1fa9343de4e90a06135d7bca06c02.png" alt="3-9"></p>
<p>在表尾插入13，需要与父节点进行比较，即和i&#x3D;[9&#x2F;2]&#x3D;4（32元素），显然13比32小，就将13与父节点进行交换。</p>
<p><img src="https://img-blog.csdnimg.cn/9ac035521c884d2e8e7710a62624b94e.png" alt="3-10"></p>
<p>后13在和父节点i&#x3D;[4&#x2F;2]&#x3D;2（17元素）对比，显然13更小，就再与父节点进行交换。</p>
<p><img src="https://img-blog.csdnimg.cn/0754ebb580f14fcca73fc7373742f669.png" alt="3-11"></p>
<p>此时在与父节点i&#x3D;[2&#x2F;1]&#x3D;1（9元素）对比，父节点9更小，就无需再进行交换。此时即满足小根堆特性，插入成功。</p>
<h5 id="在堆中删除元素"><a href="#在堆中删除元素" class="headerlink" title="在堆中删除元素"></a>在堆中删除元素</h5><p>以小根堆为例，若删除非表尾元素则需以表尾元素来替代删除元素的位置，后再通过不断的“下坠”来恢复小根堆的特性。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/1b6bf5434bc54c1f8de4420f2ae9f484.png" alt="3-12"></p>
<p>在图3-12中，若想删除2位置的元素13。删除后会用表尾46来替代2位置的元素。</p>
<p><img src="https://img-blog.csdnimg.cn/982ef43ef01d4553a75098ebaa117f3b.png" alt="3-13"></p>
<p>后再通过46和左右孩子(2i&#x3D;4和2i+1&#x3D;5)进行比较，恢复回小根堆的特性，依次比较可得最后结果：</p>
<p><img src="https://img-blog.csdnimg.cn/389468b1e15c471caf0de6337c24fd6c.png" alt="3-14"></p>
<h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并（Merge）：把两个或多个以及有序的序列合并成一个。</p>
<p>以二路归并（二路归并即将两个表合成一个表）为例：</p>
<p><img src="https://img-blog.csdnimg.cn/fc89899a5cc14d3997d2140e31b447bb.png" alt="4-1"></p>
<p>将图4-1的左右两个表合并到一个新表中，可以通过设置i,j,k三个指针来实现，首先，先让i与j所指的值进行比较，即目前12&gt;7，则将7放到k所指位置，然后使<code>j++</code>，i和j再进行比较。</p>
<p><img src="https://img-blog.csdnimg.cn/daa19a79a61c4d909ed9ddd3f182c97b.png" alt="4-2"></p>
<p>如此反复，当j超出下标所指范围时，就只会将i所指后面的元素放入到新表中，最后即可得到最后合并的结果：</p>
<p><img src="https://img-blog.csdnimg.cn/d93d8713705f41fc89cd3c10f82174a0.png" alt="4-3"></p>
<p><strong>代码实现</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//定义一个长度为n的辅助数组B</span>
<span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> mid <span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//表A的两段A[low...mid]和A[mid+1...high]各自有序，将它们合并成一个有序表</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>low<span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        B<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//将A中所有元素复制到B中</span>
    <span class="token comment">//将 i设为第一个表中的头指针 j为第二表中的头指针  k为新表的头指针</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span> j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">=</span>i<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>		<span class="token comment">//比较B的左右两端中的元素</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//将大的赋值到k所指位置并使指针向右移</span>
        <span class="token keyword">else</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span>	A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//若第一个表未检测完，复制</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span>	A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//若第二个表未检测完，复制</span>
<span class="token punctuation">&#125;</span></code></pre>



<p><strong>合并代码实现</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>	<span class="token comment">//从中间划分两个子序列</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//对左侧子序列进行递归排序</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//对右侧子序列进行递归排序</span>
        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span>		<span class="token comment">//归并</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>



<p><strong>2路归并排序算法性能分析</strong>：</p>
<p>空间效率：Merge()操作中，辅助单元为n个单元，所以空间复杂度为O(n)。</p>
<p>时间效率：每趟归并的时间复杂度为O(n)，共需进行$[log_2n]$趟归并，所以算法时间复杂度为$O(nlog_2n)$。</p>
<p>稳定性：由于Merge()操作不会改变相同元素的相对次序，所以归并排序是稳定的算法。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。</p>
<p>假设长度为n的线性表中每个结点$a_j$的关键字由d元组（$k_j^{d-1},k_j^{d-2},\dots,k_j^1,k_j^{0}$）组成，满足$0\leq k_j^i\leq r-1 \quad (0\leq j&lt;n,0\leq i\leq d-1)$。其中$k_j^{d-1}$为最主位关键字，$k_j^0$为最次位关键字，r为基数。</p>
<p>以<strong>递减</strong>序列为例：</p>
<p><img src="https://img-blog.csdnimg.cn/8de0cf9d779c421d951f3e5066ae7ca0.png" alt="4-4"></p>
<p>此时该表的”个十百“均有十种不同的取值（即取0,1,2,3,4,5,6,7,8,9），则基数为10。最次位关键字为个位，最主位关键字为百位。</p>
<p>若要对图4-4表进行基数排序，首先会新建队列，在第一趟排序中会将所有数按照”个位“进行”分配”。</p>
<p><img src="https://img-blog.csdnimg.cn/d0b3685920d44680869f7a0a94e5d9ea.png" alt="4-5"></p>
<p>如图4-5所示，从左往右按“个位”将每个关键字放到对应的队列中，后再根据队列最大的值进行收集，每个元素会从队头出队。</p>
<p><img src="https://img-blog.csdnimg.cn/6f1e9b4166a44433a220f04271d6a528.png" alt="4-6"></p>
<p>收集完成后会得到一个“个位”递减的序列。然后再从左往右根据”十位“进行第二趟排序。</p>
<p><img src="https://img-blog.csdnimg.cn/1b23e471e8074ecd916584a87fa474d5.png" alt="4-7"></p>
<p>再进行队头关键词出队收集。</p>
<p><img src="https://img-blog.csdnimg.cn/14102c7b59e848f78b12bf2c6ee1cb28.png" alt="4-8"></p>
<p>就可以获得”十位“递减的序列，后再根据”百位“，进行第三趟排序。</p>
<p><img src="https://img-blog.csdnimg.cn/dd2b429af48c49ab8c286743a47bfe3d.png" alt="4-9"></p>
<p>再对该队列进行收集。</p>
<p><img src="https://img-blog.csdnimg.cn/40539d3b89ad413ba5ced1e50b935aee.png" alt="4-10"></p>
<p>最后就可以得到一个”百位“递减的序列，同时若”百位“相等，则根据”十位“递减，同样的，”十位“相等，根据”个位“递减。就获得了一个递减的表。</p>
<h5 id="基数排序算法性能分析"><a href="#基数排序算法性能分析" class="headerlink" title="基数排序算法性能分析"></a>基数排序算法性能分析</h5><p>空间效率：一趟排序需要的辅助存储空间为r（r个队列：r个队头指针和r个队尾指针），空间复杂度为O(r)。</p>
<p>时间效率：基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)（r为基数），所以基数排序的时间复杂度为O(d(n+r))。</p>
<p>稳定性：对于基数排序算法而言，很重要一点就是按位排序时必须是稳定的。因此基数排序一定是稳定的。</p>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><blockquote>
<p>文件通常是按块存储在磁盘上的，磁盘的读&#x2F;写以”块“为单位，数据读入内存后才能被修改，修改完成后还需写回磁盘，因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即I&#x2F;O数。</p>
</blockquote>
<p>外部排序通常采用归并排序法，与内部排序归并相似，先将每个文件块读入缓存，再将读入的记录进行排序，将排序完的有序子文件重新写回外存，最后再对这些文件块逐趟归并，使有序子文件逐渐由小到大，直至得到整个有序文件为止。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/6011a61925774801a9d2d2432a23f765.png" alt="5-1"></p>
<p>若想将图5-1中文件块有序，需先读入部分文件块使先做到部分有序。</p>
<p><img src="https://img-blog.csdnimg.cn/f99c88ff152845c4a79a3442958f618b.png" alt="5-2"></p>
<p>此时读入了两块文件块，对其进行排序。</p>
<p><img src="https://img-blog.csdnimg.cn/db8b2ce50e014db18d961518261834cb.png" alt="5-3"></p>
<p>再依次放到输出缓冲区，写回磁盘中。</p>
<p><img src="https://img-blog.csdnimg.cn/ee19efa7c87f4c4db1cd14b008dd2a74.png" alt="5-4"></p>
<p>此时这两块文件块就是有序，即可将这两块文件块称为一个有序的”归并段“，然后依次再对剩下的文件块进行读入排序再写回。</p>
<p><img src="https://img-blog.csdnimg.cn/51b5e6ee26314feea20b8f08c05eae75.png" alt="5-5"></p>
<p>经过16次读和16次的写，就可以获得8个有序”归并段“，此时就可以根据”归并段“进行归并排序。</p>
<p><img src="https://img-blog.csdnimg.cn/9bc4c7d8b8c44aa48096792a29d27db4.png" alt="5-6"></p>
<p>此时将”归并段1“和”归并段2“中的两块子文件放入缓冲区进行排序，当凑满3个关键字就写回磁盘中。</p>
<p><img src="https://img-blog.csdnimg.cn/acd86994f0b24a60bc4ed47f8d37e9f8.png" alt="5-7"></p>
<p>此时就凑满3个最小关键字就写回到磁盘中，此时为了方便接下来继续使用二路归并，物理上会新建一个新文件块来存储要写回的关键字，将原先空间归还给系统。</p>
<p><img src="https://img-blog.csdnimg.cn/678221d791a14bd397ef195624864949.png" alt="5-8"></p>
<p>然后继续进行归并，而当输入缓冲区有一块为空时，就会立刻从磁盘中再读新的文件快来填补。</p>
<p><img src="https://img-blog.csdnimg.cn/d9678fa445be42c4a9a2cd3872789363.png" alt="5-9"></p>
<p>这样就能保证归并永远是从归并段中最小的记录开始。</p>
<p><img src="https://img-blog.csdnimg.cn/296022b077b14c04aa866ac9fc6fb67e.png" alt="5-10"></p>
<p>最后就能归并一个更长的“归并段”。</p>
<p><img src="https://img-blog.csdnimg.cn/d7d9d4e61ea24536b054f2c526e0164e.png" alt="5-11"></p>
<p>依次再将剩下的归并，可得：</p>
<p><img src="https://img-blog.csdnimg.cn/78e7f66380f846dfbcee25f8b35978e0.png" alt="5-12"></p>
<p>然后依据这个思路，扩充为8、16个文件块为以归并段进行归并，就能获得最终有序文件。</p>
<p>一般情况下，外部排序中实现两两归并时，会进行大量数据读出、写入磁盘，而这会耗费大量的时间。一般<strong>外部排序的总时间 &#x3D; 内部排序所需的时间 + 外存信息读写的时间 + 内部归并所需的时间</strong>。</p>
<p>由上二路归并所示，生成一个归并段就会进行了读、写外部信息，而读写的次数&#x3D;32 + 32*3 &#x3D;128（初始生成归并段进行读、写各16次，读、写各16次，共三趟归并）。</p>
<p>若想进行优化，可采用4归并排序，仅需2趟归并，此时外部读、写次数减至32+ 32 *2 &#x3D; 96次。</p>
<p><strong>结论</strong>：</p>
<p>对用r个初始归并段，做k路归并，则归并书可用k叉树表示，若树高为h，则$归并趟数&#x3D;h-1&#x3D;[\log_kr]$，<strong>若k越大，r越小，归并趟数越少，读写磁盘次数越少</strong>。</p>
<h4 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h4><p>败者树可视为一棵完全二叉树。k个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较（即让更小的进行下一步比较，根节点为要比较的结点中最小的值），一直到根结点。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/c20e026756ca4086a41f8e119cd7ca54.png" alt="5-13"></p>
<p>败者树中会将每个归并段中第一个最小的关键字进行比较，更小的将继续上升继续下一轮比较。</p>
<p><img src="https://img-blog.csdnimg.cn/d9834dab86a141b9bec30379e3da5882.png" alt="5-14"></p>
<p>从左往右看27和12进行比较，12失败，记录失败者的归并段1，12进行下一场比拼。1和17比较，1失败，记录失败者的归并段4，1进入下一场比拼。2和9比较，2失败，记录失败者的归并段6，2进行下一场比拼。11和4比较，4失败，记录失败者的归并段7，4进入下一场比拼，每次都会进行最小关键字的比较，比较到最后可得最小关键字为1，来自归并段3（树中放的是关键字来自哪个归并段）。</p>
<p><img src="https://img-blog.csdnimg.cn/3d7dc3d362ee444eac12a2a20646d849.png" alt="5-15"></p>
<p>然后进行下一轮比较，直接可从归并段3中使6出队，与剩下的进行比较。</p>
<p><img src="https://img-blog.csdnimg.cn/d56bdfd7769847f18e5e602b8cede7b7.png" alt="5-16"></p>
<p>依次进行比较，后面就不再过多赘述。</p>
<p><strong>对于k路归并，第一次构造败者树需要对比关键字k-1次，有了败者树，选出最小元素只需对比关键字$[\log_2k]$次</strong></p>
<h4 id="置换-选择排序（生成初始归并段）"><a href="#置换-选择排序（生成初始归并段）" class="headerlink" title="置换-选择排序（生成初始归并段）"></a>置换-选择排序（生成初始归并段）</h4><blockquote>
<p>若磁盘要排序总的记录个数为n，每个归并段的长度为l，则初始归并段的个数$r&#x3D;[n&#x2F;l]$。若用内部排序方法得到各个初始归并段，它就依赖于内部排序时可用内存工作区的大小。因此，可用置换-选择算法来产生更长的初始归并段。</p>
</blockquote>
<p>设初始代排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置换-选择排序步骤如下：</p>
<ol>
<li>从FI输入w个记录到工作区WA。</li>
<li>从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。</li>
<li>将MINIMAX记录输出到FO中去。</li>
<li>若FI不空，则从FI输入下一个记录到WA中。</li>
<li>从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li>
<li>重复3和5的步骤，直至WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中。</li>
<li>重复2和6的步骤，直至WA为空。</li>
</ol>
<p>例子（构造递增归并段）：</p>
<p><img src="https://img-blog.csdnimg.cn/76e4fe19f05f4f988a3d852e0b957622.png" alt="5-17"></p>
<p>如图5-17，有24个初始待排序记录，设内存工作区WA只能容纳3个记录，会先读取FI中开头的三个记录3、4、9，加入到WA中，然后选出最小的记录为MINIMAX记录并放到归并段1中。</p>
<p><img src="https://img-blog.csdnimg.cn/7ac072b464164ef6adb739c633f66ae2.png" alt="5-18"></p>
<p>此时WA中出现空位，就会从FI中再读入新的记录。</p>
<p><img src="https://img-blog.csdnimg.cn/c4ecccb8057a48bbb53d177b073a9535.png" alt="5-19"></p>
<p>此时WA中最小值为6，并且比$MINIMAX&#x3D;4$要大，所以将6放入到归并段1中，并且把MINIMAX修改为6，再从FI中读入13。</p>
<p><img src="https://img-blog.csdnimg.cn/585a23d98d00490595b0b4e137063b9e.png" alt="5-20"></p>
<p>不断重复上方步骤，直至读入10时：</p>
<p><img src="https://img-blog.csdnimg.cn/30bacbf8543141048250ccfe5b71c7d5.png" alt="5-21"></p>
<p>此时10要小于$MINIMAX&#x3D;13$，从而要将MINIMAX改成第二小的14（保证归并段1中递增），并将14放入放入归并段1中。</p>
<p><img src="https://img-blog.csdnimg.cn/e063ffdd51e64747856acb27c773673d.png" alt="5-22"></p>
<p>再继续进行上方步骤，直至WA中都比归并段1中末尾值要小。说明此时就应该截止。</p>
<p><img src="https://img-blog.csdnimg.cn/add5f4fc027b4c288fb10dac4abd78aa.png" alt="5-23"></p>
<p>后面剩下的记录和上方步骤一样，即可获得最终3个归并段。</p>
<p><img src="https://img-blog.csdnimg.cn/1b2040ca9e05495296b78bf3f31852f9.png" alt="5-24"></p>
<h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4><p>最佳归并树是将长度不等的初始归并段来归并排序，并使I&#x2F;O次数最少。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/be1a611048f34f52801b6577cbf10102.png" alt="5-25"></p>
<p>若有图5-25五个归并段R1,R2,R3,R4,R5，记录个数分别为2,5,1,6,2。此时使用二路归并，来生成归并树:</p>
<p><img src="https://img-blog.csdnimg.cn/accd33c2703b42f2aec7da7d6568c502.png" alt="5-26"></p>
<p>先将R2和R3进行二路归并，将R2中5个记录和R3中1个记录读入到内存，在内存中进行归并后再写回磁盘，来回就读、写各（5+1）次，R4和R5同理，读、写各（6+2）次，然后再将他们归并好的记录个数6和记录个数8进行归并成有14记录的归并段，最后再和R1归并，即最终的含有16个记录的归并段。</p>
<p>此时上方<strong>读磁盘的次数&#x3D;写磁盘的次数&#x3D;6+8+14+16&#x3D;44次</strong>，而此时归并树的带权路径长度$WPL&#x3D;2<em>1+5</em>3+1<em>3+6</em>3+2*3&#x3D;44$，和读、写磁盘的次数相同。</p>
<p><strong>由此可得$I&#x2F;O次数&#x3D;2\times WPL$。</strong></p>
<p>若想让I&#x2F;O次数最少，即WPL最少，就可以使用哈夫曼树来构建，哈夫曼树（以二路归并为例）就是以两个结点权值最小的组成一个树，此时根节点为两个结点权值之和，后再根据权值最小的两个结点进行归并。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/f11efe61e6744c41ad6e465431a9d5e5.png" alt="5-27"></p>
<p>图2-27中构建哈夫曼树先R3和R1构成一棵树，根节点的权值为3，根节点3再与R5构建树，根节点权值为5，再与R2构建树，根节点权值为10，再与R4构建树，根节点权值为16。</p>
<p><img src="https://img-blog.csdnimg.cn/5f341abaf883454fad55f3b8e3a357eb.png" alt="5-28"></p>
<p>此时树的$WPL&#x3D;1<em>4+2</em>4+2<em>3+5</em>2+6*1&#x3D;34$，而此时I&#x2F;O次数只需68次，先前图5-25进行归并则需I&#x2F;O88次，明显用哈夫曼树效率提高。</p>
<p>而当进行k叉归并时，若<strong>初始归并段的数量无法构成严格的k叉归并树，则需要补充几个权值为0的“虚段”</strong>，再进行k叉哈夫曼树的构造。</p>
<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/8ece6b66cca8402d93d54be5052407bd.png" alt="5-29"></p>
<p>此时图2-29若想进行3路归并，显然会少一个结点，此时就可以填补一个虚段0，从而满足严格3叉归并树。</p>
<p><img src="https://img-blog.csdnimg.cn/b4790fa1c7ef4ac99399bee9d2271985.png" alt="5-30"></p>
<p>再构建3叉哈夫曼树：</p>
<p><img src="https://img-blog.csdnimg.cn/df0646c468dc48f3a25f93bdbf558cf7.png" alt="5-31"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LsWorld</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/11/03/shu-ju-jie-gou-pai-xu/">http://example.com/2023/11/03/shu-ju-jie-gou-pai-xu/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LsWorld</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                    <span class="chip bg-color">数据结构</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: url('../../source/mouse-click-solid.png'),pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'arRvTlzSn9CAss8hbeBtFvpV-gzGzoHsz',
        appKey: 'FgLccL6NmYrYIouy47VKkySf',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/11/04/shu-dian-men-dian-lu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="数电-门电路">
                        
                        <span class="card-title">数电-门电路</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-11-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E7%94%B5/" class="post-category">
                                    数电
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E7%94%B5/">
                        <span class="chip bg-color">数电</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/10/25/shu-ju-jie-gou-cha-zhao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="数据结构-查找">
                        
                        <span class="card-title">数据结构-查找</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-10-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            LsWorld
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="chip bg-color">数据结构</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2025</span>
            
            <a href="/about" target="_blank">LsWorld</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "4";
                        var startDate = "10";
                        var startHour = "16";
                        var startMinute = "38";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/lsWorl" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1428903832@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1428903832" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1428903832" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,147,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
