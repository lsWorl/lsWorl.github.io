<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统-计算机系统概述</title>
      <link href="/2024/01/12/cao-zuo-xi-tong-ji-suan-ji-xi-tong-gai-shu/"/>
      <url>/2024/01/12/cao-zuo-xi-tong-ji-suan-ji-xi-tong-gai-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5><p>并发是指两个或多个事件在同一时间间隔内发生，宏观上可以说是同时发生的，但微观上是交替发生的。</p><p><strong>并行</strong>。指两个或多个事件在同一时刻同时发生。</p><p>注：</p><p><strong>单核CPU</strong>同一时刻只能执行一个程序，各个程序只能并发地执行。</p><p><strong>多核CPU</strong>同一时刻可以同时执行多个程序，多个程序可以并行地执行。</p><p>比如Intel第八代i3处理器就是4核CPU，意味着可以并行地执行4个程序。</p><p>并发性是操作系统一个最基本的特性。</p><h5 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h5><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>共享又可分为以下两种方式：</p><ol><li>互斥共享方式。系统中的某些资源一个时间段内只允许一个进程访问该资源。</li><li>同时共享方式。允许一个事件段内由多个进程“同时”对它们进行访问。</li></ol><h5 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h5><p>虚拟是把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，以不可预知的速度向前推进，就是进程的异步性。</p><h4 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a>操作系统运行环境</h4><p>操作系统会根据CPU的程序状态字寄存器（PSW）来判断当前操作系统的状态，一般操作系统会有两种状态：</p><ul><li>内核态。处于内核态时，说明此时正在运行内核程序，此时可以执行<strong>特权指令</strong>（特权指令就是指只有处于内核态才能执行的指令）。</li><li>用户态。处于用户态时，说明此时正在运行的是应用程序，此时只能执行<strong>非特权指令</strong>。</li></ul><p>而当CPU处于用户态时若对CPU发出特权指令会使CPU<strong>引发一个中断信号</strong>，并强制进入内核态来处理当前中断信号的内核程序。</p><p>若<strong>内核态转用户态</strong>：只有执行一条特权指令——修改PSW的标志为“用户态”才会转变。</p><p>若<strong>用户态转内核态</strong>：则由一个中断信号引发。</p><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><p><img src="https://img-blog.csdnimg.cn/direct/570618772ff84f4eabc959d8f49abac7.png"></p><p>操作系统一般都会进行分层，而根据内核所覆盖的范围则引申出“大内核”和“微内核”。</p><p><img src="https://img-blog.csdnimg.cn/direct/efde02b8bfeb49918d2edc6c3bab4cff.png"></p><h5 id="大内核"><a href="#大内核" class="headerlink" title="大内核"></a>大内核</h5><p>大内核也称宏内核或单内核，其是将操作系统的主要功能模块都作为系统内核，运行在核心态。</p><p>有高性能的优点。</p><p>缺点是内核代码庞大，结构混乱，难以维护。</p><h5 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h5><p>微内核构架是只把最基本的功能保留在内核。</p><p>优点是内核功能少，结构清晰，方便维护。</p><p>缺点是需要频繁的在核心态和用户态之间切换，性能低。</p><h4 id="各操作系统结构的优缺点"><a href="#各操作系统结构的优缺点" class="headerlink" title="各操作系统结构的优缺点"></a>各操作系统结构的优缺点</h4><p><img src="https://img-blog.csdnimg.cn/direct/b2fa1bda55a744cbbdc6a61878e8e91c.png"></p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机就是使用虚拟化计数，将一台物理机器虚拟化为多台虚拟机器VM，每个虚拟机器都可以独立运行一个操作系统。</p><p><img src="https://img-blog.csdnimg.cn/direct/a28e2358bccf4e629c3ae6d53d40ce78.png"></p><p><img src="https://img-blog.csdnimg.cn/direct/f4cdc025904147e8a6ee07b0df14c206.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-IO系统基本概念</title>
      <link href="/2024/01/08/ji-suan-ji-zu-cheng-yuan-li-io-xi-tong-ji-ben-gai-nian/"/>
      <url>/2024/01/08/ji-suan-ji-zu-cheng-yuan-li-io-xi-tong-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="IO控制方式简介"><a href="#IO控制方式简介" class="headerlink" title="IO控制方式简介"></a>IO控制方式简介</h3><p>假设有这么一段代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> i<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>当上方代码执行到<code>scanf(&quot;%c&quot;, &amp;i);</code>此时需要I&#x2F;O设备来输入内容使程序继续进行下去。</p><p>此时CPU有两种解决方案：</p><ol><li><strong>程序查询方式</strong>：CPU不断轮询检查I&#x2F;O控制器的状态寄存器，检测到状态为”已完成“后，再从数据寄存器取出输入数据。</li><li><strong>程序中断方式</strong>：等待键盘I&#x2F;O时可以先让CPU执行其他程序，键盘I&#x2F;O完成后I&#x2F;O控制器<strong>向CPU发出中断请求</strong>，CPU响应中断请求，并取走输入数据。</li></ol><p>用上述方法都需要用CPU做中转站来让主存和IO设备相互联系。</p><p><img src="https://img-blog.csdnimg.cn/direct/8c1da7a6e7ae4d12b6dc1e436237d2ee.png"></p><p>若对磁盘等高速外设就不适合使用上诉方法，因此就可以用DMA（Direct Memory Access）控制方式。</p><p><strong>DMA控制方式</strong>：主存和高速io设备之间建立一条直接数据通路。每完成一整块数据读写后才向CPU发出一次中断请求。</p><p><img src="https://img-blog.csdnimg.cn/direct/8489af5225cd4116a30c75e8eb6163af.png"></p><h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p>有的商用机可能会接上大量的IO设备，因此全让CPU管理就效率太过低下，因此引入了通道控制方式。</p><p>通道使具有特殊功能的处理器，能对IO设备进行统一管理。</p><p><img src="https://img-blog.csdnimg.cn/direct/d9e3d58e0e75416fb514c0d7b9abaa7e.png"></p><p>通道可以识别并执行一系列通道指令，通道指令种类、功能通常比较单一。</p><h4 id="I-x2F-O系统指令"><a href="#I-x2F-O系统指令" class="headerlink" title="I&#x2F;O系统指令"></a>I&#x2F;O系统指令</h4><p>I&#x2F;O指令是CPU指令的一部分，通常由操作码、命令码和设备码组成。</p><p><img src="https://img-blog.csdnimg.cn/direct/aa4b2e0393f746feaeffddcceb3150f6.png"></p><p>操作码指明CPU要对IO接口做什么，命令码指明IO接口要对设备做什么。</p><h4 id="显示存储器（VRAM）"><a href="#显示存储器（VRAM）" class="headerlink" title="显示存储器（VRAM）"></a>显示存储器（VRAM）</h4><p>也称<strong>刷新存储器</strong>，为了不断提高刷新图形的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</p><p><strong>VARM容量&#x3D; 分辨率 × 灰度级位数</strong>。</p><p><strong>VARM带宽&#x3D; 分辨率 × 灰度级位数 × 帧频</strong>。</p><h3 id="I-x2F-O接口的作用"><a href="#I-x2F-O接口的作用" class="headerlink" title="I&#x2F;O接口的作用"></a>I&#x2F;O接口的作用</h3><p>I&#x2F;O接口中大体上包含了数据寄存器、控制寄存器与状态寄存器，分别能实现以下的主要功能：</p><ol><li>数据缓冲：通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配。</li><li>错误或状态检测：通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用。</li><li>控制和定时：接受从控制总线发来的控制信号、时钟信号。</li><li>与主机的设备通信：实现 主机——IO设备—IO设备之间的通信</li></ol><h3 id="I-x2F-O端口及其编址"><a href="#I-x2F-O端口及其编址" class="headerlink" title="I&#x2F;O端口及其编址"></a>I&#x2F;O端口及其编址</h3><p>I&#x2F;O端口可分为数据端口（读或写）、控制端口（写）和状态端口（读），端口若想被CPU访问，就必须对各个端口进行编号。</p><h4 id="统一编址"><a href="#统一编址" class="headerlink" title="统一编址"></a>统一编址</h4><p><img src="https://img-blog.csdnimg.cn/direct/8cfcfba6df6d466fae6db37e0b9b1f24.png"></p><p>又称<strong>存储器映射方式</strong>，把IO端口和内存一起分配，靠<strong>不同的地址码</strong>区分内存和IO设备。CPU不需要设置专门的IO指令，用统一的访存指令就可以访问IO端口。RISC机器常用，因为这种机器只有LOAD、STORE两个取指指令。</p><p><strong>优点</strong>：</p><p>不需要专门的输入&#x2F;输出指令，所有访存指令都可直接访问端口，程序设计灵活性高</p><p>端口有较大的编址空间。</p><p>读写控制逻辑电路简单。</p><p><strong>缺点：</strong></p><p>端口占用了主存地址空间，使主存地址空间变小外设寻址时间长。</p><h4 id="独立编址"><a href="#独立编址" class="headerlink" title="独立编址"></a>独立编址</h4><p>靠不同的<strong>指令</strong>区分内存的IO设备。只能用专门的IO指令访问IO端口。</p><p><img src="https://img-blog.csdnimg.cn/direct/045564ee40254e2ba3aa8711d6dfed21.png"></p><p>Intel处理器常用IN、OUT就是IO指令。</p><p><strong>优点：</strong></p><p>使用专用IO指令，程序编制清晰，IO端口地址位数少，地址译码速度快，IO端口的地址不占用主存地址空间。</p><p><strong>缺点：</strong></p><p>IO指令类型少，一般只能对端口进行传送操作，程序设计灵活性差。</p><p>需要CPU提供存储器读&#x2F;写、IO设备读&#x2F;写两组控制信号，增加了控制逻辑电路的复杂性。</p><h3 id="程序中断"><a href="#程序中断" class="headerlink" title="程序中断"></a>程序中断</h3><p>CPU响应中断必须满足以下3个条件：</p><ol><li>中断源有中断请求。</li><li>CPU允许中断即开中断。</li><li>一条指令执行完毕，且没有更紧迫的任务。</li></ol><h4 id="程序中断判优"><a href="#程序中断判优" class="headerlink" title="程序中断判优"></a>程序中断判优</h4><p>中断判优既可以用硬件实现，也可以用软件实现。</p><p>硬件实现是通过<strong>硬件排队器</strong>实现，它既可以设置在CPU中，也可以分散在各个中断源中；</p><p>软件实现是通过<strong>查询程序</strong>实现。</p><h4 id="中断隐指令的主要任务"><a href="#中断隐指令的主要任务" class="headerlink" title="中断隐指令的主要任务"></a>中断隐指令的主要任务</h4><ol><li>关中断。在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所大端，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能正确继续执行下去。</li><li>保存断点。为了保证在中断服务程序执行完后能正确返回到原先程序，必须保存PC的内容。</li><li>引出中断服务程序。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）。</li></ol><p><strong>单重中断</strong>：执行中断服务程序时<strong>不响应</strong>新的中断请求。</p><p><strong>多重中断</strong>：又称中断嵌套，执行中断服务程序<strong>可响应</strong>新的中断请求。</p><p><img src="https://img-blog.csdnimg.cn/direct/5187c5dacdfc4f0987ba450e130ad667.png"></p><h4 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h4><p>中断屏蔽技术会用屏蔽字来作为是否要中断屏蔽的依准，一般用“1”表示屏蔽，“0”表示正常申请。</p><p>例：设某机有4个中断源A、B、C、D，其硬件排队优先次序为A&gt;B&gt;C&gt;D,现要求中断次序改为D&gt;A&gt;C&gt;B。</p><p>1.写出每个中断源对应的屏蔽字。</p><p><img src="https://img-blog.csdnimg.cn/direct/8a003238daae4b6d8fbb8d79970ca006.png"></p><p>A只可以被D中断，所以D的中断信号为0。B可被除自己以外的信号中断，所以除自身以外都为0。C可由A和D屏蔽，所以A和D为0。D优先级最低，所以屏蔽字全为1。</p><p>2.按下图所示的时间轴给出4个中断源的请求时刻，画出CPU执行程序的轨迹。设每个中断服务程序执行时间均为20us。</p><p><img src="https://img-blog.csdnimg.cn/direct/8eba60f1a0d34c88b81ff57c11f6b87d.png"></p><p>由上方描述可得下图：</p><p><img src="https://img-blog.csdnimg.cn/direct/a3e1dc31782b4ca59300e96b147ee8ae.png"></p><p>开始B先执行，由于B的次序最低，到执行到D会打断B的执行，然后D完成后继续执行B，再当B执行到10us时执行A（A的次序高于B），A执行完成后再执行B，B执行到15u秒又被C打断执行，执行完C后最后再完成B。</p><h4 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h4><p>主存和DMA接口之间有一条直接数据通路。</p><p>由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，<strong>IO与主机并行工作，程序和传送并行工作</strong>。</p><p>DMA方式具有下列特点：</p><ol><li>它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。</li><li>在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li><li>主存中要开辟专用缓冲区，及时供给和接受外设的数据</li><li>DMA传送速度快，CPU和外设并行工作，提高了系统效率。</li><li>DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</li></ol><p><strong>DMA方式和中断方式的区别和特点</strong></p><p><img src="https://img-blog.csdnimg.cn/direct/1db671682378469583b9896d1939de08.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 输入输出系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-总线概述</title>
      <link href="/2024/01/05/ji-suan-ji-zu-cheng-yuan-li-zong-xian-gai-shu/"/>
      <url>/2024/01/05/ji-suan-ji-zu-cheng-yuan-li-zong-xian-gai-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h3><p>总线是一组能为多个部件同时共享的公共信息传送线路。由于总线发送信号，与总线连接的所有部件都能接受到，所以<strong>同一时刻只能有一个部件发送数据</strong>。可<strong>有多个部件同时接受数据</strong>。</p><p><img src="https://img-blog.csdnimg.cn/direct/c7b06567f9e84fcf8eb86815ea13d20b.png"></p><h5 id="总线的特点："><a href="#总线的特点：" class="headerlink" title="总线的特点："></a>总线的特点：</h5><p>共享：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路<strong>分时共享</strong>。</p><p>分时：指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时向总线发送信息。</p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><h4 id="串行总线与并行总线"><a href="#串行总线与并行总线" class="headerlink" title="串行总线与并行总线"></a>串行总线与并行总线</h4><p><strong>串行总线：</strong></p><p>每次传送只传送1bit数据。</p><p>优点：只需要一条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间。</p><p>缺点：在数据发送和接受的时候要进行拆卸和装配，要考虑串行，并行转换的问题。</p><p><strong>并行总线：</strong></p><p>每次可以并行发送多bit数据。</p><p>优点：总线的逻辑时序比较简单，电路实现起来比较容易。</p><p>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高昂；由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。</p><h4 id="按功能进行划分"><a href="#按功能进行划分" class="headerlink" title="按功能进行划分"></a>按功能进行划分</h4><h5 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h5><p>片内总线式芯片内部的总线，如CPU内部寄存器与寄存器之间、ALU之间的公共连接线。</p><h5 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h5><p>系统总线式计算机系统内各功能部件（CPU、主存、I&#x2F;O接口）之间相互连接的总线。又可分为数据总线、地址总线和控制总线。</p><p><strong>数据总线</strong>的根数与机器字长、存储字长有关，为双向传输。</p><p><strong>地址总线</strong>的根数与主存地址空间大小及设备数量有关，为单向传输。</p><p><strong>控制总线</strong>用于传输控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号。</p><h3 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h3><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p><img src="https://img-blog.csdnimg.cn/direct/0468dbe4f3e24fc9ab6ef941f3c12c72.png"></p><p>单总线结构将CPU、主存、I&#x2F;O设备都连接在一组总线上，允许I&#x2F;O设备之间、I&#x2F;O设备和CPU之间直接交换信息。</p><p><strong>优点</strong>：结构简单，成本低，易于接入新的设备。</p><p><strong>缺点</strong>：带宽低、父爱中，多个部件只能争用唯一的总线，且不支持并发传送操作。</p><h4 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h4><p><img src="https://img-blog.csdnimg.cn/direct/5ff17cfc03c6489eb36453d973fed39b.png"></p><p>双总线结构式用两条总线，一条是<strong>主存总线</strong>，用于CPU、主存和通道之间进行数据传送；另一条是<strong>I&#x2F;O总线</strong>，用于多个外部设备与通道之间进行数据传送。</p><p>上图<strong>通道是具有特殊功能的处理器</strong>，对输入输出设备统一管理。</p><p>该模式支持<strong>突发传送</strong>（送出一个地址，收到多个地址连续的数据）。</p><p><strong>优点</strong>：将较低俗的I&#x2F;O设备从单总线上分离处理，实现存储器总线和I&#x2F;O设备分离。</p><p><strong>缺点</strong>：需要增加通道等硬件设备。</p><h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><p><img src="https://img-blog.csdnimg.cn/direct/a28a1ef60ecb4f67a192bbb0d1fdb1c6.png"></p><p>三总线结构式在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为主存总线、I&#x2F;O总线和直接内存访问DMA总线。</p><p><strong>优点</strong>：提高了I&#x2F;O设备的性能，使其更快地响应命令，提高系统吞吐量。</p><p><strong>缺点</strong>：系统工作效率较低、</p><h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h3><h4 id="总线的传输周期（总线周期）"><a href="#总线的传输周期（总线周期）" class="headerlink" title="总线的传输周期（总线周期）"></a>总线的传输周期（总线周期）</h4><p><strong>指一次总线操作所需的时间</strong>。总线传输周期通常由若干各总线时钟周期构成。</p><h4 id="总线时钟周期"><a href="#总线时钟周期" class="headerlink" title="总线时钟周期"></a>总线时钟周期</h4><p>即<strong>机器的时钟周期</strong>。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。（现代计算机中，总线时钟周期也有可能由桥接器设备提供）。</p><h4 id="总线的工作频率"><a href="#总线的工作频率" class="headerlink" title="总线的工作频率"></a>总线的工作频率</h4><p>总线上各种操作的频率，为<strong>总线周期的倒数</strong>。若总线周期&#x3D;N个时钟周期，则总线的工作频率&#x3D;时钟频率&#x2F;N。实际上表示<strong>总线在一秒内会传送几次数据</strong>。</p><h4 id="总线的时钟频率"><a href="#总线的时钟频率" class="headerlink" title="总线的时钟频率"></a>总线的时钟频率</h4><p>即机器的时钟频率，为<strong>时钟周期的倒数</strong>。若时钟周期为T，则时钟频率为1&#x2F;T.</p><p>实际上指<strong>一秒内由多少个时钟周期</strong>。</p><h4 id="总线宽度"><a href="#总线宽度" class="headerlink" title="总线宽度"></a>总线宽度</h4><p>又称为总线位宽，它是<strong>总线上同时能够传输的数据位数</strong>，通常指<strong>数据总线的根数</strong>，如32根称为32位总线。</p><h4 id="总线带宽"><a href="#总线带宽" class="headerlink" title="总线带宽"></a>总线带宽</h4><p>可理解为总线的数据传输率，即<strong>单位时间内总线上可传输数据的位数</strong>，通常每秒传送信息的字节数来衡量，单位可用字节&#x2F;秒表示。<br>$$<br>总线带宽&#x3D;总线工作频率\times 总线宽度(bit&#x2F;s)&#x3D;总线工作频率\times(总线宽度&#x2F;8)(B&#x2F;s)<br>$$<br>总线带宽指的是总线本身所能达到的<strong>最高传输速率</strong>。</p><h4 id="总线复用"><a href="#总线复用" class="headerlink" title="总线复用"></a>总线复用</h4><p>总线复用是指一种信号线在<strong>不同时间传输不同的信息</strong>。可以使用较少的线传输更多的信息，从而节省了空间和成本。</p><h4 id="信号线数"><a href="#信号线数" class="headerlink" title="信号线数"></a>信号线数</h4><p>地址总线、数据总线和控制总线3种总线数的总和称为信号线数。</p><h3 id="总线传输"><a href="#总线传输" class="headerlink" title="总线传输"></a>总线传输</h3><p>总线传输总共分为四个阶段：</p><ol><li>申请分配阶段：由需要使用总线的主模块提出申请，经总线仲裁后决定下一传输周期的总线使用权。也可将此阶段细分为<strong>传输请求和总线仲裁</strong>两个阶段。</li><li>寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址和相关命令。</li><li>传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送。</li><li>结束阶段：主模块<strong>有关信息</strong>均从系统总线上撤除，让出总线使用权。</li></ol><p>总线传输会根据其定时方式来协调发送和接受双方的传送定时关系。</p><h4 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h4><p>总线控制器采用<strong>统一的时钟信号</strong>来协调发送和接受双方的传送定时关系。</p><p>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。</p><p>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性差。</p><p>同步通信适用于<strong>总线长度较短</strong>以及总线所接<strong>部件的存取时间近</strong>的系统。</p><h4 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h4><p>异步定时方式通过传输双方相互制约的“握手”信号来实现定时控制。</p><p>优点：总线周期长度可变，可保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</p><p>缺点：比同步控制方式复杂，速度比同步定时慢。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-多处理器的基本概念</title>
      <link href="/2024/01/05/ji-suan-ji-zu-cheng-yuan-li-duo-chu-li-qi-de-ji-ben-gai-nian/"/>
      <url>/2024/01/05/ji-suan-ji-zu-cheng-yuan-li-duo-chu-li-qi-de-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="SISD、SIMD、MIMD的基本概念"><a href="#SISD、SIMD、MIMD的基本概念" class="headerlink" title="SISD、SIMD、MIMD的基本概念"></a>SISD、SIMD、MIMD的基本概念</h4><h5 id="单指令流单数据流（SISD）结构"><a href="#单指令流单数据流（SISD）结构" class="headerlink" title="单指令流单数据流（SISD）结构"></a>单指令流单数据流（SISD）结构</h5><p>该计算机通常仅包含一个处理器和一个存储器。</p><p><strong>特性</strong>：</p><ul><li>各指令序列只能并发、不能并行，每条指令处理一两个数据。</li><li>不是数据级并行技术。</li></ul><p><strong>硬件组成</strong>：</p><ul><li>一个处理器+一个主存储器</li><li>若采用指令流水线，需设置多个功能部件，采用多模块交叉存储器。</li></ul><p>前面介绍的计算机架构都是SISD结构。</p><h5 id="单指令流多数据流-SIMD"><a href="#单指令流多数据流-SIMD" class="headerlink" title="单指令流多数据流(SIMD)"></a>单指令流多数据流(SIMD)</h5><p><strong>特性</strong>：</p><ul><li>各指令序列只能并发、不能并行，但每条指令可同时处理多个数据。</li><li>是一个数据级并行技术。</li></ul><p><strong>硬件组成</strong>：</p><ul><li>一个指令控制部件（CU）+多个处理单元&#x2F;执行单元（如ALU）+多个局部存储器+一个主存储器</li><li>每个执行单元有各自的寄存器组、局部寄存器及地址寄存器。</li><li>不同执行单元执行同一条指令，处理不同的数据。</li></ul><h5 id="多指令流单数据流（MISD）"><a href="#多指令流单数据流（MISD）" class="headerlink" title="多指令流单数据流（MISD）"></a>多指令流单数据流（MISD）</h5><p>能同时执行多条指令，处理同一个数据，现实中不存在这种计算机。</p><h5 id="多指令流多数据流（MIMD）"><a href="#多指令流多数据流（MIMD）" class="headerlink" title="多指令流多数据流（MIMD）"></a>多指令流多数据流（MIMD）</h5><p>如现实中的intel i5或 i7等处理器。</p><p><strong>特性</strong>：</p><ul><li>各指令序列并行执行，分别处理多个不同的数据。</li><li>是一种线程级并行，甚至是线程级以上并行技术。</li></ul><p>进一步分类可分为：</p><ul><li><p>多处理器系统</p><ul><li><p>特性：</p><p>各处理器之间，可以通过LOAD&#x2F;STORE指令，访问同一个主存储器，可通过主存相互传送数据。</p></li><li><p>硬件组成：</p><ul><li>一台计算机内，包含多个处理器+一个主存储器。</li><li><strong>多个处理器共享单一的物理地址空间</strong>。</li></ul></li></ul></li><li><p>多计算机系统（如分布式计算系统）</p><ul><li><p>特性：</p><p>各计算机之间，不能通过LOAD&#x2F;STORE指令直接进行访问对方的存储器，只能通过“消息传递”相互传送数据。</p></li><li><p>硬件组成：</p><ul><li>由多个计算机组成，因此由多个处理器+多个主存储器</li><li>每台计算机拥有各自的私有存储器，物理地址空间相互独立。</li></ul></li></ul></li></ul><h5 id="向量处理器（SIMD思想的进阶应用）"><a href="#向量处理器（SIMD思想的进阶应用）" class="headerlink" title="向量处理器（SIMD思想的进阶应用）"></a>向量处理器（SIMD思想的进阶应用）</h5><p><strong>特性</strong>：</p><ul><li>一条指令的处理对象是”向量”</li><li>擅长对向量型数据并行计算、浮点数运算，常被用超级计算机中，处理科学研究中巨大运算量。</li></ul><p><strong>硬件组成</strong>：</p><ul><li>多个处理单元，多组“向量寄存器”。</li><li>主存储器采用“多个端口同时读取”的交叉多模块存储器。</li><li>主存储器大小限定了机器的解题规模，因此要有多容量、集中式的主存储器。</li></ul><h4 id="硬件多线程的概念"><a href="#硬件多线程的概念" class="headerlink" title="硬件多线程的概念"></a>硬件多线程的概念</h4><p><img src="https://img-blog.csdnimg.cn/direct/24417f29440b4d48ba30a971bdbd2fe0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 中央处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-指令流水线</title>
      <link href="/2024/01/04/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-liu-shui-xian/"/>
      <url>/2024/01/04/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-liu-shui-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a>指令流水的定义</h3><p>一条指令的执行过程可以分成多个阶段，每个阶段功能由相应的功能部件完成。而视各阶段为相应的流水段，则指令的执行过程就构成了一条指令流水线。</p><h4 id="顺序执行方式"><a href="#顺序执行方式" class="headerlink" title="顺序执行方式"></a>顺序执行方式</h4><p>即只有上一条指令完成后才能进行下一条指令的执行。</p><p>若设取指、分析、执行三个阶段的时间都相等，用t表示，顺序执行方式可得：</p><p><img src="https://img-blog.csdnimg.cn/direct/391d9004a20848b481d94729866b87fc.png"></p><p>总耗时T&#x3D;$n\times 3t&#x3D;3nt$。</p><p>传统的冯诺依曼机就是采用顺序执行方式，该方式<strong>又称串行执行方式</strong>。</p><p><strong>优点</strong>：控制简单，硬件代价小。</p><p><strong>缺点</strong>：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。</p><h4 id="一次重叠执行方式"><a href="#一次重叠执行方式" class="headerlink" title="一次重叠执行方式"></a>一次重叠执行方式</h4><p><img src="https://img-blog.csdnimg.cn/direct/a3a92cdf98b549a8a875bc778013e01f.png"></p><p>总耗时T&#x3D;$(n-1)\times 2t+3t&#x3D;(1+2n)t$。</p><p><strong>优点</strong>：程序的执行时间缩短了1&#x2F;3，各功能部件的利用率提高。</p><p><strong>缺点</strong>：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂。</p><h4 id="二次重叠执行方式"><a href="#二次重叠执行方式" class="headerlink" title="二次重叠执行方式"></a>二次重叠执行方式</h4><p><img src="https://img-blog.csdnimg.cn/direct/659018fb623b42a5b2c9b11ee77e428e.png"></p><p>总耗时T&#x3D;$(n-1)\times t+3t&#x3D;(2+n)t$。</p><p><strong>优点</strong>：与顺序执行程序的执行时间缩短了2&#x2F;3，各功能部件的利用率提高，这是一种理想的指令执行方式。</p><h4 id="流水线的表示方法"><a href="#流水线的表示方法" class="headerlink" title="流水线的表示方法"></a>流水线的表示方法</h4><p><img src="https://img-blog.csdnimg.cn/direct/c185c24d2a994770bdbea16736fa63d1.png"></p><p><strong>指令流程图</strong>用于分析影响流水线的因素。</p><p><strong>时空图</strong>用于分析流水线的性能。</p><h4 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h4><ol><li><p>吞吐率。吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量。</p><p>设任务数为n：处理完成n各任务所用的时间为T</p><p>则流水线吞吐率（TP）的基本公式为<strong>TP&#x3D;n&#x2F;T</strong>。</p></li><li><p>加速比。完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。</p></li><li><p>效率。流水线的设备利用率。</p><p>一般公式为<br>$$<br>E&#x3D;\frac{n个任务占用k时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}<br>$$</p></li></ol><h3 id="影响流水线的因素"><a href="#影响流水线的因素" class="headerlink" title="影响流水线的因素"></a>影响流水线的因素</h3><h4 id="结构相关（资源冲突）"><a href="#结构相关（资源冲突）" class="headerlink" title="结构相关（资源冲突）"></a>结构相关（资源冲突）</h4><p>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。</p><p><img src="https://img-blog.csdnimg.cn/direct/6532ec71f4e04ce582105410940290d6.png"></p><p>解决方法：</p><ol><li>后一相关指令暂停一周期</li><li>资源重复配置： 数据存储器+指令存储器分配到不同的地方。</li></ol><h4 id="数据相关（数据冲突）"><a href="#数据相关（数据冲突）" class="headerlink" title="数据相关（数据冲突）"></a>数据相关（数据冲突）</h4><p>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。</p><p><img src="https://img-blog.csdnimg.cn/direct/7257d649a71b47758f09f4880a23888f.png"></p><p>解决方法：</p><ol><li>把遇到数据相关的指令及其后序指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为<strong>硬件阻塞（stall）</strong>和<strong>软件插入“NOP”（空操作）</strong>两种方法。</li><li>数据旁路技术。</li><li>编译优化：通过编译器调整指令顺序来解决数据相关。</li></ol><h4 id="控制相关（控制冲突）"><a href="#控制相关（控制冲突）" class="headerlink" title="控制相关（控制冲突）"></a>控制相关（控制冲突）</h4><p>当流水线遇到转移指令和其他改变PC指的指令而造成断流时，会引起控制相关。</p><p><img src="https://img-blog.csdnimg.cn/direct/d6351a69895549a9a23f82358d4f2660.png"></p><h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><h4 id="超标量流水线技术"><a href="#超标量流水线技术" class="headerlink" title="超标量流水线技术"></a>超标量流水线技术</h4><p><img src="https://img-blog.csdnimg.cn/direct/71923b0393004092b068025117f7278d.png"></p><p>每个时钟周期内可并发多条独立指令，要配置多个功能部件，且<strong>不能调整</strong>指令的执行顺序。</p><p>通过编译优化技术来把可并行的指令搭配起来。</p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p><img src="https://img-blog.csdnimg.cn/direct/a505035d66244fc9aef5fda8a001b1e0.png"></p><p>在一个时钟周期内再分段，在一个时钟周期内<strong>一个功能部件使用多次</strong>。同样不能调整指令的执行顺序。</p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p><img src="https://img-blog.csdnimg.cn/direct/b65da3b88bda41d29ef8ed0b135e5b8b.png"></p><p>由编译程序挖掘出指令间<strong>潜在的并行性</strong>，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 中央处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-控制器的功能和工作原理</title>
      <link href="/2023/12/28/ji-suan-ji-zu-cheng-yuan-li-kong-zhi-qi-de-gong-neng-he-gong-zuo-yuan-li/"/>
      <url>/2023/12/28/ji-suan-ji-zu-cheng-yuan-li-kong-zhi-qi-de-gong-neng-he-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><p>硬布线控制器时根据指令操作码、目前的时钟周期、节拍信号以及机器状态条件来发出“微命令”。</p><p>下方图中<strong>FE为取值阶段、IND为间接寻址阶段、EX为执行阶段、INT为中断阶段</strong>。</p><p><img src="https://img-blog.csdnimg.cn/direct/c256e97608ac415588b82c90b0b845f0.png"></p><h4 id="硬布线控制器的设计"><a href="#硬布线控制器的设计" class="headerlink" title="硬布线控制器的设计"></a>硬布线控制器的设计</h4><p>设计步骤：</p><ol><li>分析每个阶段的微操作序列（取值、间址、执行、中断四个阶段），确定指令在什么阶段。</li><li>选择CPU的控制方式，确定采用定长机器周期还是不定长机器周期，每个机器周期安排几个节拍。</li><li>安排微操作时序，如何在规定节拍内完成整个机器周期的所有微操作。</li><li>电路设计</li></ol><h5 id="取值周期内的微操作"><a href="#取值周期内的微操作" class="headerlink" title="取值周期内的微操作"></a>取值周期内的微操作</h5><p>取值周期所有的指令都是一样的，即</p><p>PC -&gt; MAR</p><p>1 -&gt; R</p><p>M(MAR) -&gt; MDR</p><p>MDR -&gt; IR</p><p>OP(IR) -&gt; ID（指令译码器，Instruction Decoder）</p><p>(PC) + 1 -&gt; PC</p><h5 id="间址周期内的微操作"><a href="#间址周期内的微操作" class="headerlink" title="间址周期内的微操作"></a>间址周期内的微操作</h5><p>该阶段所有指令都一样</p><p>Ad(IR) -&gt; MAR 将IR地址码部分放到MAR中，即形式地址来找有效地址</p><p>1 -&gt; R</p><p>M(MAR) -&gt; MDR     找到有效地址的数据放入MDR中</p><p>MDR -&gt; Ad(IR)</p><h5 id="执行周期的微操作"><a href="#执行周期的微操作" class="headerlink" title="执行周期的微操作"></a>执行周期的微操作</h5><p>由于该阶段指令所执行的微操作各不相同，就以各些为例：</p><ul><li><p>CLA（clear ACC指令，将ACC清零）：</p><p>0 -&gt; ACC（也可以写作AC）</p></li><li><p>LDA X（取数指令，把X所指内容取到ACC中）</p><p>Ad(IR) -&gt; MAR</p><p>1 -&gt; R</p><p>M(MAR) -&gt; MDR</p><p>MDR -&gt; AC</p></li><li><p>JMP X（无条件转移到X的位置）</p><p>Ad(IR) -&gt; PC</p></li><li><p>BAN X （条件转移，Branch ACC Negative，当ACC为负时候转移）</p><p>$A_0\cdot Ad(IR) +\overline{A_0}\cdot (PC) \rightarrow PC$</p></li></ul><p>硬布线控制器的特点：</p><ul><li>指令越多，设计和实现就越复杂，因此一般用RISC</li><li>如果扩充一条新的指令，则控制器设计需要大改，因此扩充指令比较困难。</li><li>由于纯硬件实现控制，因此执行速度快，微操作控制信号由组合逻辑电路即时产生。</li></ul><h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>微程序设计设计的基本概念：</p><ol><li><p>微命令与微操作。一条机器指令可以分解称一个微操作序列，微操作是计算机中最基本、不可再分解的操作。微命令和微操作时一一对应的。<strong>微命令时微操作的控制信号，微操作是微命令的执行过程</strong>。</p></li><li><p>微指令与微周期。<strong>微指令是多个微命令的集合，是对指令执行步骤的描述</strong>，<strong>微周期</strong>是从CM（控制器存储器）中取出一条微指令并执行相应微操作所需的时间。</p><p>一条微指令的基本由<strong>操作控制字段和顺序控制字段（指明下一条微指令的地址）</strong>组成。</p></li><li><p>程序与微程序。程序是由指令序列组成，而微程序是由微指令序列组成，<strong>每一种指令对应一个微程序</strong>。</p></li></ol><h4 id="微程序的基本组成"><a href="#微程序的基本组成" class="headerlink" title="微程序的基本组成"></a>微程序的基本组成</h4><p><img src="https://img-blog.csdnimg.cn/direct/4b172149f6f440c2bf01be7835a9de86.png"></p><p>图中下地址存放的是下一条要执行的微指令，CM（控制器存储器）是用于存放微指令序列。</p><h4 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h4><p>在设计微指令前需要了解的概念：</p><ul><li>相容性微命令。可以并行完成的微命令。</li><li>互斥性微命令。不允许并行完成的微命令。</li></ul><h5 id="水平型微指令"><a href="#水平型微指令" class="headerlink" title="水平型微指令"></a>水平型微指令</h5><p>一条微指令能定义<strong>多个</strong>可并行的微指令。</p><p>优点是微指令条数少，微程序短，执行速度快；缺点是微指令长，编写微程序较麻烦。</p><p><img src="https://img-blog.csdnimg.cn/direct/40209d375c5041ff8ac2e0aa584011e0.png"></p><h5 id="垂直型微指令"><a href="#垂直型微指令" class="headerlink" title="垂直型微指令"></a>垂直型微指令</h5><p>一条微指令只能定义一个微命令，由微操作码字段规定具体功能。</p><p>优点是微指令短、简单、规整，便于编写微程序；缺点是微程序长，微指令条数多，执行速度慢，工作效率低。</p><p><img src="https://img-blog.csdnimg.cn/direct/e9c56cb68fb641fa83c4ed3ebd50c87d.png"></p><h4 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h4><p>微指令的编码方式主要对水平型微指令进行探讨。目的是保证速度的情况下，尽量缩短微指令字长。</p><h5 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h5><p>在微指令的操作控制字段中，每一位代表一个微操作命令。</p><p>某位为“1”表示该控制信号有效，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/direct/c59ca5646c354b268888004ff98331fd.png"></p><p>优点是简单、直观，执行速度快，操作可并行；</p><p>缺点是微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大。</p><h5 id="字段直接编码方式"><a href="#字段直接编码方式" class="headerlink" title="字段直接编码方式"></a>字段直接编码方式</h5><p>将微指令的控制字段分成若干“段”，<strong>每段经译码后发出控制信号</strong>。</p><p>微命令字段分段原则：</p><ol><li>互斥性微命令分在同一段内，相容性微命令分在不同段内。</li><li>每小段包含信息位不能太多</li><li>每小段应留出一个状态，表示本字段不发出任何微命令，当字段长度为3时，只能表示7个互斥的微命令，通常用000表示不操作。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/e12f87ddb903451fbc14077004d0748d.png"></p><p>优点：可以缩短微指令字长。</p><p>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。</p><h5 id="字段间接译码方式"><a href="#字段间接译码方式" class="headerlink" title="字段间接译码方式"></a>字段间接译码方式</h5><p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接译码，又称隐式编码。</p><p>优点：可进一步缩短微指令字长。</p><p>缺点：削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段。</p><h4 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h4><ol><li><p>微指令的下地址字段指出</p><p>微指令格式中设置一条下地址字段，<strong>由微指令的下地址字段直接指出后继微指令的地址</strong>，这种方式又称为<strong>断定方式</strong>。</p></li><li><p>根据机器指令的操作码形成</p><p>当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</p></li><li><p>增量<strong>计数器法</strong></p><p>像CPU中CP一样，即 (CMAR)+1 -&gt; CMAR</p></li><li><p>分支转移</p></li><li><p>通过测试网络</p></li><li><p>由硬件产生微程序入口地址</p></li></ol><h4 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h4><p>设计步骤：</p><ol><li><p>分析每个阶段的微操作序列</p></li><li><p>写出对应机器的微操作命令及节拍安排</p><ol><li><p>写出每个周期所需的微操作（参照硬布线）</p></li><li><p>补充微程序控制器特有的微操作：</p><p>a.取指周期：</p><p>  Ad(CMDR) -&gt; CMAR</p><p>  OP(IR) -&gt; CMAR</p><p>b.执行周期：</p><p>  Ad(CMDR) -&gt; CMAR</p></li></ol></li><li><p>确定微指令格式</p><p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。</p><p>根据CM中存储的微指令总数，确定微指令的顺序控制字段的位数。</p><p>最后按操作控制字段位数和顺序控制字段位数就可以确定微指令字长。</p></li><li><p>编写微指令码点</p><p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</p></li></ol><p><strong>例：</strong></p><h5 id="取指周期-微程序控制器的节拍安排"><a href="#取指周期-微程序控制器的节拍安排" class="headerlink" title="取指周期-微程序控制器的节拍安排"></a>取指周期-微程序控制器的节拍安排</h5><p>假设取指周期为三个节拍</p><p>T_0PC-&gt;MAR将PC中指令放到MAR中</p><p>T_01-&gt; R向主存发送读信号</p><p>T_1(PC) + 1 -&gt; PCPC加“1”来指向下一个要执行的指令</p><p>T_1M(MAR) -&gt; MDR将主存中地址MAR中的数据放入MDR中</p><p>T_2MDR -&gt; IR将MDR存一份到IR中</p><p>T_2OP(IR)-&gt; 微地址形成部件将IR的操作码发送给微地址形成部件</p><p>此时取指操作用三个微指令即可完成</p><p>而每执行完<strong>一条微指令</strong>的命令后要在最后用一个节拍实现<code>Ad(CMDR) -&gt; CMAR</code>来将CMDR的下地址信息送给CMAR，使CMAR有下一条地址的信息。取指周期内最后还要执行指令：<code>OP(IR)-&gt;微地址形成部件-&gt;CMAR</code></p><p><img src="https://img-blog.csdnimg.cn/direct/ebf7a6561af242eb9d857bcfb7b7d273.png"></p><h4 id="微程序设计分类"><a href="#微程序设计分类" class="headerlink" title="微程序设计分类"></a>微程序设计分类</h4><ol><li><p>静态微程序设计和动态微程序设计</p><ul><li>静态。微程序无需改变，采用<strong>ROM</strong>实现。</li><li>动态。通过<strong>改变微指令和微程序</strong>改变机器指令，有利于仿真，采用EPROM</li></ul></li><li><p>毫微程序设计</p><p>毫微程序设计就是用<strong>毫微程序解释微程序</strong>。对微程序的更深一层的套娃。</p></li></ol><h4 id="微程序控制器和硬布线控制器的区别"><a href="#微程序控制器和硬布线控制器的区别" class="headerlink" title="微程序控制器和硬布线控制器的区别"></a>微程序控制器和硬布线控制器的区别</h4><p><img src="https://img-blog.csdnimg.cn/direct/13c85edc1c13429a917e3585a438d031.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 中央处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-数据通路的功能和基本结构</title>
      <link href="/2023/12/27/ji-suan-ji-zu-cheng-yuan-li-shu-ju-tong-lu-de-gong-neng-he-ji-ben-jie-gou/"/>
      <url>/2023/12/27/ji-suan-ji-zu-cheng-yuan-li-shu-ju-tong-lu-de-gong-neng-he-ji-ben-jie-gou/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="数据通路的基本结构"><a href="#数据通路的基本结构" class="headerlink" title="数据通路的基本结构"></a>数据通路的基本结构</h3><p>数据通路的基本概念：</p><ul><li>内部总线。使指同一部件，如CPU内部连接各个寄存器及运算部件之间的总线；</li><li>系统总线。是指同一台计算机系统的各部件，如CPU、内存、通道和各类IO接口间互相连接的总线。</li></ul><h4 id="CPU内部单总线方式"><a href="#CPU内部单总线方式" class="headerlink" title="CPU内部单总线方式"></a>CPU内部单总线方式</h4><p>单总线模式就是将所有寄存器的输入和输出端都连接到一条公共通路上，这种结构简单，但数据传输存在较多冲突现象，性能较低。</p><p><img src="https://img-blog.csdnimg.cn/direct/dcee86e9816d4c3f84359908255b1260.png"></p><h5 id="单总线模式下寄存器之间数据传送"><a href="#单总线模式下寄存器之间数据传送" class="headerlink" title="单总线模式下寄存器之间数据传送"></a>单总线模式下寄存器之间数据传送</h5><p>若想把PC内容送至MAR，实现传送操作的流程及控制信号为：</p><p>(PC)-&gt;Bus，即PC先把信号发送给CU，然后CU给PCout高电平，使PC的值可以传送到总线中。</p><p>Bus-&gt;MAR，然后CU给MARIN高电平，总线内容传入MAR中。</p><h5 id="单总线模式下主存与CPU之间的数据传送"><a href="#单总线模式下主存与CPU之间的数据传送" class="headerlink" title="单总线模式下主存与CPU之间的数据传送"></a>单总线模式下主存与CPU之间的数据传送</h5><p>把CPU中数据发送给主存，比如CPU从主存读取指令，流程如下：</p><p>(PC)-&gt;Bus-&gt;MAR    Pcout和MARin有效，将PC中值通过总线放到MAR中</p><p>1-&gt;R CU发读命令（通过控制总线发出），使MAR可以通过地址总线将地址传到主存。</p><p>MEM(MAR)-&gt;MDR       MDRin有效，将主存中MAR地址所对应的数据放到MDR中。</p><p>MDR-&gt;Bus-&gt;IR     MDRout和IRin有效，将现行指令的数据放入到IR（用于存储当前正在执行的指令）中</p><h5 id="单总线模式下执行算术或逻辑运算"><a href="#单总线模式下执行算术或逻辑运算" class="headerlink" title="单总线模式下执行算术或逻辑运算"></a>单总线模式下执行算术或逻辑运算</h5><p>比如执行一条加法指令，其流程为：</p><p>Ad(IR)-&gt;Bus-&gt;MARMDRout和MARin有效，将当前IR的地址通过CPU内部总线送到MAR中</p><p>1-&gt;R CU发读命令</p><p>MEM(MAR)-&gt;MDR         MDRin有效</p><p>MDR-&gt;Bus-&gt;YMDRout和Yin有效，将操作数放入Y寄存器</p><p>(ACC)+(Y)-&gt;Z   ACCout和ALUin有效，CU向ALU发送加命令</p><p>Z-&gt;ACC    Zout和ACCin有效，结果放回ACC。</p><h4 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h4><p>根据指令执行过程的数据和地址流动方向来安排连接线路，避免使用共享总线，该方案性能高，但硬件量大。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 中央处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-指令执行过程</title>
      <link href="/2023/12/27/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-zhi-xing-guo-cheng/"/>
      <url>/2023/12/27/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-zhi-xing-guo-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>了解指令执行过程之前，需要了解指令的一些基本概念。</p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>指令周期是CPU从主存中每取出并执行一条指令所需的全部时间。</p><p>指令周期常常用若干<strong>机器周期</strong>来表示，机器周期又叫<strong>CPU周期</strong>。</p><p>而一个机器周期又包含若干<strong>时钟周期</strong>（也成为节拍、T周期或CPU时钟周期，它是CPU操作的<strong>最基本单位</strong>）</p><p><img src="https://img-blog.csdnimg.cn/direct/13609ceb2afc47e0b0c92a72cee39763.png"></p><p>由上图可得每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。</p><p>指令工作周期总共可以区分为四个阶段：取值周期、间址周期、执行周期和中断周期，而为了区别不同的工作周期，在CPU内设置4个标志触发器FE（对应取值）、IND（对应间址）、EX（对应执行）、INT（对应中断）来区别为哪个工作周期。</p><h4 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h4><h5 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h5><p>若想进行取指，首先PC会想MAR发送当前指令地址，然后CU会发出控制信号，经控制总线传到主存，同时MAR中地址信息也会通过地址总线发送到主存中，此时主存中所读出的数据会通过数据总线传到MDR中，最后将MDR中获取到的数据放到IR中，就完成了一次取指操作。</p><p><img src="https://img-blog.csdnimg.cn/direct/220441749bc645ac8a54c98ebfa70b42.png"></p><h5 id="间指周期"><a href="#间指周期" class="headerlink" title="间指周期"></a>间指周期</h5><p>有些指令取完后会进入间指周期，此时IR中已经放着数据的地址，要再通过取指操作来进行间接寻址。</p><h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4><h5 id="单指令周期"><a href="#单指令周期" class="headerlink" title="单指令周期"></a>单指令周期</h5><p>将所有指令都选用相同的执行时间（即最长的那条指令）来完成。</p><p>指令之间串行执行，每条指令只能等前一条指令执行结束后才能启动。</p><p>缺点：对于本来可以在短时间完成的指令需要使用较长的周期来完成。</p><h5 id="多指令周期"><a href="#多指令周期" class="headerlink" title="多指令周期"></a>多指令周期</h5><p>对不同类型的指令选用不同的执行步骤，指令间串行执行，在前一条执行结束后才能执行下一条，可以用不同个数的时钟周期完成不同指令的执行过程。</p><p>缺点：需要设计更复杂的硬件设计。</p><h5 id="流水线方案"><a href="#流水线方案" class="headerlink" title="流水线方案"></a>流水线方案</h5><p>指令之间可以并行执行的方案，其追求是在每个时钟脉冲周期完成一条指令的执行过程。可以使尽量让多条指令同时运行。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 中央处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-CPU的功能和基本结构</title>
      <link href="/2023/12/27/ji-suan-ji-zu-cheng-yuan-li-cpu-de-gong-neng-he-ji-ben-jie-gou/"/>
      <url>/2023/12/27/ji-suan-ji-zu-cheng-yuan-li-cpu-de-gong-neng-he-ji-ben-jie-gou/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><p>中央处理器CPU由控制器和运算器组成。</p><p>CPU的具体功能包括：</p><ol><li>指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。</li><li>操作控制。一条指令的功能往往由若干操作信号的组合来实现。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求尽心动作。</li><li>时间控制。对各种操作加以时间上的控制。</li><li>数据加工。对数据进行算术和逻辑运算。</li><li>中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。</li></ol><h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><p>CPU主要由运算器和控制器组成，</p><p>运算器主要负责对数据的加工，进行逻辑和算术运算等操作。</p><p>控制器负责协调并控制计算机各部件执行指令的顺序等操作，包括取指令、分析指令、中断等操作。</p><p><img src="https://img-blog.csdnimg.cn/direct/dcbe30f1f6f743b59fe2e6cf8fcf6c70.png"></p><h4 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h4><p>运算器由算术逻辑单元(ALU)、通用寄存器组、暂存寄存器、累加寄存器（ACC）、程序状态寄存器（PSW）、移位器、计数器（CT）等所组成。</p><p>算术逻辑单元主要功能是进行算术&#x2F;逻辑运算。</p><p>通用寄存器如AX、BX、CD、SP（堆栈指针，用于指示栈顶的地址）等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等，下图的通用寄存器AX中的AH表示高地址部分，AL表示地址部分。</p><p><img src="https://img-blog.csdnimg.cn/direct/c591b4a6866b470f91fe2e575f79e8f6.png"></p><h5 id="ALU与寄存器之间的连线方式"><a href="#ALU与寄存器之间的连线方式" class="headerlink" title="ALU与寄存器之间的连线方式"></a>ALU与寄存器之间的连线方式</h5><ol><li><p>使用专用数据通路方式；根据指令执行过程中的数据和地址的流动方向安排线路，每个寄存器都有专门的导线与ALU相连。</p><p>若直接用导线相连，为防止多个寄存器同时向ALU传输数据，可以用多路选择器或三态门来解决该问题。</p><p><img src="https://img-blog.csdnimg.cn/direct/bb40888c18d6492aabd7dac483d4d183.png" alt="三态门解决"></p></li><li><p>CPU内部单总线方式：将所有寄存器输入和输出端都连接到一条公共通路上。</p><p>该方法需要搭配暂存寄存器，结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。</p><p><img src="https://img-blog.csdnimg.cn/direct/742d185be2f64c98a1dab41f030b08d8.png"></p></li></ol><h4 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h4><p>控制器由程序计数器（PC）、指令寄存器（IR）、指令译码器、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、时序系统和微操作信号发生器等组成。</p><ol><li>程序计数器。用于指出<strong>下一条指令</strong>在主存中的存放地址，PC由自增功能。</li><li>指令寄存器。当取出一条指令后，会将指令放到指令寄存器中，用来保存当前正在执行的指令。</li><li>指令译码器。将指令寄存器中操作码部分进行译码，然后向控制器提供特定的操作信号。</li><li>微操作信号发生器。根据译码器中的译码结果来确定接下来CPU要执行哪些操作。</li><li>时序系统。来产生各种时序信号，让微操作系统来确定先执行哪些操作。</li><li>存储器地址寄存器（MAR）。存放要访问主存单元的地址，</li><li>存储器数据寄存器（MDR）。存放向主存写入的信息或从主存读出的信息。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/5d10de8ab4f6449797f0b0df55f55802.png"></p><p><strong>注：CPU内部程序计数器PC、程序状态寄存器PSW、累加器和通用寄存器组是对用户可见的，可供汇编程序员进行操作。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 中央处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-CISC和RISC的基本概念</title>
      <link href="/2023/12/26/ji-suan-ji-zu-cheng-yuan-li-cisc-he-risc-de-ji-ben-gai-nian/"/>
      <url>/2023/12/26/ji-suan-ji-zu-cheng-yuan-li-cisc-he-risc-de-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="复杂指令系统计算机（CISC-Complex-Instruction-Set-Computer）"><a href="#复杂指令系统计算机（CISC-Complex-Instruction-Set-Computer）" class="headerlink" title="复杂指令系统计算机（CISC, Complex Instruction Set Computer）"></a>复杂指令系统计算机（CISC, Complex Instruction Set Computer）</h3><p>设计思路：<strong>一条指令完成一个复杂的基本功能</strong>，例，x86架构，主要用于笔记本，台式机等。</p><p>CISC的主要特点：</p><ol><li>指令系统复杂庞大，指令数目一般200条以上。</li><li>指令长度不固定。</li><li>可以访存的指令不受限制。</li><li>各种指令使用频率相差大。</li><li>各种指令指令时间相差大。</li><li>控制器大多数采用微程序控制。</li><li>难以优化编译生成高效的目标代码程序。</li></ol><h3 id="精简指令系统计算机（RISC-Reduced-Instruction-Set-Computer）"><a href="#精简指令系统计算机（RISC-Reduced-Instruction-Set-Computer）" class="headerlink" title="精简指令系统计算机（RISC, Reduced Instruction Set Computer）"></a>精简指令系统计算机（RISC, Reduced Instruction Set Computer）</h3><p>设计思路：一条指令完成一个基本“动作”；<strong>多条指令组合完成一个复杂的基本功能</strong>，例，ARM架构，主要用于手机、平板等。</p><p>RISC的主要特点：</p><ol><li>选取使用频率最高的一些简单指令，复杂指令功能由简单指令的组合来实现。</li><li>指令长度固定，指令格式种类少。</li><li>只有<code>Load/Store</code>（取数，存数）指令能访存，其余指令的操作都在寄存器之间进行。</li><li>CPU中通用寄存器数量多。</li><li>RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li><li>以硬布线控制为主。</li><li>重视编译优化工作，以减少程序执行时间。</li></ol><h3 id="CISC和RISC的比较"><a href="#CISC和RISC的比较" class="headerlink" title="CISC和RISC的比较"></a>CISC和RISC的比较</h3><p><img src="https://img-blog.csdnimg.cn/direct/beb0a0fed12544b4bd920dd3f3b1e513.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-程序的机器代码表示</title>
      <link href="/2023/12/23/ji-suan-ji-zu-cheng-yuan-li-cheng-xu-de-ji-qi-dai-ma-biao-shi/"/>
      <url>/2023/12/23/ji-suan-ji-zu-cheng-yuan-li-cheng-xu-de-ji-qi-dai-ma-biao-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="x86汇编语言指令基础"><a href="#x86汇编语言指令基础" class="headerlink" title="x86汇编语言指令基础"></a>x86汇编语言指令基础</h3><p>x86汇编语言是指所有结尾为86型号的cpu所能解析的语言。</p><p>指令的格式为：操作码 + 地址码。</p><p>以mov操作（mov指令功能，将源操作数s复制到目的操作数d所指的位置）为例：</p><p>mov eax,ebx：意思是将<strong>寄存器ebx的值</strong>复制到<strong>寄存器eax</strong>中。</p><p>mov eax,5: 意思是将<strong>立即数5</strong>复制到<strong>寄存器eax</strong>中。</p><p>mov eax, dword ptr [af996h]：意思是将<strong>内存地址 af996h</strong>所指的<strong>32bit值</strong>复制到<strong>寄存器eax</strong>中。</p><p>mov byte ptr [af996h], 5：意思是将立即数5复制到<strong>内存地址 af996h</strong>所指的<strong>一字节中</strong>。</p><p>内存读写长度的指明：</p><p><strong>dword ptr</strong>——双字， 32bit</p><p><strong>word ptr</strong>——单字，16bit</p><p><strong>byte ptr</strong>——字节，8bit</p><h4 id="x86架构相关寄存器"><a href="#x86架构相关寄存器" class="headerlink" title="x86架构相关寄存器"></a>x86架构相关寄存器</h4><p><img src="https://img-blog.csdnimg.cn/direct/e76ccc256a844bf7bdc6271a1102bf07.png"></p><p>若通用寄存器去掉开头的英文字母E，即AX,BX,CX,DX，此时<strong>大小为低16bit</strong>。</p><p>若未指明主存读写长度时，<strong>默认32bit</strong>。</p><p>例： mov eax, [ebx] 等价于 mov eax, dword ptr [ebx]</p><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>以下的s均为源操作数（source），d为目的操作数（destination）。且目的操作数不可为常量，x86中两操作数<strong>不允许同时来自内存中</strong>。</p><h5 id="常见的算术运算指令"><a href="#常见的算术运算指令" class="headerlink" title="常见的算术运算指令"></a>常见的算术运算指令</h5><p>add d,s：add，加，把s加到d中。</p><p>sub d,s：subtract，减，d中减去s。</p><p>mul d,s：multiply，乘，无符号数d*s，乘积存入d。</p><p>imul d,s：有符号数d*s，乘积存入d。</p><p>div s：divide，除，无符号数除法，被除数会隐含放入到edx:eax（将被除数位扩展）中，然后edx:eax &#x2F; s，商存入eax，余数存入edx。</p><p>idiv s：有符号数除法，被除数会隐含放入到edx:eax中，然后edx:eax &#x2F; s，商存入eax，余数存入edx。</p><p>neg d：negative，将d取负数，结果存入d。</p><p>inc d：increase，d++。</p><p>dec d：decrease，d–。</p><h5 id="常见的逻辑运算指令"><a href="#常见的逻辑运算指令" class="headerlink" title="常见的逻辑运算指令"></a>常见的逻辑运算指令</h5><p>and d,s：and，将d、s逐位相与，结果放回d。</p><p>or d,s：or，将d、s逐位相或，结果放回d</p><p>not d：not，将d逐位取反，结果放回d</p><p>xor d,s：exclusive or，将d、s逐位异或，结果放回d</p><p>shl d,s：shift left，将d逻辑左移s位，结果放回d（通常s是常量）</p><p>shr d,s：shift right，将d逻辑右移s位，结果放回d（通常s是常量）</p><h5 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h5><p>用于实现<strong>分支结构、循环结构</strong>的指令：cmp、test、jmp、jxxx</p><p>用于<strong>实现函数调用</strong>的指令：push、pop、call、ret</p><p>用于<strong>实现数据转移</strong>的指令：mov</p><h3 id="AT-amp-T格式和Intel格式"><a href="#AT-amp-T格式和Intel格式" class="headerlink" title="AT&amp;T格式和Intel格式"></a>AT&amp;T格式和Intel格式</h3><p>AT&amp;T制定的汇编语言格式通常用于Unix、linux</p><p>Intel制定的汇编语言格式通常用于windows</p><p><img src="https://img-blog.csdnimg.cn/direct/fd57bf2fd85b49d393ed45c3485f157e.png"></p><h3 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h3><p><strong>注：在Intel x86处理器中，程序计数器PC（Program Counter）通常被称为IP（Instruction Pointer）。</strong></p><h4 id="无条件转移指令——jmp"><a href="#无条件转移指令——jmp" class="headerlink" title="无条件转移指令——jmp"></a>无条件转移指令——jmp</h4><p>无条件转移指令格式： jmp &lt;地址&gt;</p><p>使用jmp会让PC无条件转移至&lt;地址&gt;，地址可以是常量、寄存器或来自主存。</p><p>例：</p><p>jmp 128：跳转到地址为128的位置</p><p>jmp eax：跳转到eax寄存器中所指的位置</p><p>jmp [999]：跳转到主存地址999中所指的位置</p><p><img src="https://img-blog.csdnimg.cn/direct/88a3f65c772943bdbc7c26f8c02aecd2.png"></p><p>除了以上方法使用jmp，也可以<strong>使用“标号”锚定位置</strong>（用冒号结尾，名字可以自己取）。</p><p><img src="https://img-blog.csdnimg.cn/direct/20bdf0a4515a47bcaa93585eff75ef25.png"></p><h4 id="条件转移指令——jxxx"><a href="#条件转移指令——jxxx" class="headerlink" title="条件转移指令——jxxx"></a>条件转移指令——jxxx</h4><p>条件转移指令一般要和<code>cmp</code>指令一起使用</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cmp</span> a,b   <span class="token comment">#比较a和b两个数</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash">je <span class="token operator">&lt;</span>地址<span class="token operator">></span>   <span class="token comment">#jump when equal，若a==b跳转</span>jne <span class="token operator">&lt;</span>地址<span class="token operator">></span>  <span class="token comment">#jump when not equal，若a!=b跳转</span>jg <span class="token operator">&lt;</span>地址<span class="token operator">></span>   <span class="token comment">#jump when greater than，若a>b跳转</span>jl <span class="token operator">&lt;</span>地址<span class="token operator">></span>   <span class="token comment">#jump when less than, 若a>=b跳转</span>jle <span class="token operator">&lt;</span>地址<span class="token operator">></span>  <span class="token comment">#jump when less than or equal to,若a&lt;=b跳转</span></code></pre><p>例：</p><p>若有这么一段C语言代码</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">></span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    c<span class="token operator">=</span>a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    c <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>则用汇编表示</p><pre class="language-bash" data-language="bash"><code class="language-bash">mov eax,a   <span class="token comment">#将变量a存入eax</span>mov ebx,b   <span class="token comment">#将变量b存入ebx</span><span class="token function">cmp</span> eax,ebx <span class="token comment">#比较a和b的值</span>jg NEXT     <span class="token comment">#若a>b，转移到NEXT:</span>mov ecx,ebx <span class="token comment">#假设ecx存储变量c，令c=b</span>jmp END     <span class="token comment">#无条件转移到END:</span>NEXT:mov ecx,eax <span class="token comment">#假设ecx存储变量c，令 c=a</span>END:</code></pre><h3 id="循环语句的机器级表示"><a href="#循环语句的机器级表示" class="headerlink" title="循环语句的机器级表示"></a>循环语句的机器级表示</h3><p>例</p><p>有这么一段循环代码</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    result <span class="token operator">+=</span> i<span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//求 1+2+3+...+100</span></code></pre><p>上方代码用汇编实现，即</p><pre class="language-bash" data-language="bash"><code class="language-bash">mov eax,0   <span class="token comment">#用eax保存result,初始值为0</span>mov edx,1   <span class="token comment">#用edx保存 i,初始值为1</span><span class="token function">cmp</span> edx,100 <span class="token comment">#比较 i和100</span>jg L2       <span class="token comment">#若i>100,转跳到L2执行</span>L1:         <span class="token comment">#循环主体</span><span class="token function">add</span> eax,edx <span class="token comment">#实现 result +=i</span>inc edx     <span class="token comment">#inc 自增指令，实现i++</span><span class="token function">cmp</span> edx,100 <span class="token comment">#比较 i和100</span>jle L1      <span class="token comment">#若 i&lt;=100，则转跳到L1执行</span>L2:         <span class="token comment">#跳出循环主体</span></code></pre><h4 id="用loop指令实现循环"><a href="#用loop指令实现循环" class="headerlink" title="用loop指令实现循环"></a>用loop指令实现循环</h4><p>x86中还提供了<code>loop</code>指令来实现循环</p><p>例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//coding...</span><span class="token punctuation">&#125;</span> </code></pre><p>用汇编实现</p><pre class="language-bash" data-language="bash"><code class="language-bash">mov ecx,500     <span class="token comment">#用ecx作为循环计数器</span>Looptop:        <span class="token comment">#循环的开始</span><span class="token punctuation">..</span>.coding<span class="token punctuation">..</span>.<span class="token punctuation">..</span>.loop Looptop   <span class="token comment">#ecx--，若ecx!=0,跳转到Looptop</span></code></pre><p>上方<code>loop Looptop</code>指令等价于<code>dec ecx   cmp ecx,0   jne Looptop</code>三条指令。</p><p><strong>注：loop是默认对ecx进行操作，用loop通用寄存器只能用ecx作为循环计数器</strong></p><h3 id="函数调用的机器级表示"><a href="#函数调用的机器级表示" class="headerlink" title="函数调用的机器级表示"></a>函数调用的机器级表示</h3><p>在高级语言中，每个函数都有自己的栈区，称为栈帧，一个栈由若干个栈帧组成。目前正在执行的函数栈帧是一定位于栈顶。</p><p>函数调用x86汇编语言一般会通过<code>call/ret</code>指令来实现。</p><h4 id="call-x2F-ret指令"><a href="#call-x2F-ret指令" class="headerlink" title="call&#x2F;ret指令"></a>call&#x2F;ret指令</h4><p>用于实现子程序的调用及返回。</p><p>例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//coding...</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>x86汇编实现</p><pre class="language-bash" data-language="bash"><code class="language-bash">main: <span class="token punctuation">..</span>. coding<span class="token punctuation">..</span>. <span class="token punctuation">..</span>. call <span class="token function">add</span>  <span class="token comment">#这里调用了call函数</span> <span class="token punctuation">..</span>. ret       <span class="token comment">#main函数结束</span></code></pre><p><strong>call指令</strong>的作用：</p><ul><li>将IP旧值压栈保存（效果相对于push IP）</li><li>设置IP新值，无条件转移至被调用函数的第一条指令（效果相对于 jmp xxx）。</li></ul><h4 id="函数调用栈在内存中的位置"><a href="#函数调用栈在内存中的位置" class="headerlink" title="函数调用栈在内存中的位置"></a>函数调用栈在内存中的位置</h4><p>若有一台32位x86系统（<strong>x86系统默认以4字节为栈的操作单位</strong>），进程虚拟地址空间位4GB，高地址的1GB为操作系统内核区，低地址3GB为用户区，函数调用栈在用户区的高地址部分，具体如图所示。</p><p><img src="https://img-blog.csdnimg.cn/direct/425042383e12452b8ac82cb2778672b4.png"></p><p>若想使用栈，则需要用到EBP（堆栈基指针）,ESP（堆栈顶指针）通用寄存器，<strong>EBP指向当前栈帧的“底部”，ESP指向当前栈帧的“顶部”</strong>。</p><h4 id="访问栈帧数据"><a href="#访问栈帧数据" class="headerlink" title="访问栈帧数据"></a>访问栈帧数据</h4><h5 id="使用push和pop指令访问"><a href="#使用push和pop指令访问" class="headerlink" title="使用push和pop指令访问"></a>使用push和pop指令访问</h5><p>若要操作栈，则需使用<code>push</code>和<code>pop</code>指令，<code>push</code>会先让esp减4（即指向低地址的数据），后可以将立即数、寄存器或主存地址压入到栈顶，<code>pop</code>则是将栈顶元素出栈，然后放到寄存器或主存地址中，再让esp加4（指向高地址的数据）。</p><p>例：</p><pre class="language-bash" data-language="bash"><code class="language-bash">push eax     <span class="token comment">#将寄存器eax的值压栈</span>push <span class="token number">985</span>     <span class="token comment">#将立即数985压栈</span>push <span class="token punctuation">[</span>ebp+8<span class="token punctuation">]</span> <span class="token comment">#将主存地址[ebp+8]里的数据压栈</span>pop eax      <span class="token comment">#栈顶元素出栈，写入寄存器eax</span>pop <span class="token punctuation">[</span>ebp+8<span class="token punctuation">]</span>  <span class="token comment">#栈顶元素出栈，写入主存地址[ebp+8]</span></code></pre><h5 id="使用mov指令访问"><a href="#使用mov指令访问" class="headerlink" title="使用mov指令访问"></a>使用mov指令访问</h5><p>例：</p><pre class="language-bash" data-language="bash"><code class="language-bash">sub esp,12       <span class="token comment">#栈顶指针-12</span>mov <span class="token punctuation">[</span>esp+8<span class="token punctuation">]</span>,eax  <span class="token comment">#将eax的值复制到主存[esp+8]中</span><span class="token function">add</span> esp,8        <span class="token comment">#栈顶指针+8</span></code></pre><p><img src="https://img-blog.csdnimg.cn/direct/45238dbe37ee4b05997603babea92a7d.png"></p><p>即可以用mov指令，结合esp、ebp指针访问栈帧数据，用加法&#x2F;减法指令，即sub&#x2F;add修改栈顶指针esp的值。</p><h4 id="函数调用时，切换栈帧"><a href="#函数调用时，切换栈帧" class="headerlink" title="函数调用时，切换栈帧"></a>函数调用时，切换栈帧</h4><p>当函数调用时，可以通过<code>push ebp</code>和<code>mov ebp,esp</code>来切换栈帧。</p><p>例：</p><p>有这么一段汇编代码</p><pre class="language-bash" data-language="bash"><code class="language-bash">caller:push ebpmov ebp,esp<span class="token punctuation">..</span>.call <span class="token function">add</span><span class="token punctuation">..</span>.leaveret<span class="token punctuation">..</span>.<span class="token punctuation">..</span>.add:push ebpmov ebp,esp<span class="token punctuation">..</span>.<span class="token punctuation">..</span>.leaveret</code></pre><p>当上方代码运行到<code>call add</code>时，就会调用add函数，此时就需要切换栈帧，call指令一使用就会将IP旧值压栈，然后将新的IP值指向函数内的第一条指令，即<code>push ebp</code>，将栈低地址压入栈顶中，此时就是进行切换栈帧。</p><p><img src="https://img-blog.csdnimg.cn/direct/f429955c40364cdeb39ee5adc4f3459e.png"></p><p>执行<code>mov ebp,esp</code>，将<code>ebp</code>栈底寄存器指向栈顶，就实现了切换。</p><p><img src="https://img-blog.csdnimg.cn/direct/80e2f5b661e44a68a0d1cadde1628385.png"></p><p><strong>注：<code>push ebp</code>和<code>mov ebp,esp</code>可以精简为<code>enter</code>一条指令，效果相同</strong></p><p>若想<strong>恢复原先的栈帧</strong>，使用<code>mov esp,ebp</code>和<code>pop ebp</code>即可实现，这两条也等价于<code>leave</code>指令。</p><h4 id="栈帧中可能包含的内容"><a href="#栈帧中可能包含的内容" class="headerlink" title="栈帧中可能包含的内容"></a>栈帧中可能包含的内容</h4><ul><li><p>通常会将<strong>局部变量</strong>集中存储在<strong>栈帧底部区域</strong>。</p></li><li><p>通常将<strong>调用参数</strong>集中存储在<strong>栈帧顶部区域</strong>。</p></li><li><p><strong>栈帧最底部</strong>一定是<strong>上一层栈帧基址</strong>（ebp旧值）</p></li><li><p><strong>栈帧最顶部</strong>一定是<strong>返回地址</strong>（当前函数的栈帧除外）</p></li></ul><p><img src="https://img-blog.csdnimg.cn/direct/da107479656c4e63b438d28341003f3b.png"></p><p>使用<code>ebp-4</code>或<code>ebp-8</code>等就可以访问局部变量，用<code>esp+4</code>或<code>esp+8</code>等就可以访问调用参数</p><p>gcc编译器将每个栈帧大小设置为<strong>16B的整数倍</strong>（当前函数的栈帧除外），所以可能会出现中间空闲区域。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-指令的寻址方式</title>
      <link href="/2023/12/18/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-de-xun-zhi-fang-shi/"/>
      <url>/2023/12/18/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-de-xun-zhi-fang-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>寻址方式分为指令寻址和数据寻址两大类。寻找下一条将要执行的指令地址称为指令寻址；寻址本条指令的数据地址称为数据寻址。</p><h4 id="指令寻址-1"><a href="#指令寻址-1" class="headerlink" title="指令寻址"></a>指令寻址</h4><p>指令寻址方式有两种：一是顺序寻址，二是跳跃寻址。</p><h5 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h5><p>通过程序计数器PC加1（1个指令字长，实际加的值回因指令长度、编址方式而不同），自动形成下一条指令的地址。</p><p>例：</p><p>若某系统采用<strong>定长指令字结构</strong>，指令字长&#x3D;存储字长&#x3D;16bit&#x3D;2B，主存<strong>按字编址</strong>（即按2B编址）。</p><p><img src="https://img-blog.csdnimg.cn/direct/8d39647c533949928de8dc81ab8071da.png"></p><p>此时若取走地址直接让<strong>PC+1</strong>即可跳到下一条地址。</p><p>而若此时设某系统采用<strong>定长指令字结构</strong>，指令字长&#x3D;存储字长&#x3D;16bit&#x3D;2B，主存<strong>按字节编址</strong>（即按1B编址）。</p><p>此时一条指令占两个地址。</p><p><img src="https://img-blog.csdnimg.cn/direct/a25e6a104dd140029d1d7674937c6a61.png"></p><p>此时若想实现顺序寻址则需<strong>PC+2</strong>（2个指令字长）来形成下一条指令的地址。</p><h5 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h5><p>是指下条指令的地址不由程序计数器PC自动给出，而由<strong>本条指令给出下条指令地址的计算方式</strong>。</p><p>例：</p><p>若某系统采用<strong>定长指令字结构</strong>，指令字长&#x3D;存储字长&#x3D;16bit&#x3D;2B，主存<strong>按字编址</strong>（即按2B编址）。</p><p>指令结构如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/direct/5df32cc9fe42439d8c385eedf4f55df6.png"></p><p>当运行到第三条指令时，JMP为无条件转移，会将PC中的内容改成7，所以会跳到第7条指令地址进行执行。</p><h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><p>数据寻址的方式较多，为区别各种方式，通常会在指令字中设一个<strong>形式地址</strong>的字段，来表明用那种寻址方式，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/direct/b92c70f2408942bdb41c4d54248d6eb9.png"></p><p>在数据寻址中，会EA来表示有效地址，A表示形式地址。</p><p>默认指令字长&#x3D;机器字长&#x3D;存储字长</p><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>指令字中的形式地址A就是操作数的真实地址EA, EA&#x3D;A。</p><p>指令形式：</p><p><img src="https://img-blog.csdnimg.cn/direct/da12e4f66ecc4204a57b850cafcd01c4.png"></p><p>例：</p><p>若要对操作数3进行取值并放入寄存器中。</p><p><img src="https://img-blog.csdnimg.cn/direct/9cec856cbc664b0b9c420a857b62832e.png"></p><p>此时会先访存1次进行取指令，然后再访存1次执行指令，共访存2次。</p><p>直接寻址<strong>优点</strong>：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。</p><p>直接寻址<strong>缺点</strong>：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。</p><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>间接寻址中指令的地址字段给出的形式地址不是操作数的真正地址，而是<strong>操作数有效地址所在存储单元的地址</strong>，就是操作数地址的地址，即EA&#x3D;(A)。</p><p>指令形式：</p><p><img src="https://img-blog.csdnimg.cn/direct/da12e4f66ecc4204a57b850cafcd01c4.png"></p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/direct/380d6ab0fe764aba88450e0fc8e8efc0.png"></p><p>上图进行寻址，首先会进行取地址访存1次，然后执行指令找到A所在的数据，根据A的内容找到真正地址EA，访存2次，共访存3次。</p><p>也可以两次间接寻址：</p><p><img src="https://img-blog.csdnimg.cn/direct/49fb1807a74744da919ebb908a494d0c.png"></p><p>当<strong>主存字第一位为1时</strong>，表示取出的仍不是操作数的地址，需要多次间接寻址。只有当第一位为0时，表示取得的是操作数的地址。</p><p><strong>优点</strong>：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间接寻址可以方便地完成子程序返回）。</p><p><strong>缺点</strong>：指令在执行阶段要多次访存（一次间接寻址需两次访存，多次需根据存储字的最高位确定）。</p><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>寄存器寻址是指在指令字中给出操作数所在的寄存器编号，即EA&#x3D;$R_i$，其操作数在由$R_i$所指的寄存器内。</p><p>指令形式：</p><p><img src="https://img-blog.csdnimg.cn/direct/ea5efe764426493d9d84c1dfd4d7e2a4.png"></p><p>例：</p><p>若此时寄存器编号为1001，对应十进制9，会在$R_9$中进行寻址。</p><p><img src="https://img-blog.csdnimg.cn/direct/4c3d57b079944dc7bffef740196445ff.png"></p><p>此时只需取指令的时候进行访存1次，由于EA在寄存器中，所以执行指令无需访存，共访存1次。</p><p><strong>优点</strong>：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量&#x2F;矩阵运算。</p><p><strong>缺点</strong>：寄存器价格昂贵，计算机中寄存器个数有限。</p><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>指寄存器$R_i$中给出的不是一个操作数，而是操作数所在的主存单元的地址。即EA&#x3D;($R_i$)。</p><p>指令形式：</p><p><img src="https://img-blog.csdnimg.cn/direct/ea5efe764426493d9d84c1dfd4d7e2a4.png"></p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/direct/cfe395b5417443f1aee95997e85210dd.png"></p><p>用这种方式，取指令时需进行一次访存，执行指令也需访存1次，共访存2次。</p><p><strong>优点</strong>：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）</p><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>这种类型的指令不明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</p><p>例：</p><p>将A进行累加操作：</p><p><img src="https://img-blog.csdnimg.cn/direct/50330246d63a4c15b073d448313854fa.png"></p><p><strong>优点</strong>：有利于缩短指令字长</p><p><strong>缺点</strong>：需增加存储操作数或隐含地址的硬件。</p><h4 id="立即（数）寻址"><a href="#立即（数）寻址" class="headerlink" title="立即（数）寻址"></a>立即（数）寻址</h4><p>这种类型的指令地址字段指出的就是操作数本身，又称立即数，采用补码表示。</p><p>指令形式：</p><p><img src="https://img-blog.csdnimg.cn/direct/a94925ebb6c240fb92a045ad6bcb0b64.png"></p><p>例：</p><p>上方的形式地址就是十进制形式就是操作数3。</p><p>此时执行一条指令会取指令进行访存1次，由于已经是操作数，执行指令将不会访存，共访存1次。</p><p><strong>优点</strong>：指令执行阶段不访问主存，指令执行时间最短</p><p><strong>缺点</strong>：A的位数限制了立即数的范围。 如A的位数为n，且立即数采用补码时，可表示的数据范围为$-2^{n-1} $ ~ $ 2^{n-1} -1$</p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>将CPU中<strong>基址寄存器（BR）</strong>的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即$EA&#x3D;(BR)+A$。</p><p>基址寻址的硬件实现：</p><p><img src="https://img-blog.csdnimg.cn/direct/220b72bd46a3412b8ba6429ca2df112e.png"></p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/direct/6e34a4e8309541a29fbe9810b8b4120b.png"></p><p>在图中中若主存以100开始作为主存地址，地址码寻址取数a，此时a的主存地址为105，就可以将BR设置为0000 0000 0110 0100（十进制100），通过ALU，此时均可以实现基于100来进行有效地址的寻址。</p><p>注：基址寄存器是面向操作系统的，其<strong>内容由操作系统或管理程序确定</strong>。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。</p><p>当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其内容仍由操作系统确定。</p><p><strong>优点</strong>：便于程序“浮动”，方便实现多道程序并发运行。可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序。</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><p>是将有效地址EA等于指令字中的形式地址A与<strong>变址寄存器IX</strong>的内容相加之和，即<strong>EA&#x3D;(IX)+A</strong>，其中<font color="#ff0000">IX可为变址寄存器（专用）</font>，也<font color="#ff0000">可用通用寄存器作为变址寄存器</font>。</p><p>变址寻址的硬件实现：</p><p><img src="https://img-blog.csdnimg.cn/direct/42b106c94c584aa7a53850b4075dc4c4.png"></p><p>注：变址寄存器是<strong>面向用户</strong>的，在程序执行过程中，变址寄存器的内容可由用户改变（IX作为偏移量），形式地址A不变（作为基地址）。</p><p><strong>优点</strong>：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别<strong>适合编制循环程序</strong>。</p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即<strong>EA&#x3D;(PC)+A</strong>，其中A是相对于PC所指地址的<strong>位移量</strong>，可正可负，<strong>补码表示</strong>。</p><p>相对寻址的硬件实现：</p><p><img src="https://img-blog.csdnimg.cn/direct/393c50b0af1b498e8c31d582f4f3ca04.png"></p><p><strong>优点</strong>：操作数的地址不是固定，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此<strong>便于程序浮动</strong>（一段代码在程序内部的浮动）。相对寻址广泛<strong>应用于转移指令</strong>。</p><h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。</p><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”原则管理的存储区，该存储区中被读&#x2F;写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。</p><p>用寄存器来实现栈结构也称<strong>硬堆栈</strong>。而用主存中某一块区域来实现堆栈称为<strong>软堆栈</strong>。</p><p>下图是对寻址的总结：</p><p><img src="https://img-blog.csdnimg.cn/direct/1cdbc8a00a59486e8e469baad2ef0f23.png"></p>]]></content>
      
      
      <categories>
          
          <category> true </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-指令系统</title>
      <link href="/2023/12/17/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-xi-tong/"/>
      <url>/2023/12/17/ji-suan-ji-zu-cheng-yuan-li-zhi-ling-xi-tong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h3><p>一条指令就是机器语言的一个语句，是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分：</p><p><img src="https://img-blog.csdnimg.cn/direct/8f4ba22e153b4a7c8c8e0fdd1be0192c.png"></p><h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4><p>只给出操作码OP，没有显式地址，这种地址有两种可能：</p><ol><li>不需要操作数的指令，如空操作指令、停机指令、关中断指令等。</li><li>零地址的运算类指令<strong>仅用在堆栈计算机</strong>（例如后缀表达式）中。</li></ol><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><p><img src="https://img-blog.csdnimg.cn/direct/d7b94bc4a7924d8984cead9dc8cf2c62.png"></p><ol><li><p>只有目的操作数的单操作数指令，按$A_1$地址读取操作数，进行OP操作后，结果存回原地址。</p><p>指令含义：$OP（A_1）-&gt;A_1$</p><p>如操作码含义是加1、减1、求反、求补等。</p></li><li><p>隐含约定目的地址的双操作数指令，</p><p>例ACC，</p><p>指令函数：(ACC)OP$(A_1)$-&gt;ACC</p><p>若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围位$2^{24}&#x3D;16M$。</p></li></ol><h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><p><img src="https://img-blog.csdnimg.cn/direct/8e059c801e9b4da99e3945c65a4eb656.png"></p><p>常用于两个操作数的算数运算、逻辑运算相关指令</p><p>指令含义：$(A_1)OP(A_2)-&gt;A_1$</p><h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><p><img src="https://img-blog.csdnimg.cn/direct/98948468ee194470b8b5604f3d6d295b.png"></p><p>常用于序列两个操作数的算数运算、逻辑运算相关指令，结果用地址保存。</p><p>指令含义：$(A_1)OP(A_2)-&gt;A_3$</p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><p><img src="https://img-blog.csdnimg.cn/direct/d068f43ffa2a4c73866ba1cde4e389dc.png"></p><p>指令含义$(A_1)OP(A_2)-&gt;A_3, A_4&#x3D;$下一条将要执行指令的地址。</p><p>完成指令需要访存4次，取指-&gt;读A1-&gt;读A2 -&gt;写A3</p><h4 id="指令长度分类"><a href="#指令长度分类" class="headerlink" title="指令长度分类"></a>指令长度分类</h4><p>指令字长：一条指令的总长度。</p><p>机器字长：CPU进行依次整数运算所能处理的二进制数据的位数（通常与ALU有关）。</p><p>存储字长：一个存储单元中二进制代码位数（通常和MDR位数相同）。</p><p>半字长指令、单字长指令、双字长指令——通常指指令长度是机器字长的多少倍。</p><p><strong>定长指令字结构</strong>：指令系统所有指令长度<strong>都相等</strong>。</p><p><strong>变长指令字结构</strong>：指令系统中指令长度<strong>不等</strong>。</p><h4 id="操作类型分类"><a href="#操作类型分类" class="headerlink" title="操作类型分类"></a>操作类型分类</h4><ol><li><p>数据传送</p><p>LOAD ：把<strong>存储器</strong>中的数据放到<strong>寄存器</strong>中。</p><p>STORE ：把<strong>寄存器</strong>中的数据放到<strong>存储器</strong>中。</p></li><li><p>算数逻辑操作</p><p>加减乘除，逻辑就是与或非等运算。</p></li><li><p>移位操作</p><p>算术移位、逻辑移位、循环移位等。</p></li><li><p>转移操作</p><p>有无条件转移（JMP）、条件转移(BRANCH)、调用（CALL）、返回（SET）等。</p></li><li><p>输入输出操作</p><p>CPU寄存器与IO端口之间的数据传达。</p></li></ol><h3 id="拓展操作码指令格式"><a href="#拓展操作码指令格式" class="headerlink" title="拓展操作码指令格式"></a>拓展操作码指令格式</h3><p>例：</p><p>设指令字长为16位，每个地址码占4位；</p><p>前4位位基本操作码字段OP，另外3个4位长做地址字段。</p><p>4位基本操作码全用于三地址指令，则有16条。</p><p>但至少需将1111留作拓展操作码用，即三指令为15条、</p><p>而1111 1111也需留作拓展操作码用，二指令条为15条、</p><p>1111 1111 1111也需留作拓展操作码用，一指令条为15条、</p><p>零地址指令为16条。</p><p><img src="https://img-blog.csdnimg.cn/direct/3eb57de83cc2495e8108a6262120f5f7.png"></p><p>在设计拓展操作码<strong>需注意</strong>：</p><ol><li>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。</li><li>各指令的操作码一定不能重复。</li></ol><p>通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码。</p><p><em>设地址长度为n，上一层流出m种状态，下一层可拓展出$m \times 2^n$种状态。</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-虚拟存储器</title>
      <link href="/2023/12/13/ji-suan-ji-zu-cheng-yuan-li-xu-ni-cun-chu-qi/"/>
      <url>/2023/12/13/ji-suan-ji-zu-cheng-yuan-li-xu-ni-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h3><p>虚拟存储器就是基于主存和辅存（类似于cache在CPU和主存一样），在通过<strong>系统软件和硬件</strong>实现了主存的速度和辅存的容量。主要是为了解决主存容量不足的问题。</p><p>虚拟存储器会将主存或辅存的地址空间统一编址，这些地址称为<strong>虚地址或逻辑地址</strong>，虚地址对应的存储空间称为<strong>虚拟空间或程序空间</strong>。实际的主存单元地址称为实地址或物理地址。</p><p><strong>虚地址&#x3D;虚存页号+页内字地址</strong></p><p><strong>实地址&#x3D;主存页号+页内字地址</strong></p><p><strong>辅存地址&#x3D;磁盘号+盘面号+磁道号+扇区号</strong></p><p>虚拟存储器的地址空间如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/direct/33356981bce14235a801e11486341218.jpeg"></p><p>CPU使用虚地址时会通过辅助硬件来找出虚地址和实地址之间的对应关系。</p><p>若虚地址对应存储单元内容<strong>已经在</strong>主存中，可以通过地址变换使CPU能直接访问主存指示的实际单元；</p><p>若虚地址对应存储单元内容<strong>不在</strong>主存中，则要把包含的字一页或一段调入主存后再由CPU访问。</p><p>若<strong>主存已满</strong>，则采用替换算法置换主存中的交换块（即页面）。</p><p>虚拟存储机制采用的使全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而，在<strong>处理一致性问题采用回写法</strong>。</p><h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><p>页式虚拟存储器以页为单位，将主存空间和虚拟空间都划分成同样大小的页，<strong>主存的页称为实页、页框</strong>，虚存的页称为<strong>虚页</strong>。</p><p>虚拟地址分为两个字段：<strong>虚页号和页内地址</strong>。</p><p><strong>页表</strong>来实现虚拟地址到物理地址的转换。（页表回长久地保存在内存中）。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><strong>有效位</strong>也称装入位，用来表示对应页面是否在主存，</p><p>若为1，则表示虚拟页已从外存调入主存，<strong>此时页表存放该页的物理页号</strong>；</p><p>若为0，则表示未调入主存，此时页表可以存放该页的磁盘地址。</p><p><strong>脏位</strong>也称修改位，用来表示页面是否被修改过，虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。</p><p><strong>引用位</strong>也称使用位，用来配合替换策略进行设置，用来配合替换策略进行设置，例如是否实现最先调入（FIFO位）或最近最少用（LRU位）策略等。</p><p>页式虚拟存储器的<strong>优点</strong>： 页面的长度固定，页表简单，调入方便。</p><p>页式虚拟存储器的<strong>缺点</strong>： 由于程序不可能正好式页面的整数倍，因此可能会导致空间无法充分使用而浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式存储器方便。</p><p><img src="https://img-blog.csdnimg.cn/direct/859d2e06980243f6a4be0fd3955aff78.png"></p><h4 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h4><p>依据程序局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表中，可以明显提高效率。相应放在<strong>主存中的页表称为慢表</strong>。</p><p>地址转换时，首先会查找快表，若命中，则无需访问主存中的页表。</p><p>快表通常采用<strong>全相联或组相联</strong>实现。每个LTB项由页表<strong>表项内容加上一个TLB标记字段组成</strong>，<strong>TLB标记</strong>用来表示该表项取自页表哪个虚拟号对应的页表项。</p><h3 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h3><p>段式虚拟存储器中的段是按逻辑结构划分的，各个段的长度<strong>因程序而异</strong>。</p><p>段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。</p><p>CPU根据虚拟地址访存时候，首先格局段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断是否已经调入主存（”1“表示调入）。已调入则从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，则得到对应主存的实际地址。</p><p><img src="https://img-blog.csdnimg.cn/direct/dbfead2aabc34a84b2597bfb54f0c321.png"></p><p>段式存储的<strong>优点</strong>是：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使它容易编译、管理修改和维护；<strong>缺点</strong>是因为段长度可变，分配空间不方便，容易在段间留下碎片。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-高速缓冲存储器</title>
      <link href="/2023/12/12/ji-suan-ji-zu-cheng-yuan-li-gao-su-huan-chong-cun-chu-qi/"/>
      <url>/2023/12/12/ji-suan-ji-zu-cheng-yuan-li-gao-su-huan-chong-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="Cache的基本原理"><a href="#Cache的基本原理" class="headerlink" title="Cache的基本原理"></a>Cache的基本原理</h3><p>目前Cache被集成在CPU内部，且用SRAM实现，速度快，成本高</p><p>当cache要运行时，会将主存的存储空间进行“分块”，cache与主存之间的数据交换以cache块为单位。</p><p>例：设每1KB为一块，主存共4MB，cache为8KB，<strong>主存与cache间以“块”为单位进行数据交换</strong>。</p><p><img src="https://img-blog.csdnimg.cn/direct/6f9d1bb76873444b83853b38196d2cef.png"></p><p>4MB&#x3D;$2^{22}bit$，1K&#x3D;$2^{10}$，因此主存可以被分为$2^{12}&#x3D;4096$块，cache分为8块。</p><p>然后因主存的地址共22位，所以可以将12位用来表示块号，剩下10位表示块内地址。</p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><ul><li>空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的</li><li>时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息（指一段代码可能在邻近时间很快再被调用）。</li></ul><p>Cache就是用局部性原理，把程序中正在使用的部分数据存在cache中，使CPU的访存操作大多数针对cache进行，从而提高程序的执行速度。</p><p>例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//程序A：按行访问</span><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//程序B：按列访问</span><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>由于数组是按行进行存放在内存中，因此按行访问会有空间连接性，程序A的空间局部性会比程序B的空间局部性更好。cache执行程序A会更快。</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>在之前要先了解一些概念，</p><p><strong>命中率H</strong>：CPU欲访问的信息已在Cache中的比率。</p><p><strong>缺失（未命中）率</strong>： M &#x3D; 1 - H。</p><p>设一个程序执行期间，cache的总命中次数位$N_c$，访问主存的总次数为$N_m$，则命中H：<br>$$<br>H&#x3D;N_c&#x2F;(N_c+N_m)<br>$$<br>设$t_c$为访问一次cache所需时间，$t_m$为访问一次主存所需时间。则cache主存系统的<strong>平均访问时间t</strong>（以先访问cache，若cache未命中再访问主存）为：<br>$$<br>t&#x3D;Ht_c+(1-H)(t_c+t_m)<br>$$<br>若同时访问cache和主存，若cache命中则立即停止访问主存，<strong>平均访问时间t</strong>：<br>$$<br>t&#x3D;Ht_c+(1-H)t_m<br>$$</p><h3 id="cache和主存的映射方式"><a href="#cache和主存的映射方式" class="headerlink" title="cache和主存的映射方式"></a>cache和主存的映射方式</h3><p>cache行中的信息是主存中某个块的副本，地址映射就是指把主存地址空间映射到cache地址空间。并且cache中每块要加一个<strong>标记</strong>，指明它是主存中的哪一块副本。<strong>为了说明cache行中的信息是否有效，每个cache行需要一个有效位</strong>。</p><p>地址映射的方法有三种：</p><h4 id="全相连映射"><a href="#全相连映射" class="headerlink" title="全相连映射"></a>全相连映射</h4><p>主存的每一块可以装入cache中的<strong>任何位置</strong>，每行的标记用于指出该行取自主存的哪一块，所以<strong>CPU访存时需要与所有cache行的标记进行比较</strong>。</p><p>优点是比较灵活，cache块的冲突概率低，空间利用率搞，命中率也高；</p><p>缺点是标记的比较速度较慢，实现成本较高，通常需要采用昂贵的按内容寻址的相联存储器进行地址映射。</p><p>例：</p><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据cache有8个cache行（即cache块，与主存块的大小相等），行长为64B。</p><p>主存256MB&#x3D;$2^{28}$bit，主存的地址共28位，由于块大小为64B&#x3D;$2^6$， 所以主存块内地址为6位，主存块号22位。</p><p><img src="https://img-blog.csdnimg.cn/direct/f9d30ab4316542b0a0e9d3ad2edfa1c9.png"></p><p>使用全相联映射，先初始所有有效位为0，主存的块可以放到cache中的任意位置。假设将主存块号0放到cache3中，此时会将有效位置为1，并标记上当前主存的主存块号。</p><p>同样若将$2^{22}-3$的主存块放入到cache1中，标记会变为$2^{22}-3$的主存块号。如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/direct/a60ae3bd2f3f473ba161df3c532d9cfe.png"></p><p>当使用“全相联映射”进行访问主存地址$1…1101 \quad 001110$时，会根据主存地址的前22位对比cache 中所有块的标记；</p><p>若标记匹配且有效位&#x3D;1，则cache 命中，访问cache块内地址为001110的单元。</p><p>若未命中或有效位&#x3D;0，则正常访问主存。</p><h4 id="直接映射（只能放固定位置）"><a href="#直接映射（只能放固定位置）" class="headerlink" title="直接映射（只能放固定位置）"></a>直接映射（只能放固定位置）</h4><p>主存中的<strong>每一块只能装入cache中的唯一位置</strong>。若这个位置已有内容，则产生块冲突，<strong>原来的块</strong>将无条件被替换出去（无需使用替换算法）。直接映射实现简单，但不够灵活，即使cache的其他许多地址空着也不能占用，<strong>空间利用率低</strong>。</p><p>直接映射的关系可定义为：<br>$$<br>cache行号&#x3D;主存块号 % cache总行数<br>$$<br>例：</p><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据cache有8个cache行（即cache块，与主存块的大小相等），行长为64B。</p><p>主存256MB&#x3D;$2^{28}$bit，主存的地址共28位，由于块大小为64B&#x3D;$2^6$， 所以主存块内地址为6位，主存块号22位。</p><p>若将0块号主存放入到cache中，此时0%8&#x3D;0，所以会放到cache0中。</p><p><img src="https://img-blog.csdnimg.cn/direct/47b37bdec5004842a1403bcff7657a9f.png"></p><p>若想再将8块号主存放到cache中，由于8%8&#x3D;0，所以会直接覆盖原先cache存放的信息。</p><p><img src="https://img-blog.csdnimg.cn/direct/0923dc5100954b75a272c9ab25aacb47.png"></p><p>使用直接直接映射由于是对cache总行数取模，因此可以只取$\log_2总行数$来得到应映射到cache哪一行，该例题中$log_28&#x3D;3$，因此只需19位标记即可，3位作于cache的行号，就可以直接根据主存块地址的后三位来确定应该放在cache的哪一行。</p><p><img src="https://img-blog.csdnimg.cn/direct/580425a1ec6c46ce9a7f34712bb53e72.png"></p><h4 id="组相联映射（可放到特定分组）"><a href="#组相联映射（可放到特定分组）" class="headerlink" title="组相联映射（可放到特定分组）"></a>组相联映射（可放到特定分组）</h4><p>将cache分成Q个大小相等的组，每个主存块可以装入固定组中的任意一行，即<strong>组间采用直接映射、组内采用全相联映射</strong>的方式。</p><p>组相联映射的关系可以定义为：<br>$$<br>cache组号&#x3D;主存块号 % cache组数（Q）<br>$$<br>例：</p><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据cache有8个cache行（即cache块，与主存块的大小相等），行长为64B，采用二路组相联映射（2块为一组，分四组）。</p><p>主存256MB&#x3D;$2^{28}$bit，主存的地址共28位，由于块大小为64B&#x3D;$2^6$， 所以主存块内地址为6位，主存块号22位。</p><p>若想将块号1主存放入cache中，此时分组数&#x3D;4，1%4&#x3D;1，所以会放入到第1组中任意位置。</p><p><img src="https://img-blog.csdnimg.cn/direct/8f1c8480044046d2a2480a329bd84394.png"></p><p>同样的，和直接映射类似，可以通过$\log_2分组数$来直接判断应该留几位作为判断放入cache的哪一个分组。在这例子中$\log_24&#x3D;2$，2位作为cache行号，剩下20位作为标记位。</p><p><img src="https://img-blog.csdnimg.cn/direct/452a78bbdf2e4f3293db2af9b640e496.png"></p><h3 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h3><p>在采用全相联映射或组相联映射方式时，从主存向cache传送一个新块，当cache或cache组中的空间已被占满时，就需要使用替换算法置换cache行。</p><h4 id="随机算法（RAND）"><a href="#随机算法（RAND）" class="headerlink" title="随机算法（RAND）"></a>随机算法（RAND）</h4><p>若cache已满，则随机选择一块替换。</p><p>例：</p><p>设总共有4个cache块，初始整个cache为空。采用全相联映射，依次访问主存块 {1，2，3，4，1，2，5，1，2，3，4，5}</p><p>由题第一次调用1，2，3，4会依次将主存块放入cache中，此时cache都未命中（因为原先cache中没有内容）。</p><p><img src="https://img-blog.csdnimg.cn/direct/112db0e861c246f09c3f7f9d5988b802.png"></p><p>再进行访问 1，2，此时cache中有1，2，就算命中，当访问5时，由于cache中没有5，根据随机算法cache会随机替换一个，假设这里随机替换了cache2中的3。</p><p><img src="https://img-blog.csdnimg.cn/direct/eab191ce86864df48b334472c615b2da.png"></p><p>而后面的步骤就与前面几乎相同，若cache中有则命中，没有则进行替换。</p><p>随机算法实现简单，但没考虑局部性原理，实际效果很不稳定。</p><h4 id="先进先出算法（FIFO）"><a href="#先进先出算法（FIFO）" class="headerlink" title="先进先出算法（FIFO）"></a>先进先出算法（FIFO）</h4><p>选择最早调入的行进行替换。</p><p>例：</p><p>设总共有4个cache块，初始整个cache为空。采用全相联映射，依次访问主存块 {1，2，3，4，1，2，5，1，2，3，4，5}</p><p>前面与上个随机算法图相似，依次访问到5的时候，根据先进先出的原则，会将cache0块中的1替换为5.</p><p><img src="https://img-blog.csdnimg.cn/direct/fff7c0f3dbc4489496d261b2fdbbee1e.png"></p><p>后面都是同样的步骤。</p><p>先进先出算法实现简单，也没考虑局部性原理，最先被调入cache的块也有可能是被频繁访问的，同时也会出现<strong>抖动现象</strong>（频繁的换入换出）。</p><h4 id="近期最少使用算法（LRU）"><a href="#近期最少使用算法（LRU）" class="headerlink" title="近期最少使用算法（LRU）"></a>近期最少使用算法（LRU）</h4><p>依据程序访问的局部性原理，选择近期内长久未访问过cache行进行替换，是堆栈类算法。</p><p>LRU会为每一个cache块设置一个“计数器”，用于<strong>记录每个cache块有多久没被访问</strong>，<strong>当cache满后替换“计数器”最大的</strong>。</p><p>计数器的变化规则为：</p><ol><li>命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变。</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余全加1；</li><li>未命中且无空闲行时，计数器最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。</li></ol><p>例：</p><p>设总共有4个cache块，初始整个cache为空。采用全相联映射，依次访问主存块 {1，2，3，4，1，2，5，1，2，3，4，5}</p><p>前面与先前的算法都一样，依次访问到5的时候，由于此时cache已满，根据访问时间来看，3是最久没被访问的，所以会用5来替换3的位置，后面的处理方法类似。</p><p><img src="https://img-blog.csdnimg.cn/direct/8b3171ebfe4c4a779bcf339153392f32.png"></p><p>cache块的总数&#x3D;$2^n$，则计数器只需n位。且cache装满后所有计数器的值一定不重复。</p><h4 id="最不经常使用算法（LFU）"><a href="#最不经常使用算法（LFU）" class="headerlink" title="最不经常使用算法（LFU）"></a>最不经常使用算法（LFU）</h4><p>为每一个cache块设置一个“计数器”，用于记录每个cache块被访问过几次。<strong>当cache满后替换“计数器”最小的</strong>。</p><p>例：</p><p>设总共有4个cache块，初始整个cache为空。采用全相联映射，依次访问主存块 {1，2，3，4，1，2，5，1，2，3，4，5}</p><p>前面与先前的算法都一样，新调入的块计数器置0，之后每个被访问过后计数器都会加1，依次访问到5的时候，需要替换，会选择计数器最小的行（若有多个最小的行，可按行号递增或FIFO策略进行选择），此时5就会替换3的位置，后面的步骤就与前面一致。</p><p><img src="https://img-blog.csdnimg.cn/direct/011078c724864d9e877e72d22fbece7c.png"></p><p>LFU算法，曾经被经常访问的主存块在未来不一定会用到，并没有很好的遵循局部性原理，实际运行效果不如LRU。</p><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><p>因为cache中的内容是主存块副本，当对cache中的内容进行更新时，就需选用写操作策略使cache内容和主存内容保持一致。</p><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><p>对应cache写命中（write hit），有两种处理方法。</p><h5 id="全写法（写直通法，-write-through）"><a href="#全写法（写直通法，-write-through）" class="headerlink" title="全写法（写直通法， write-through）"></a>全写法（写直通法， write-through）</h5><p>当CPU对cache写命中时，必须把数据同时写入cache和主存。这种方法实现简单，保证主存数据的正确性。缺点使增加访存次数，降低了cache 的效率。</p><p>使用全写法需要借助一个写缓冲（SRAM实现的FIFO队列）：为减少全写法直接写入主存的时间损耗。</p><p>每当对cache块进行写入时，同样也会对写缓冲进行写入，然后会在专门的控制电路下逐一写回。</p><p>当出现频繁写时，会使写缓冲饱和溢出。</p><p><img src="https://img-blog.csdnimg.cn/direct/bd52763055314e638faad117e724c120.png"></p><h5 id="回写法（write-back）"><a href="#回写法（write-back）" class="headerlink" title="回写法（write-back）"></a>回写法（write-back）</h5><p>当CPU对cache写命中时，只把数据写入cache，而不立即写入内存，只有当此块被换出时才写回主存。</p><p>并且会给每个cache行设置一个修改位（脏位）。若修改位为1，则说明对应cache行中的块被修改过，替换时需写回主存；若&#x3D;0，则说明未被修改。</p><p>如下图所示，cache3被修改过，仅当cache3被换出时候写回主存0块号。</p><p><img src="https://img-blog.csdnimg.cn/direct/e689077197744b8a8159d632db877cb7.png"></p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><p>对于cache写不命中，也有两种处理方法。</p><h5 id="写分配法（write-allocate）"><a href="#写分配法（write-allocate）" class="headerlink" title="写分配法（write-allocate）"></a>写分配法（write-allocate）</h5><p>加载主存中的块到cahe中，然后更新这个cache块。</p><p>通常搭配写回法使用。</p><p><img src="https://img-blog.csdnimg.cn/direct/d2db380b14524811b4c24cc84a0248fc.png"></p><h5 id="非写分配法（not-write-allocate）"><a href="#非写分配法（not-write-allocate）" class="headerlink" title="非写分配法（not-write-allocate）"></a>非写分配法（not-write-allocate）</h5><p>只写入主存，不进行调块。 非写分配法通常搭配全写法使用。</p><p><img src="https://img-blog.csdnimg.cn/direct/6faa2d1fabcb4ce1a2432937bc026769.png"></p><p>现代计算机一般都会采用多级cache。</p><p><img src="https://img-blog.csdnimg.cn/direct/6db976739d464755a04710a613053ac7.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-外部存储器</title>
      <link href="/2023/12/10/ji-suan-ji-zu-cheng-yuan-li-wai-bu-cun-chu-qi/"/>
      <url>/2023/12/10/ji-suan-ji-zu-cheng-yuan-li-wai-bu-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。</p><p>所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。<strong>磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器</strong>。</p><h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><p>磁盘存储器的优点有：</p><ol><li>存储容量大，位价格低；</li><li>记录介质可重复使用；</li><li>记录信息可长期保存而不丢失，甚至可脱机存档；</li><li>非破坏性读出，读出时不需要再生</li></ol><p><strong>缺点</strong>：读取速度慢，机械结构复杂，对工作环境要求较高。</p><p>外存储器既可以<strong>作为输入设备也可以作为输出设备</strong>。</p><h4 id="磁盘存储器的组成"><a href="#磁盘存储器的组成" class="headerlink" title="磁盘存储器的组成"></a>磁盘存储器的组成</h4><p>磁盘存储器是由磁盘驱动器、磁盘控制器和盘片组成。</p><ul><li>磁盘驱动器。核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动磁头固定盘片的硬件存储器。</li><li>磁盘控制器。硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。</li></ul><p>磁盘的存储区域。一块硬盘含有若干纪录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，<strong>扇区（也称块），是磁盘读写的最小单位，即磁盘按块存取</strong>。</p><ul><li>磁头数（Heads），即记录面数，表示硬盘总共又多少个磁头。磁头用于读取&#x2F;写入盘片上记录面的信息，一个记录面对应一个磁头。</li><li>柱面数（Cylinders），表示硬盘每面盘片上又多少条磁道。</li><li>扇区数（Sectors），表示每条磁道上有多少个扇区。</li></ul><h4 id="磁盘的性能指标"><a href="#磁盘的性能指标" class="headerlink" title="磁盘的性能指标"></a>磁盘的性能指标</h4><ul><li>记录密度：记录密度是指盘片单位面积上记录的二进制的信息栏，<strong>通常以道密度、位密度和面密度表示</strong>。道密度是沿磁盘半径方向单位长度上磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积。</li><li>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。</li><li>平均存取时间。由寻道时间（磁头移动到目的磁道的时间）、旋转延迟时间（磁头定位到要读写扇区的时间）和传输时间（传输数据所花费的时间）三部分构成，如下图所示。</li><li><img src="https://img-blog.csdnimg.cn/direct/315cacb3376e494491060f035a69abdf.png"></li><li>数据传输率。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。假设磁盘旋转数位r转&#x2F;秒，每条磁道容量为N字节，则数据传输率为</li></ul><p>$$<br>D_r&#x3D;rN<br>$$</p><h4 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h4><p>主机向磁盘控制器发送寻址信息，磁盘的地址一般如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/direct/f18226cad4b54be8bcf2ff7dc9f11925.png"></p><p>例：若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘有256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码：</p><p><img src="https://img-blog.csdnimg.cn/direct/c8e258d8b2cf41e78434752acbb5ddb4.png"></p><p>通过2位表示0~3范围，可以覆盖4个驱动器，磁道可以用8位进行表示，4位可以表示16个盘面号，同样16个扇区也只需4比特即可表示。</p><h4 id="磁盘的工作过程"><a href="#磁盘的工作过程" class="headerlink" title="磁盘的工作过程"></a>磁盘的工作过程</h4><p>磁盘的主要操作就是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二部是执行控制字。</p><p>硬盘属于机械式部件，其<strong>读写操作时串行的</strong>，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p><h3 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h3><blockquote><p>RAID（Redundant Array of Inexpensive Disks，廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储，并行访问，具有更好的存储性能、可靠性和安全性。</p></blockquote><p>RAID的分级如下所示。在RAID1~RAID5几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提高了系统的可靠性。</p><ul><li>RAID0：无冗余和无校验的磁盘阵列（没有容错能力）。</li><li>RAID1：镜像磁盘阵列（有容错能力，但存储容量会减少一半）。</li><li>RAID2：采用纠错的海明码的磁盘阵列。</li><li>RAID3：位交叉奇偶校验的磁盘阵列。</li><li>RAID4：块交叉奇偶校验的磁盘阵列。</li><li>RAID5：无独立校验的奇偶校验磁盘阵列。</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/522b85dea99647d8ae78bcc42b4fe3ea.png"></p><h3 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h3><p>固态硬盘是一种<strong>基于闪存技术的存储器</strong>。它与U盘并没有本质上的差别，只是容量更大，存取性能更好。一个SSD由多个闪存芯片和闪存翻译层组成，闪存芯片替代机械硬盘的机械驱动器，而闪存翻译层将来自CPU的逻辑块读写请求翻译成对底层物理设备的读写控制信号，因此<strong>闪存翻译层相当于扮演了磁盘控制器的角色</strong>，下图就是固态硬盘的结构。</p><p><img src="https://img-blog.csdnimg.cn/direct/82f1271d2a144f77b4a228e08a718410.png"></p><p>一块闪存通常由m块（相当于机械硬盘的磁道）组成，每块由P页（相当于机械硬盘的块&#x2F;扇区）组成。通常，<strong>页的大小是512B<del>4KB，每块由32</del>128页组成，块的大小为16KB~512KB</strong>。数据是<strong>以页为单位读写</strong>的。只有在一页所属的块整个被擦除后，才能写这一页。某个块进行了<strong>约10万次</strong>重复写之后，就会磨损坏，不能再使用（而机械硬盘的扇区不会因读写次数过多而损坏）。</p><p>SSD的<strong>读的速度要比写的速度快</strong>，写前若页中有数据需要对当前所属块进行擦除。</p><p>SSD由半导体存储器构成，没有移动的部件，因而随机访问时间比机械硬盘快的多。</p><p>SSD目前通常会采用磨损均衡技术（将“擦除”平均分布在各个块上，以提升使用寿命），逻辑块号可以通过闪存翻译层映射到其他物理地址上。</p><p>磨损均衡技术一般包括：</p><ol><li>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块。</li><li>静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务。</li></ol><h4 id="SSD解决数据丢失问题"><a href="#SSD解决数据丢失问题" class="headerlink" title="SSD解决数据丢失问题"></a>SSD解决数据丢失问题</h4><p>由于SSD以块为单位进行擦除，而读写又以页为单位，因此可能要进行写之前需要擦除当前块页的元素，因此可以通过将要写入的页所在的块中的所有元素复制到其他块中，并在复制块中在要写入的页位置上写入新数据，然后等擦除完块中元素后再重新复制回去。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数电-触发器</title>
      <link href="/2023/12/07/shu-dian-hong-fa-qi/"/>
      <url>/2023/12/07/shu-dian-hong-fa-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="触发器的基本特点和作用"><a href="#触发器的基本特点和作用" class="headerlink" title="触发器的基本特点和作用"></a>触发器的基本特点和作用</h3><p>Flip-Flop，简称为FF，又称双稳态触发器。</p><h4 id="触发器基本特点"><a href="#触发器基本特点" class="headerlink" title="触发器基本特点"></a>触发器基本特点</h4><ol><li><p>具有两个能自保持的稳定状态（稳态）</p><p>通常用输出端Q的状态来表示触发器的状态。</p><p>如$Q&#x3D;0、\overline{Q}&#x3D;1$时，表示<font color="#ff0000">0状态</font>；$Q&#x3D;1、\overline{Q}&#x3D;0$时，表示<font color="#ff0000">1状态</font></p></li><li><p>在输入信号作用下，触发器的两个稳定状态可相互转换（状态的翻转）。</p></li><li><p>输入信号消失后，新状态可长期保持下来，具有<strong>记忆功能</strong>，可存储二进制信息。、</p></li></ol><h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p><strong>触发器和门电路是构成数字电路的基本单元</strong>。</p><p>触发器具有记忆功能，由它构成的电路在某时刻的输出不仅取决于该时刻的输入，还与电路原来状态有关（时序逻辑电路）。而<strong>门电路无记忆功能</strong>，由它构成的电路在某时刻的输出完全取决于该时刻的输入，与电路原来状态无关（组合逻辑电路）。</p><h3 id="基本触发器"><a href="#基本触发器" class="headerlink" title="基本触发器"></a>基本触发器</h3><h4 id="由与非门构成的基本RS触发器"><a href="#由与非门构成的基本RS触发器" class="headerlink" title="由与非门构成的基本RS触发器"></a>由与非门构成的基本RS触发器</h4><p><img src="https://img-blog.csdnimg.cn/direct/588f08bb599746058ad5897b5b2183a5.png" alt="1-1"></p><p>图中$\overline{S_D}$ 为置1端，也称<strong>置位端</strong>，$\overline{R_D}$为置0端，也称<strong>复位端</strong>。</p><p>$Q&#x3D;0、\overline{Q}&#x3D;1$时，表示<font color="#ff0000">触发器的0状态</font>；$Q&#x3D;1、\overline{Q}&#x3D;0$时，表示<font color="#ff0000">触发器的1状态</font></p><p><strong>RS触发器的逻辑图</strong>如下图：</p><p><img src="https://img-blog.csdnimg.cn/direct/f38ba07c02e149da96f8f8ed7fee43c7.png" alt="1-2"></p><h5 id="逻辑功能"><a href="#逻辑功能" class="headerlink" title="逻辑功能"></a>逻辑功能</h5><p>在图1-1中，若$\overline{R_D}&#x3D;0,\overline{S_D}&#x3D;1$，由于$\overline{R_D}&#x3D;0$，先与后非，无论什么和0相与都是0再非得1，所以可得$\overline{Q}&#x3D;1$，再通过$\overline{Q}&#x3D;1$和$\overline{S_D}&#x3D;1$进行与非运算，得$Q&#x3D;0$，得下图，此时触发器被置0。</p><p><img src="https://img-blog.csdnimg.cn/direct/3f9d99e1b5af446d9cc39f61935dc9bb.png"></p><p>而若$\overline{R_D}&#x3D;1,\overline{S_D}&#x3D;0$，正好与上方情况相反，可得$\overline{Q}&#x3D;0,Q&#x3D;1$，此时触发器置1。</p><p>若$\overline{R_D}&#x3D;1,\overline{S_D}&#x3D;1$，可根据输出结果$G_1$和$G_2$门电路逻辑函数来推出相应值，$G_1$ output：Q&#x3D;$\overline{\overline{S_D}\cdot \overline{Q}}&#x3D;\overline{1\cdot \overline{Q}}&#x3D;Q$, $G_2$ output：$\overline{Q}&#x3D;\overline{\overline{R_D}\cdot Q}&#x3D;\overline{1\cdot Q}&#x3D;\overline{Q}$，由此可得最后触发器的状态保持不变。</p><p>若$\overline{R_D}&#x3D;0,\overline{S_D}&#x3D;0$，无论怎么样Q和$\overline{Q}$的值都是1，输出的既非0状态，也非1状态。这种情况是<strong>禁用</strong>的。</p><p>最后可根据上方列出真值表功能图：</p><p><img src="https://img-blog.csdnimg.cn/direct/567a460e644d49a6b83f2256e550cb74.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主存储器与CPU的连接</title>
      <link href="/2023/12/06/ji-suan-ji-zu-cheng-yuan-li-zhu-cun-chu-qi-yu-cpu-de-lian-jie/"/>
      <url>/2023/12/06/ji-suan-ji-zu-cheng-yuan-li-zhu-cun-chu-qi-yu-cpu-de-lian-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h3><ol><li>主存储器通过数据总线、地址总线与控制总线与CPU连接。</li><li>地址总线的位数与工作频率的乘积正比于数据传输率。（数据总线的宽度&#x3D;存储字长）</li><li>地址总线的<strong>位数</strong>决定了<strong>可寻址的最大内存空间</strong>。</li><li>控制总线（读&#x2F;写）指出总线周期的类型和本次输入&#x2F;输出操作完成的时刻。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/f7cbef172297476196f302a3cd56d60a.png"></p><p>上图是一块8$\times$8的单块存储芯片，单个芯片的容量不可能很大，往往需要通过拓展技术来将多个芯片集成在内存条上，若想扩展主存字数则需通过<strong>字扩展</strong>，当<strong>数据总线宽度 &gt; 存储芯片字长</strong>，则需要进行位扩展。</p><p>现在的计算机MDR（主存数据寄存器）和MAR（主存地址寄存器）都是集成在CPU中</p><p><img src="https://img-blog.csdnimg.cn/direct/c82dffc2b5cc4f01ae3d803e7a81ca89.png"></p><h3 id="主存容量的拓展"><a href="#主存容量的拓展" class="headerlink" title="主存容量的拓展"></a>主存容量的拓展</h3><p>由于单个存储芯片容量优先，因此需要在字或位两方面进行扩充才能满足实际存储器的容量要求。</p><h4 id="位拓展法"><a href="#位拓展法" class="headerlink" title="位拓展法"></a>位拓展法</h4><p>CPU的数据线数与存储芯片的数据位数不一定相等，因此必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/direct/61835be20ec04d8ab5e8203b7148f677.png"></p><p>上图用8K$\times$1位的存储芯片与CPU连接$8K&#x3D;2^{13}$，所以共需要13根地址总线和1根数据总线，显然CPU数据利用的不够充分，因此可以通过增加芯片的方式，来让数据总线得到充分的利用，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/direct/00fcc79acfe14001b1bd378bec41c6c7.png"></p><p>此时除了数据总线连接不一致其他都为同个地址总线以及读写总线，因此称为位拓展法。</p><p>最终通过8个存储芯片就可以将位数拓展为8位。</p><p><img src="https://img-blog.csdnimg.cn/direct/bbee2fc2eb7a4d87983759814399d2c6.png"></p><p>**注意：仅采用位拓展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，所以片选信号$\overline{CS}$要连接到所有芯片 **</p><h4 id="字拓展法"><a href="#字拓展法" class="headerlink" title="字拓展法"></a>字拓展法</h4><p>字拓展是指增加存储器中字的数量，而位数不变。</p><p>例：</p><p>将下图一块8K$\times$8位的芯片与CPU连接，显然数据线已经可以发挥最大功效，然后地址线还有3条空出，因此可以通过再添加一片8K$\times$8位同型号芯片来与CPU连接，而片选信号$CS$分别连接到CPU地址线上，从而实现CPU地址线的充分利用，这种方法称为<strong>线选法</strong>。</p><p><img src="https://img-blog.csdnimg.cn/direct/885fc8dc33884792b65aec6652ddf6e9.png"></p><p>然而这种方法是有瑕疵的，若上图$A_{13} A_{14}$全为0或全为1时候，工作就会产生冲突。第一块芯片地址所能表示的范围为010 0000 0000 0000 ~ 011 1111 1111 11111（以01x xxxx xxxx xxxx作为地址），第二块芯片所能表示的地址范围为 100 0000 0000 0000 ~ 101 1111 1111 1111（以10x xxxx xxxx xxxx作为地址），在这存储器中，以00和11开头的地址都不可用，因此可以通过译码器来进行改良。</p><p><img src="https://img-blog.csdnimg.cn/direct/14d471e2e491467f9910ec530d08f02b.png"></p><p>如上图，通过一个2-4译码器来充分利用地址线，此时00和11都可以被用作为地址，可以<strong>使地址空间连续，相应的电路会比线选法更发杂</strong>。</p><h4 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法"></a>字位同时扩展法</h4><p>实际上，存储器往往需要同时扩充字和位。</p><p>如下图所示，通过两块8K$\times$4位组成一组来连接到地址线中，这样就实现位拓展，再增至4组，通过字拓展将2-4译码器将剩下$A_{14}A_{15}$地址线充分利用，实现了字位同时拓展，且此时地址空间也是连续的。 </p><p><img src="https://img-blog.csdnimg.cn/direct/dbd705f7ef0e45afb3c23ea0ea310c82.png"></p>]]></content>
      
      
      <categories>
          
          <category> true </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-主存储器</title>
      <link href="/2023/12/05/ji-suan-ji-zu-cheng-yuan-li-zhu-cun-chu-qi/"/>
      <url>/2023/12/05/ji-suan-ji-zu-cheng-yuan-li-zhu-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><h4 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h4><p>存储器基本是由半导体元件组成，半导体可以根据供电的大小来输出高电平或低电平。</p><p>一个存储元包括MOS管（半导体，MOS管可以理解为一种电控开关，当输入电压到达某个阈值就可以接通）和电容，根据接入的高低电平由半导体来控制，假设电容中有保存电荷导致MOS管变成1，以至于可以接通，此时外部就可以接受到高电平信号1，若电容中没有保存电荷，那么MOS管无法接通外部就会接受到低电平0。以此就可以构成一个存储元。</p><p><img src="https://img-blog.csdnimg.cn/direct/4563247d987b4ae39c225953fd627b0d.png"></p><p>而若通过一条总线来连接所有存储元，就可以组成一个<strong>存储单元（也称为存储字）</strong>，当总线接入一个高电平就会让所有存储元的MOS管都导通，从而电容中存储的0或1就会通过绿色的线进行导出。</p><p><img src="https://img-blog.csdnimg.cn/direct/b10758329f8e4889bbd67de47fc5d6b1.png"></p><h4 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h4><p>存储器为了实现读写，需要通过译码器来进行统一的读写操作，会有地址总线来输入要读取那一部分的存储单元，然后通过译码器来进行相应的读取，再通过控制电路来控制译码器是否工作。</p><p><img src="https://img-blog.csdnimg.cn/direct/9b99dc3b27dd48c889645966e092c528.png"></p><p>将上方图各个功能进行封装则有下图：</p><p><img src="https://img-blog.csdnimg.cn/direct/83464cb3a08a459da50f9a5a05f52a70.png"></p><p>就有存储器的基本框架，地址线来接受外界的地址信息，通过数据线来进行数据的传输，片选线来用于读取某一块特定的存储芯片（一般有多块存储芯片），读&#x2F;写控制线来控制是读还是写（有可能一条或两条）。</p><p><strong>地址线数量&#x3D;$\log_2(寻址范围)$ ，数据线数量&#x3D;数据位数</strong>。</p><p>例：容量1024$\times$8位的SRAM芯片，除电源和接地线外，该芯片的引脚（要接入的线）的最小数目是多少？</p><p>由上图得片选线有一根，读写控制线最少1根，地址线的数量&#x3D; $\log_2(1024)&#x3D;10$（DRAM存在复用情况，可以减半，下方有DRAM中介绍）。数据位数为8位，所以数据线8根，结果最少的引脚数&#x3D; 1 + 1（或 2 ） + 10 + 8 &#x3D;20（或 21）.</p><p><strong>存储芯片常见描述</strong></p><p>例：8K$\times$8位，指有8K个存储单元，存储字长为8位（有8个存储元）。即$2^{10+3}\times 8bit$。</p><p>8K$\times$1位，指有8K个存储单元，存储字长为1位。即$2^{10+3}\times 1bit$</p><p>64K$\times$16位，指有64K个存储单元，存储字长为16位。即$2^{10+6}\times 16bit$</p><h3 id="SRAM芯片和DRAM芯片"><a href="#SRAM芯片和DRAM芯片" class="headerlink" title="SRAM芯片和DRAM芯片"></a>SRAM芯片和DRAM芯片</h3><blockquote><p>Dynamic Random Access Memory，即动态RAM，通常用于主存</p><p>Static Random Access Memory，即静态RAM，通常用于Cache</p></blockquote><h4 id="SRAM的工作原理"><a href="#SRAM的工作原理" class="headerlink" title="SRAM的工作原理"></a>SRAM的工作原理</h4><p>通常把存放一个二进制位的物理器件称为存储元，是存储器的最基本的构建。静态随机存储器（SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此即使信息被读取后，它仍保持其原状态而不需要再生（非破坏性读出）。</p><p>双稳态触发器只要不断供电就不会导致信息流失，触发器的状态就不会改变。</p><p><img src="https://img-blog.csdnimg.cn/direct/2cbbcfdf8b044c9886a85c4b20234c35.png"></p><h4 id="DRAM的工作原理"><a href="#DRAM的工作原理" class="headerlink" title="DRAM的工作原理"></a>DRAM的工作原理</h4><p>与SRAM的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息，DRAM的基本存储单元通常只用一个晶体管，所以它比SRAM的密度要高很多。并且集成高、价格低、容量大和功耗低等优点。</p><p><img src="https://img-blog.csdnimg.cn/direct/97b1d5cede4a4ab296ff53eba1c1a837.png"></p><p>DRAM电容上的<strong>电荷一般只能维持1~2ms</strong>，因此即使电源不断电，信息也会自动消失。为此需要每隔一段时间必须刷新，通常取2ms，称为<strong>刷新周期</strong>。</p><h5 id="DRAM刷新"><a href="#DRAM刷新" class="headerlink" title="DRAM刷新"></a>DRAM刷新</h5><p>若以行为单位进行刷新，若有n位的地址，则需要$2^n$根选通线，显然在工程上难度较大，由此拆分出了行列地址，将存储元从一维的行，延申成二维的行列，通过行地址译码器和列地址译码器来实现，当行列选中同个单元即读取这个单元的信息。<font color="#ff0000">注：DRAM以行进行刷新</font></p><p>从此可将n位地址拆分成n&#x2F;2位地址从而达到减少选通线的目的。</p><p><img src="https://img-blog.csdnimg.cn/direct/22220bbf15994e4bbc5be05653767fda.png"></p><p>例： 某一DRAM芯片，采用地址复用技术，其容量为 1024$\times$8 位，除电源和接地端外，该芯片的引脚数最少是多少（读写控制线为2根）。</p><p>根据题描述，可得寻址范围为1024$&#x3D;2^{10}$，所以地址线为10根，采用地址复用技术地址线减半为5根，数据线仍为8根，加上<strong>行选通线和列选通线</strong>两根及读写控制线两根（<strong>片选线用行通选来代替</strong>），结果总共为 5 + 8 + 2 + 2 &#x3D;17根。</p><p>将存储单元分为行列后就可以进行行或列刷新，常用的刷新方式有3种。</p><ol><li><p>集中刷新。</p><p>指在一个刷新周期内，<strong>利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”</strong>。<strong>优点</strong>是读写操作时不受刷新工作的影响；缺点是在集中刷新（死区）不能访问存储器。</p><p><img src="https://img-blog.csdnimg.cn/direct/c8ae3df502ef4843a75fee70fdcf70af.png"></p></li><li><p>分散刷新。</p><p>把对每行的刷新分散到各个工作周期中。这样，存储器的系统工作周期分为<strong>前半部分用于正常读、写或保持；后半部分用于刷新</strong>。如存储芯片的存取周期为5μs，则系统的存取周期为1μs。<strong>优点是没有死区；缺点是加长了系统的存取周期，降低了速度</strong></p><p><img src="https://img-blog.csdnimg.cn/direct/6f22e6620fdc473895ae984447a6f037.png"></p></li><li><p>异步刷新。</p><p>异步刷新既可缩短“死时间”，又能充分利用最大刷新间隔2ms的特点。具体做法是将<strong>刷新周期➗行数</strong>，得到<strong>两次刷新操作之间的时间间隔t</strong>，利用逻辑电路每隔时间t产生一次刷新。</p><p><img src="https://img-blog.csdnimg.cn/direct/c310b772d3064c77994ff2ce6b15d665.png"></p><p><strong>注：DRAM刷新需要注意以下问题</strong></p><ol><li>刷新对CPU是透明的，即刷新不依赖外部的访问；</li><li>动态RAM的刷新单位是行，由芯片内部自行生成行地址；</li><li>刷新操作类类似于读操作。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。</li></ol></li></ol><p><strong>注：现在的主存通常采用SDRAM芯片</strong></p><h4 id="SRAM和DRAM的比较"><a href="#SRAM和DRAM的比较" class="headerlink" title="SRAM和DRAM的比较"></a>SRAM和DRAM的比较</h4><p><img src="https://img-blog.csdnimg.cn/direct/d2534420a5634cf89924c043d2e5dcba.png"></p><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p>ROM和RAM都是支持随机访问的存储器，其中SRAM和DRAM均为易失性半导体存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的。ROM器件有两个显著的有点：</p><ol><li>结构简单，所以位密度比可读写存储器的高。</li><li>具有非易失性，所以可靠性高。</li></ol><h4 id="ROM的类型"><a href="#ROM的类型" class="headerlink" title="ROM的类型"></a>ROM的类型</h4><p>ROM可分为掩模式只读存储器（MROM）、一次可编程只读存储器（PROM）、可擦除可编码只读存储器（EPROM）、Flash存储器和固态硬盘（SSD）。</p><ol><li><p>掩模式只读存储器（MROM，Mask Read Only Memory）</p><p>由半导体制造厂按用户提出的要求在芯片的<strong>生成过程中</strong>直接写入，写入后任何人都无法改变其内容。<strong>优点是可靠性高，集成度高，价格便宜；缺点是灵活性差。</strong></p></li><li><p>一次性可编程只读存储器（PROM，Programmable Read Only Memory）</p><p>PROM可以实现一次性编程的只读存储器。允许用户写入自己的程序，<strong>一旦写入，内容就无法改变</strong>。</p></li><li><p>可擦除可编程只读存储器（ EPROM，Erasable Programmable Read-Only Memory）</p><p>EPROM允许用户写入信息，之后用某种方法擦除数据，<font color="#ff0000">可进行多次重写，由于改写较为繁琐，速度较慢，不能作为需要频繁读写的RAM使用</font>。</p><p>UVEPROM（ultraviolet rays）——用紫外线照射8~20分钟，擦除<strong>所有信息</strong>。</p><p>EEPROM（也记为$E^2PROM$），可用“电擦除”的方式，擦除<strong>特点的字</strong>。</p></li><li><p>Flash存储器，闪速存储器（注：U盘、SD卡就是闪存）</p><p>Flash存储器在EEPROM的基础上发展而来，断电后也能保存信息，且<font color="#ff0000">可进行多次快速擦除重写</font>，由于闪存要先擦除后写入，因此<strong>闪存的“写”速度要比“读”速度更慢</strong>。每个存储元只需单个MOS管，位密度比RAM高。</p></li><li><p>SSD（Solid State Drives）——固态硬盘</p><p>由控制单元+存储单元（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，<font color="#ff0000">可进行多次快速擦除重写</font>。SSD速度快、功耗低、价格高。目前个人电脑上常用SSD取代传统的机械硬盘。</p></li></ol><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐量。常用的由单体多字存储器和多体低位交叉存储器。</p><h4 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h4><p>单体多字系统的特点使存储体中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读入m个字，地址必须顺序排列并处于同一存储单元。</p><p>单体多字系统在<strong>一个存取周期内，从同一地址取出m条指令</strong>，然后将指令逐条送至CPU执行，每个1&#x2F;m存取周期，CPU向主存取一条指令。这显然提高了单体存储器的工作速度。</p><p><img src="https://img-blog.csdnimg.cn/direct/8575dbbb9c9940a6b5c5fa23c84646cb.png"></p><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><p>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。</p><p>多体并行存储器分为高位交叉编址和低位交叉编址两种。</p><ol><li><p>高位交叉编址（顺序方式）</p><p>高位地址表示体号，低位地址为体内地址。如下图所示，存储体共有4个模块$M_0$~$M_3$，每个存储体有8个存储单元，因此总共大小为$4\times 8 &#x3D; 32&#x3D;2^5$，可以用5bit来做存储体的地址。</p><p><img src="https://img-blog.csdnimg.cn/direct/2a61cdcdbf4240c4a4029dca198324bb.png"></p><p>由于是高位交叉编址，图上的<strong>蓝色部分为体号地址，黑色部分为体内地址（体号一致，体内地址不同）</strong>。高位交叉方式下，总是把<strong>低位的体内地址</strong>送到由<strong>高位体号</strong>确定的模块内进行译码。访问一个连续主存块时，总是先在一个模块内访问，等访问完该模块才能转到下一个模块访问。<strong>CPU总是按顺序访问存储模块，各模块不能被并行访问（按列进行访问）</strong>，因此不能提高存储器的吞吐率。</p></li><li><p>低位交叉编址（交叉方式）</p><p><img src="https://img-blog.csdnimg.cn/direct/62e5dc6e6b31416d868af7ada9bae1ed.png"></p><p>图上的<strong>蓝色部分为体号地址，黑色部分为体内地址（体号不同，体内地址一致）</strong>。低位交叉方式下，总是把<strong>高位的体内地址</strong>送到由<strong>低位体号</strong>确定的模块内进行译码。<strong>CPU总是按行进行访问，地址按行进行编号</strong>。</p><p>若通过低位交叉编址按顺序进行访问存储单元，只需$T+(n-1)r$时间即可。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/direct/e37772bf19ea4cbaac40b5dcf268c8c9.png"></p><p>若通过高位交叉编址，访问连续存储单元地址需要等该存储体恢复后才能进行再次访问，因此则需要4T的时间开销。</p><p><img src="https://img-blog.csdnimg.cn/direct/8045c72dd1e44f3f9a31c9152bc40261.png"></p><h5 id="低位交叉编址下存储体的取的数量"><a href="#低位交叉编址下存储体的取的数量" class="headerlink" title="低位交叉编址下存储体的取的数量"></a>低位交叉编址下存储体的取的数量</h5><p>由于低位交叉方式下是采用“流水线”的方式进行并行存取（宏观上并行，微观上串行）。</p><p>宏观上，一个存储周期内，m体交叉存储器可以<strong>提供数据量为单个模块的m倍</strong>。</p><p>设存取周期为T，<strong>存取时间为r</strong>，为了使流水线不间断，应保证<strong>模块数</strong>$m\geq T&#x2F;r$，当m&#x3D;T&#x2F;r时，效率最佳。</p><p>设存取周期为T，<strong>总线传输周期为r</strong>，为了使流水线不间断，应保证<strong>模块数</strong>$m\geq T&#x2F;r$，当m&#x3D;T&#x2F;r时，效率最佳。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-存储器概述</title>
      <link href="/2023/12/04/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi-gai-shu/"/>
      <url>/2023/12/04/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi-gai-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><p>存储器种类繁多，可从不同角度对存储器进行分类。</p><h4 id="按在计算机中的作用（层次）分类"><a href="#按在计算机中的作用（层次）分类" class="headerlink" title="按在计算机中的作用（层次）分类"></a>按在计算机中的作用（层次）分类</h4><p><img src="https://img-blog.csdnimg.cn/direct/e89803cd178e4f2993c34d3a6f75309c.png"></p><ol><li>主存储器。简称主存，又称内存储器（内存），用来存放计算机运行期间所需的程序和数据，<strong>CPU可以直接随机地对其进行访问</strong>，也可以和Cache及辅存交换数据。<strong>特点是容量较小、存取速度较快，每位价格较高</strong>。</li><li>辅助存储器。简称辅存，用来存放需要永久性保存的信息。<strong>辅存的内容需要调入主存后才能被CPU访问</strong>。特点是<strong>容量大、存取速度较慢、单位成本低</strong>。</li><li>高速缓冲存储器。简称Cache，位于主存和CPU之间，用来存放CPU经常使用的指令和数据，以便CPU能高速地访问它们。<strong>Cache的存取速度可与CPU速度相匹配，但存储容量小、价格高。</strong>现代计算机通常集成在CPU中。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/3fc3df264a9c413ba22a9443c006d1bd.png"></p><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><p>按存储介质，存储器可分为磁表面（磁盘、磁带）、磁芯存储器、半导体存储器（MOS型存储器、双极型存储器，主存和Cache也属于这部分）和光存储器（光盘）。</p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><ol><li>随机存储器（RAM，Random Access Memory）。存储器的任何一个存储单元都可以随机存取，而且存取时间与存储单元的物理地址无关。<strong>优点是读写方便、使用灵活</strong>，用于主存和Cache。</li><li>只读存储器（ROM）。<strong>存储器的内容只能随机读出不能写入</strong>。信息一旦写入就固定不会，断电内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字库字库等。</li><li>串行访问存储器。对存储单元进行读&#x2F;写操作时，需按物理地址的先后顺序寻址，<strong>包括顺序存取存储器（SAM，如磁带）与直接存取存储器（DAM，如磁盘、光盘）</strong>。</li><li>相联存储器（CAM），即可以按内容访问的存储器，可以按照内容检索到存储位置进行读写。</li></ol><h4 id="按信息的可更改性分类"><a href="#按信息的可更改性分类" class="headerlink" title="按信息的可更改性分类"></a>按信息的可更改性分类</h4><ol><li>读写存储器（Read&#x2F;Write Memory）—即可读可写（如：磁盘、内存、Cache）</li><li>只读存储器（Read Only Memory）—只能读，不能写（如：实体音乐专辑通常采用CD-ROM，BIOS通常写在ROM中）</li></ol><h4 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a>按信息的可保存性分类</h4><p>断电后，存储信息消失的存储器称为<strong>易失性存储器</strong>，如RAM。</p><p>断电后，存储信息依然保存的存储器称为<strong>非易失性存储器</strong>，如磁盘，光盘。</p><p>信息读出后，原存储信息被破坏称为<strong>破坏性读出</strong>，如DRAM芯片。</p><p>信息读出后，原存储信息不被破坏称为<strong>非破坏性读出</strong>，如SRAM芯片、磁盘、光盘。</p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p>存储器由3个主要性能指标，即存储容量、单位成本和存储速度。</p><ol><li>存储容量 &#x3D; 存储字数 $\times$ 字长（如 1M $\times$ 8位）。单位换算：1B（Byte，字节）&#x3D;8b（bit,位）。</li><li>单位成本：每位价格 &#x3D; 总成本 &#x2F; 总容量。</li><li>存储速度： <strong>数据传输率</strong> &#x3D; 数据的宽度（数据宽度即是存储的字长）&#x2F; 存取周期（或称存储周期）。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/2d0acb369a544629acafa006a23dc5bd.png"></p><ul><li>存取时间（$T_a$）：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，<strong>分为读出时间和写入时间</strong>。</li><li>存取周期（$T_m$）：存取周期又称读写周期或访问周期。是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作之间所需的最小时间间隔。</li><li>主存带宽（$B_m$）：<strong>主存带宽又称数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位位字&#x2F;秒、字节&#x2F;秒（B&#x2F;s）、位节&#x2F;秒（b&#x2F;s）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路-电路定理</title>
      <link href="/2023/11/30/dian-lu-dian-lu-ding-li/"/>
      <url>/2023/11/30/dian-lu-dian-lu-ding-li/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="叠加定理"><a href="#叠加定理" class="headerlink" title="叠加定理"></a>叠加定理</h3><p>在线性电路中，任一支路的电流（或电压）可以看成是电路中<strong>每一个独立电源单独作用于电路时</strong>，在该支路产生的电流（或电压）的代数和。</p><p>结点电压和支路电流均为各电源的一次函数，均可看成各独立电源单独作用时，产生的响应之叠加。</p><p><strong>使用叠加定理注意事项：</strong></p><ol><li>叠加定理只适用于线性电路。</li><li>一个电源作用，其余电源为零。电压源为零——短路，电流源为零——开路。</li><li>功率不能叠加。</li><li>u ,i 叠加时要注意各分量的参考方向。</li><li>含受控源（线性）电路亦可用叠加，但受控源应始终保留。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/8b7bb80d7f9a4075a1ccd28e3dd673a2.png" alt="1-1"></p><p>例：求电压源的电流及功率</p><p><img src="https://img-blog.csdnimg.cn/direct/077748e6a4a944b7b4badb8e1ec79539.png" alt="1-2"></p><p>将上方电路进行拆分，拆分成两个简单电路的单独作用：</p><p><img src="https://img-blog.csdnimg.cn/direct/e0322890403d42cea3b0fcc72fc99099.png" alt="1-3"></p><p>显然左边的图为电桥平衡状态，此时$I(1)&#x3D;0$，右图在4Ω和2Ω间的结点列写KCL得$I(2)&#x3D;70&#x2F;14+70&#x2F;7&#x3D;15A$。所以原电路$I&#x3D;I(1)+I(2)&#x3D;15A,P_发&#x3D;15\times 70&#x3D;1050W$</p><h3 id="齐性原理"><a href="#齐性原理" class="headerlink" title="齐性原理"></a>齐性原理</h3><p>线性电路中，所有激励（独立源）都增大（或减少）同样的倍数，则电路中响应（电压或电流）也增大（或减小）同样的倍数。</p><p><strong>注：</strong></p><ol><li>当<strong>激励只有一个</strong>时，则响应与激励成正比。</li><li>具有可加性。</li></ol><p>例：</p><p>$R_L&#x3D;2Ω,R_1&#x3D;1Ω,R_2&#x3D;1Ω,u_s&#x3D;51V$，求电流i。</p><p><img src="https://img-blog.csdnimg.cn/direct/0c6d89bbc9824ac1939ee50ccbda43dd.png" alt="1-4"></p><p>采用倒推法：设$i’&#x3D;1A$</p><p>由齐性原理，则$\frac{i}{i’}&#x3D;\frac{u_s}{u_s’}$，即<br>$$<br>i&#x3D;\frac{u_s}{u_s’}i’&#x3D;\frac{51}{34}\times 1 &#x3D;1.5A<br>$$</p><h3 id="替代定理"><a href="#替代定理" class="headerlink" title="替代定理"></a>替代定理</h3><p>对于给定的任意一个电路，若某一支路电压为u，电流为i，那么这条支路就可以用一个电压等于u的独立电压源，或者用一个电流等于i的独立电流源，或用R&#x3D;u&#x2F;i的电阻来替代，<strong>替代后电路中全部电压和电流均保持原有值</strong></p><p>例：</p><p>求图中电路的支路电压和电流</p><p><img src="https://img-blog.csdnimg.cn/direct/f7759faa2ff94af6a5dd145ad1b6106d.png" alt="1-5"></p><p>先用电阻等效算:<br>$$<br>i_1&#x3D;\frac{110}{5+(5+10)&#x2F;&#x2F;10}&#x3D;10A<br>$$<br>并联分流算得$i_2&#x3D;(15\times i_1)&#x2F;10+15&#x3D;6A,i_3&#x3D;i_1-i_2&#x3D;4A$，欧姆定律再得$u&#x3D;6\times 10&#x3D;60V$</p><p>用将上图用替代定理验证，可得</p><p><img src="https://img-blog.csdnimg.cn/direct/dc327e092f2c415cbc6c5d6cd380b3d2.png" alt="1-6"></p><p>此时上方已经算得$V_u&#x3D;60V$，则$i_1&#x3D;(110-60)&#x2F;5&#x3D;10A,i_3&#x3D;60&#x2F;(10+15)&#x3D;4A$</p><p><strong>替代后各支路电压和电流完全不变。</strong></p><h3 id="戴维宁定理和诺顿定理"><a href="#戴维宁定理和诺顿定理" class="headerlink" title="戴维宁定理和诺顿定理"></a>戴维宁定理和诺顿定理</h3><p>戴维宁定理和诺顿定理就是将要求部分的外端等效成电阻和电压源串联的形式，以此来求出要求部分的电压或电流。</p><h5 id="定理的应用"><a href="#定理的应用" class="headerlink" title="定理的应用"></a>定理的应用</h5><ol><li><p>开路电压$U_{oc}$的计算</p><p>戴维宁等效电路中电压源电压等于将<strong>外电路断开时的开路电压</strong>$U_{oc}$，电压源方向与所求开路电压方向有关。</p></li><li><p>等效电阻的计算</p><p>等效电阻将一端口网络<strong>内部独立源全部置零（电压源短路，电流源开路）</strong>后，所得无源一端口网络的输入电阻。（若有受控源可使用外加电源法，加电压求电流或加电流求电压）</p></li></ol><p>通过戴维宁定理可将外部有源端口网络等效成如下图</p><p><img src="https://img-blog.csdnimg.cn/direct/215201a1c85f46f9a8d70f934d0ff878.png" alt="1-7"></p><p>例：</p><p>求开路电压$U_{oc}$</p><p><img src="https://img-blog.csdnimg.cn/direct/bd46281c769a46839cda36ed35c609c4.png"><br>$$<br>I&#x3D;\frac{20-10}{10+10}&#x3D;0.5A\<br>U_{oc}&#x3D;10+0.5\times 10 &#x3D; 15V<br>$$<br>再求输入电阻$R_{eq}$，将电源都置零得$R_{eq}&#x3D;10&#x2F;&#x2F;10&#x3D;5Ω$，所以可以等效为：</p><p><img src="https://img-blog.csdnimg.cn/direct/9c409a6d9a8441009cb2fe2f4277e568.png"></p><p>诺顿定理则是换成电流源，方向从电压源负到正。</p><p><strong>注</strong></p><ol><li>外电路可以是<strong>任意的线性或非线性电路</strong>，外电路发生改变时，含源一端口网络的等效电路不变。</li><li>当一端口内部含有受控源时，<strong>控制电路与受控源必须包含在被化简的同一部分电路中</strong></li></ol><h3 id="最大功率传输定理"><a href="#最大功率传输定理" class="headerlink" title="最大功率传输定理"></a>最大功率传输定理</h3><p>一个含源线性一端口电路，当所接负载不同时，一端口网络传输给负载的功率就不同，讨论负载为何值时能从电路中获取最大功率。</p><p>最大功率传输定理就是用戴维宁来等效后再根据负载来算最大功率</p><p><img src="https://img-blog.csdnimg.cn/direct/8ffa864badab49c8ab7afd618a719f4a.png"></p><p>根据$P&#x3D;R_L(\frac{u_{oc}}{R_{eq}+R_L})^2$（$R_L$为未知量）可最后算得最大功率：<br>$$<br>R_L&#x3D;R_{eq}时,P_{max}&#x3D;\frac{u_{oc}^2}{4R_{eq}}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-浮点数的表示与运算</title>
      <link href="/2023/11/29/ji-suan-ji-zu-cheng-yuan-li-fu-dian-shu-de-biao-shi-yu-yun-suan/"/>
      <url>/2023/11/29/ji-suan-ji-zu-cheng-yuan-li-fu-dian-shu-de-biao-shi-yu-yun-suan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><p>由于定点数可表示的数字范围有限，而又不能无限制的增加数据的长度，就得考虑在位数不变的情况下增加数据的表示范围，以此拓展了浮点数。例，用定点数表示电子的质量($9 \times 10^{-28}g$)。</p><h4 id="浮点数的表示格式"><a href="#浮点数的表示格式" class="headerlink" title="浮点数的表示格式"></a>浮点数的表示格式</h4><p>通常，浮点数表示为<br>$$<br>N&#x3D;(-1)^S\times M \times R^E<br>$$<br>其中，<strong>S取值0或1，用来决定浮点数的符号</strong>；M是一个二进制定点小数，称为尾数，一般用定点原码小数表示，称为<strong>阶码或指数</strong>，用<strong>移码</strong>表示。R是基数（隐含），可以约定为2、4、16，基本为2等。</p><p><img src="https://img-blog.csdnimg.cn/direct/22de4b88dee5435194ecb5dedd369146.png" alt="1-1"></p><p><strong>尾数的位数反映浮点数的精度</strong>。</p><p>例：阶码、尾数均用补码表示，求a、b的真值</p><p>$a&#x3D;0,01;1.1001$，$b&#x3D;0,10;0.01001$(阶码<code>,</code>前为符号位，尾数<code>.</code>前为符号位)</p><p>a:  阶码0,01 对应真值 +1  尾数 1.1001 对应原码 1.0111，对应真值为 -0.0111，所以a的真值$&#x3D;2^1\times (-0.0111)&#x3D;-0.111$</p><p>b: 阶码0,10 对应真值 +2  尾数 0.01001 对应真值 +0.01001 ，所以b的真值$&#x3D;2^2\times (+0.01001)&#x3D;+1.001$</p><h4 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h4><p>尾数的尾数决定浮点数的有效数位，有效数位越多，数据的精度越高。为了在浮点数运算过程中尽可能多的保留有效数字的位数，所以才需进行规格化操作。所谓<strong>规格化</strong>，是指通过调整一个非规格化浮点数的<strong>尾数和阶码的大小</strong>，使非零的浮点数在尾数的最高数位商保证是一个有效值。</p><ul><li><strong>左规</strong>：当浮点数运算的结果为非规格化要进行规格化处理，将<font color="#ff0000">尾数算数左移一位，阶码减1</font>.</li><li><strong>右规</strong>：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，<font color="#ff0000">尾数算数右移一位，阶码加1</font>.</li></ul><p>例： a &#x3D; 010; 00.1100 ,  b &#x3D; 010; 00.1000 ,  求a+b</p><p>可得 a $&#x3D; 2^2\times 00.1100$， b &#x3D; $2^2 \times 00.1000$， a+b &#x3D; $2^2\times(00.1100 + 00.1000)&#x3D;2^2\times 01.0100$，此时就导致了溢出，可以通过<strong>右规</strong>得：a + b&#x3D; $2^2\times 01.0100&#x3D; 2^3\times 00.1010$</p><h5 id="浮点数规格化的特点"><a href="#浮点数规格化的特点" class="headerlink" title="浮点数规格化的特点"></a>浮点数规格化的特点</h5><ol><li><p>用原码表示的尾数进行规格化：</p><ol><li>正数为$0.1\times \times \dots \times$的形式（0为符号位，最高位为1），其最大值表示为$0.1111\dots 1$；最小值表示为$0.100\dots 0$。尾数的表示范围$\frac{1}{2} \leq M \leq (1-2^{-n})$</li><li>负数为$1.1\times \times \dots \times$的形式，其最大值表示为$1.1000\dots0$；最小值表示为$1.1111\dots1$。尾数的表示范围为$-(1-2^{-n})\leq M \leq -\frac{1}{2}$</li></ol></li><li><p>用补码表示的尾数进行规格化：</p><ol><li>正数为$0.1\times \times \dots \times$的形式（0为符号位，最高位为1），其最大值表示为$0.1111\dots 1$；最小值表示为$0.100\dots 0$。尾数的表示范围$\frac{1}{2} \leq M \leq (1-2^{-n})$</li><li>负数为$1.0\times \times \dots \times$的形式，其最大值表示为$1.0111\dots 1$；最小值表示为$1.000\dots0$。尾数的表示范围为$-1\leq M \leq -(1&#x2F;2 +2^{-n})$</li></ol><p><strong>总结</strong>：</p><p>规格化的原码尾数，<strong>最高数值位一定是1</strong>，规格化的补码尾数，<strong>符号位与最高数值位一定相反</strong>。</p></li></ol><p>例：若某浮点数的阶码、尾数用补码表示，共4+8位；   0.110; 1.1110100，进行规格化：</p><p>由于补码负数的最高位和符号位要相反，所以要进行左规进行规格化，$2^6\times -(1110100)&#x3D;2^3 \times -(01000000)$，就规格化完毕。</p><p><strong>基数不同，浮点数的规格化形式也不同。</strong></p><h3 id="浮点数-IEEE-754标准"><a href="#浮点数-IEEE-754标准" class="headerlink" title="浮点数 IEEE 754标准"></a>浮点数 IEEE 754标准</h3><p>在了解IEEE 754标准前，先回忆下移码的概念，移码实际就是补码的符号位取反获得。移码的定义是：<strong>移码&#x3D;真值+偏置值</strong>（偏置值一般是$2^{n-1}$，此时<strong>移码&#x3D;补码符号位取反</strong>）。</p><p>例：设8位机器来表示移码，此处8位移码的<strong>偏置值&#x3D;128D&#x3D;1000 0000B</strong>。</p><p>真值 -127D &#x3D; -1111 111B，移码 &#x3D; -111 1111 + 1000 0000&#x3D; 0000 000 </p><p><strong>在IEEE 754标准中，通常会将偏置值&#x3D;$2^{n-1}-1$</strong></p><p><img src="https://img-blog.csdnimg.cn/direct/9668425212434179b64d28215e271651.png" alt="1-2"></p><p>IEEE754标准规定常用的浮点数格式有短浮点数（单精度、float型）、长浮点数（双精度、double型）、临时浮点数，其基数隐含为2，<strong>在IEEE754中，尾数采用原码表示</strong>。</p><p><img src="https://img-blog.csdnimg.cn/direct/770c3a5b227b4df9afd2ee09655e9c5f.png" alt="1-3"></p><p>由于移码&#x3D;真值+偏置值，由此可以得出<strong>阶码真值&#x3D;移码-偏移量</strong></p><p><strong>规格化的短浮点数的真值</strong>为：$(-1)^s\times 1.M\times 2^{E-127}$</p><p><strong>规格化长浮点数的真值</strong>为：$(-1)^s\times 1.M\times 2^{E-1023}$</p><p>例：将十进制数-0.75转换为IEEE754的单精度浮点数格式表示</p><p>由于是负数，所以<strong>数符&#x3D;1</strong>，<strong>尾数部分&#x3D;.100000….（共23位，隐含最高位1）</strong>，<strong>移码</strong>&#x3D;真值+偏置值&#x3D;-1+127&#x3D;-1 + 111 1111 &#x3D; 0111 1110（凑足8位）</p><p>最后可得IEEE 754标准规定浮点数为：<font color="#ff0000">1</font><font color="#AEEEEE">011 1111 0</font>100 0000 0000 0000 0000 0000</p><p>例2：IEEE 754的单精度浮点数 C0 A0 00 00 H的值是多少</p><p>C0 A0 00 00 -&gt; <font color="#ff0000">1</font><font color="#AEEEEE">100 0000 1</font>010 0000 0000 0000 0000 0000，可得<strong>数符&#x3D;1</strong>，所以为负数，<strong>尾数部分&#x3D;1.01</strong>，<strong>真值</strong>&#x3D;移码 - 偏置值&#x3D; 1000 0001 - 0111 1111 &#x3D; 0000 0010 &#x3D; 2D，所以最终值为$(-1.01)_2\times2^2&#x3D;(-1.25)\times2^2&#x3D;-5.0$</p><h5 id="IEEE-754单精度浮点型能表示的最小绝对值、最大绝对值"><a href="#IEEE-754单精度浮点型能表示的最小绝对值、最大绝对值" class="headerlink" title="IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值"></a>IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值</h5><p><strong>最小绝对值</strong>：尾数全为0，阶码真值最小 -126（**-128全1和-127全0有其他用途**），对应移码机器数 0000 0001 此时整体的真值为$(1.0)_2\times 2^{-126}$。</p><p><strong>最大绝对值</strong>：尾数全为1，阶码真值最大 127，对应移码机器数 1111 1110 此时整体的真值为$(1.111..11)_2\times 2^{127}$。</p><p><img src="https://img-blog.csdnimg.cn/direct/1d2b46ba21594081af93534eeb7258da.png" alt="1-4"></p><p><strong>只有$1\leq E \leq 254 $时，真值&#x3D;$(-1)^s\times 1.M \times 2^{E-127} $</strong></p><p>当<font color="#ff0000">阶码全为0，尾数M不全为0时</font>，表示<strong>非规格小数</strong>，则真值表示形式为$±(0.xxx…x)_2 \times 2^{-126}$</p><p>阶码真值固定为-126。</p><p>当<font color="#ff0000">阶码全为0，尾数M全为0时</font>，表示真值±0</p><p>当<font color="#ff0000">阶码全为1，尾数M全为0时</font>，表示真值无穷大$±\infin$</p><p>当<font color="#ff0000">阶码全为1，尾数M不全为0时</font>，表示真值非数值“NaN”（Not a Number）</p><h5 id="定点、浮点表示的区别"><a href="#定点、浮点表示的区别" class="headerlink" title="定点、浮点表示的区别"></a>定点、浮点表示的区别</h5><ol><li><p>数值的表示范围</p><p>若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围<strong>远大于</strong>定点表示法。</p></li><li><p>精度</p><p>对于字长相同的定点数和浮点数来说，虽然浮点数扩大了表示范围，但<strong>精度降低</strong>了。</p></li><li><p>数的运算</p><p>浮点数包括阶码和尾数两部分，运算时不仅要左尾数的运算，还要做阶码的运算，而且运算结果要求规格化。</p></li><li><p>溢出问题</p><p>在定点数运算中，当运算结果超出数的表示范围时，发生溢出；浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后<strong>阶码超出所能表示的范围</strong>时，才发生溢出。</p></li></ol><h3 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h3><p>浮点数加减运算分为以下几步：</p><ol><li>对阶</li><li>尾数加减</li><li>规格化</li><li>舍入</li><li>判溢出</li></ol><p>例：已知十进制数$X&#x3D;-5&#x2F;256$、$Y&#x3D;+59&#x2F;1024$，按机器补码浮点运算规则计算 X - Y，结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位。尾数取9位。</p><p>将X，Y用二进制表示$X&#x3D;(-101)_2\times2^{-8}&#x3D;(-0.101)_2\times2^{-5}$</p><p>$Y&#x3D;(+111011)_2\times 2^{-10}&#x3D;(0.111011)_2\times 2^{-4}$</p><p>由题目用<strong>补码</strong>表示X和Y，且阶乘也用二进制补码形式，则有（阶符取2位，阶码3位）：</p><p>X&#x3D;$(11.011000000)_{补}\times 2^{11011}$</p><p>Y&#x3D;$(00.111011000)_补\times 2^{11100}$</p><p>最后进行组合则有</p><p>X&#x3D;$11011,11.011000000$</p><p>Y&#x3D;$11100,00.111011000$</p><ol><li><p>对阶</p><p>首先要将阶码对齐，阶数小的对阶数大的对阶，尾数每右移一位，阶码加1。</p><p>计算机判断哪个阶数大，通过<strong>求阶差：$[ΔE]_补&#x3D;11011 + 00100&#x3D;11111$ ，得ΔE&#x3D;-1</strong>，说明X比Y阶数小，且小1，需要让X尾数右移。得$X&#x3D;11100,11.101100000$</p></li><li><p>尾数加减</p><p>将对阶后的值尾数进行相减：</p><p>$X-Y&#x3D;11100,11.101100000 + 11100,11.000101000&#x3D;11100,10.110001000$</p></li><li><p>规格化</p><p>$X-Y:11100,10.110001000$ -&gt; $X-Y:11101,11.011000100$</p></li><li><p>舍入</p><p>无舍入</p></li><li><p>判溢出</p><p>常阶码，无溢出，结果真值为$2^{-3} \times (-0.1001111)_2$（<strong>若阶码上溢，直接抛出异常终端，阶码下溢出，则按机器0处理</strong>）</p></li></ol><h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4><h5 id="“0”舍“1”入法"><a href="#“0”舍“1”入法" class="headerlink" title="“0”舍“1”入法"></a>“0”舍“1”入法</h5><p>类似于十进制数中的“四舍五入”，即在尾数右移时，被移去的最高数位为0，则舍去；若为1，则在尾数的末位加1。这可能会使<strong>尾数又溢出</strong>，此时需要再做以此右规。</p><h5 id="恒置“1”法"><a href="#恒置“1”法" class="headerlink" title="恒置“1”法"></a>恒置“1”法</h5><p>尾数右移时，不论丢掉的最高数值位是“1”还是“0”，都使右移后的<strong>尾数末位恒置“1”</strong>。这种方法同样有使尾数变大或变小的可能。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p><img src="https://img-blog.csdnimg.cn/direct/a423d91ce4d54b8fa6896cabea2691dc.png" alt="2-1"></p><p>上表为C语言在各机器中所占大小，当强制类型转换以 <code>char -&gt; int -&gt; long -&gt; double</code>和 <code>float -&gt; double</code>时，范围都由小到大，精度不会丢失。（<code>long-&gt;double</code>是以32位机器位标准，64位会出现精度损失）</p><p><code>int</code>可以表示32位，<code>float</code>表示为 1 + 8 + 23 &#x3D; 32，实际能表示的数为24位（23+1包含隐含的1）。<strong>所以<code>int</code>转<code>float</code>会产生精度损失，但不会溢出。 而<code>float</code>-&gt;<code>int</code>，可能溢出及损失精度。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 数制与编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-补充知识点</title>
      <link href="/2023/11/29/ji-suan-ji-zu-cheng-yuan-li-bu-chong-zhi-shi-dian/"/>
      <url>/2023/11/29/ji-suan-ji-zu-cheng-yuan-li-bu-chong-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="C语言数据转换时应注意的问题："><a href="#C语言数据转换时应注意的问题：" class="headerlink" title="C语言数据转换时应注意的问题："></a>C语言数据转换时应注意的问题：</h4><ol><li><p><strong>有符号数和无符号数之间的转换</strong>。例，由<code>signed</code>型转等长<code>unsigned</code>型数据时，<strong>符号位成为数据的一部分</strong>，即负数转换位无符号数时，数值将发生变化。同理，由<code>unsigned</code>转换为<code>signed</code>时最高位为符号位，也可能会发生数值变化。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//二进制形式 1111 1111 1111 0110</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -10</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//二进制形式 1111 1111 1111 0110</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//65526</span></code></pre></li><li><p><strong>数据的截取与保留</strong>。当一个<strong>浮点数转换为整数</strong>时，浮点数的小数部分全部舍去，并按整数形式存储。但浮点数的整数部分不能超过整形数允许的最大范围，否则溢出。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10.120</span><span class="token punctuation">;</span><span class="token keyword">short</span> s <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-10</span></code></pre></li><li><p><strong>数据转换中的精度丢失</strong>。四舍五入会丢失一些精度，截去小数也会丢失一些精度。此外，数据由long型转换为flaot型或double型时，有可能在存储时不能准确地表示该长整数的有效数字，精度也会受到影响。</p></li><li><p><strong>精度转换结果的不确定性</strong>。当较长的整数转换为较短的整数时，要将高位截去。例，<strong>long型转换为short型，只将低16位送去</strong>，这就会产生很大的误差。</p></li></ol><h3 id="计算机的数值数据是否都是二进制数"><a href="#计算机的数值数据是否都是二进制数" class="headerlink" title="计算机的数值数据是否都是二进制数"></a>计算机的数值数据是否都是二进制数</h3><p>在计算机内部，数值表示由以下两大类。</p><ol><li>直接用二进制数表示。分为有符号数和无符号数，<strong>有符号数</strong>又分为定点数表示和浮点数表示。<strong>无符号数</strong>用来表示无符号整数（如地址等信息）。</li><li>二进制编码的十进制数，一般采用BCD码，用来表示整数。</li></ol><p>计算机中数值数据虽然都用二进制，但不完全都是二进制，也有用十进制表示。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路-电阻电路的一般分析</title>
      <link href="/2023/11/23/dian-lu-dian-zu-dian-lu-de-yi-ban-fen-xi/"/>
      <url>/2023/11/23/dian-lu-dian-zu-dian-lu-de-yi-ban-fen-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="网孔电流法"><a href="#网孔电流法" class="headerlink" title="网孔电流法"></a>网孔电流法</h3><p>网孔电流法是以沿网孔连续流动的假想电流为未知量列写电路方程分析电路的方法。仅适用于平面电路。</p><h4 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h4><p>为减少未知量的个数，假想每个回路种有一个回路电流。各支路电流可用回路电流的线性组合表示，来求得电路的解。</p><h4 id="列写的方程："><a href="#列写的方程：" class="headerlink" title="列写的方程："></a>列写的方程：</h4><p>网孔电流在网孔中是闭合的，对每个相关节点均流进一次，流出一次，所以KCL自动满足。因此网孔电流法的<strong>方程个数即为网孔数</strong>。网孔方程是根据KVL进行列写。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/82dca3b0c41f4d4d865e39f63daae06d.png" alt="1-1"></p><p>假想图1-1两个回路$l_1,l_2$的电流分别为$i_{l1},i_{l2}$，支路电流可表示为：<br>$$<br>i_1&#x3D;i_{l1}\qquad i_3&#x3D;i_{l2}\<br>i_2&#x3D;i_{l2} - i_{l1}<br>$$</p><p>方程可列写为：<br>$$<br>\begin{cases}<br>\ l_1:R_1i_{l1}+R_2(i_{l1}-i_{l2})+u_{S2}-u_{S1}&#x3D;0\<br>\ l_2:R_2(i_{l2}-i_{l1})+R_3i_{l2}-u_{S2}&#x3D;0\</p><p>\end{cases}<br>$$<br>整理得：<br>$$<br>\begin{cases}<br>\ l_1:(R_1+R_2)i_{l1}-R_2i_{l2}&#x3D;u_{S1}-u_{S2}\<br>\ l_2:-R_2i_{l1}+(R_2+R_3)i_{l2}&#x3D; u_{S2}\</p><p>\end{cases}<br>$$</p><p>若称回路自身所经过的电阻为自电阻，与其他回路共有的称为互电阻。</p><p>由上方方程可得自身回路电流为自电阻之和，若<strong>支路方向相同时</strong>，互电阻取正号，相反时取负号并乘上对方的回路电流。</p><h4 id="网孔电流法的一般步骤："><a href="#网孔电流法的一般步骤：" class="headerlink" title="网孔电流法的一般步骤："></a>网孔电流法的一般步骤：</h4><ol><li>选网孔为独立回路，并确定其绕行方向；</li><li>以网孔电流为未知量，自动满足KCL，列其KVL方程，且是独立的；</li><li>求上诉方程，得到l个网孔电流；</li><li>求各支路电流；</li><li>其他分析；</li></ol><h3 id="回路电流法"><a href="#回路电流法" class="headerlink" title="回路电流法"></a>回路电流法</h3><p>回路电流法是网孔电流法的拓展，以基本回路中沿回路连续流动的假想电流为未知量列写电路方程分析电路的方法。适用于<strong>平面和非平面方程</strong>。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/e11902fb480e46fd9b6fc3e197fc31c9.png" alt="1-2"></p><p>如图1-2中选取回路电流为$i_1,i_2,i_3$，可根据网孔电流法列出相应的回路电流方程：<br>$$<br>\begin{cases}<br>\ l_1:(R_1+R_6+R_5+R_4)i_1+(R_5+R_4)i_2-(R_5+R_6)i_3&#x3D;-u_{S1}+u_{S5}\<br>\ l_2:(R_5+R_4)i_1+(R_2+R_5+R_4)i_2-R_5i_3&#x3D;U_{S5}\<br>\ l_3:-(R_5+R_6)i_1-R_5i_2+(R_3+R_5+R_6)i_3&#x3D;-u_{S5}<br>\end{cases}<br>$$</p><h3 id="结点电压法"><a href="#结点电压法" class="headerlink" title="结点电压法"></a>结点电压法</h3><p>以结点电压为未知量列写电路方程分析电路的方程。<strong>适用于结点较少的电路</strong></p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>选结点电压为未知量，则KVL自动满足，无需列写KVL方程。各支路电流、电压可视为结点电压的线性组合，求出结点电压后，便可得到各支路电压、电流。</p><h4 id="方程的列写"><a href="#方程的列写" class="headerlink" title="方程的列写"></a>方程的列写</h4><p>结点电压列写的是结点上KCL方程。</p><ol><li>选定参考结点，表明其余n-1个独立结点的电压。</li><li>列写KCL方程：$\sum i_{R出}&#x3D;\sum i_{S入}$</li><li></li></ol><p>例：</p><p><img src="https://img-blog.csdnimg.cn/direct/c55ce3be6556478fa40c331163d09043.png" alt="1-3"></p><p>将最下方接地，1 2 3号结点电压为$u_{n1}u_{n2}u_{n3}$列1 2 3号结点的KCL方程：<br>$$<br>1 :i_1+i_2&#x3D;i_{s1}+i_{s2}\<br>2 :-i_2+i_3+i_4&#x3D;0\<br>3 :-i_3+i_5&#x3D;-i_{s2}<br>$$<br>然后把支路电流用结点电压表示：<br>$$<br>\frac{u_{n1}}{R_1}+\frac{u_{n1}-u_{n2}}{R_2}&#x3D;i_{s1}+i_{s2}\<br>-\frac{u_{n1}-u_{n2}}{R_2}+\frac{u_{n2}-u_{n3}}{R_3}+\frac{u_{n2}}{R_4}&#x3D;0\<br>-\frac{u_{n2}-u_{n3}}{R_3}+\frac{u_{n3}-u_s}{R_5}&#x3D;-i_{s2}<br>$$<br>最后整理得：<br>$$<br>\begin{cases}<br>(\frac{1}{R_1}+\frac{1}{R_2})u_{n1}-(\frac{1}{R_2})u_{n2}&#x3D;i_{s1}+i_{s2}\<br>\ -(\frac{1}{R_2})u_{n1} +(\frac{1}{R_2}+\frac{1}{R_3}+\frac{1}{R_4})u_{n2}-(\frac{1}{R_3})u_{n3}&#x3D;0\</p><p>\ -(\frac{1}{R_3})u_{n2}+(\frac{1}{R_3}+\frac{1}{R_5})u_{n3}&#x3D;-i_{s2}+\frac{u_s}{R_5}<br>\end{cases}<br>$$<br>即为结点电压的最终方程表达式（或者用电导的形式）</p><p><strong>根据上方例子可总结出结点电压法的特性</strong>：</p><p>设$\frac{1}{R_i}&#x3D;G_i$（电阻的倒数等于电导），那么该结点的自电导（即与该结点相邻的电导）之和与该结点电压相乘，互电导（互电导为接在结点与结点之间的电导之和）<strong>总为负值</strong></p>]]></content>
      
      
      <categories>
          
          <category> 电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-数据的表示与运算</title>
      <link href="/2023/11/21/ji-suan-ji-zu-cheng-yuan-li-shu-ju-de-biao-shi-yu-yun-suan/"/>
      <url>/2023/11/21/ji-suan-ji-zu-cheng-yuan-li-shu-ju-de-biao-shi-yu-yun-suan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h3><h4 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h4><p>总所周知，计算机系统内部只能使用二进制进行编码，所以进制间的转换尤为重要。</p><h5 id="进位计数法"><a href="#进位计数法" class="headerlink" title="进位计数法"></a>进位计数法</h5><p>常用的进位计数法由十进制、二进制、八进制、十六进制等。</p><ol><li>二进制：二进制只有0和1两种数字符号，计数“逢二进一”，它的任意数位权位$2^i$，i位所在位数。</li><li>八进制：八进制有0~7八种数字符号，计数“逢八进一”，它的任意数位权位$8^i$，i位所在位数，<strong>二进制的3位数码编为一组</strong>解释一位八进制数码。</li><li>八进制：八进制有0~9、A、B、C、D、E、F十六种符号，计数“逢十六进一”，它的任意数位权位$16^i$，i位所在位数，<strong>二进制的4位数码编为一组</strong>解释一位十六进制数码。</li></ol><h5 id="各种进制的常见书写方式："><a href="#各种进制的常见书写方式：" class="headerlink" title="各种进制的常见书写方式："></a>各种进制的常见书写方式：</h5><ol><li>二进制： $(1010)_2&#x3D;1010B$</li><li>八进制：$(1652)_8$</li><li>十六进制：$(1652)_{16}&#x3D;1652H&#x3D;0x1652$</li><li>十进制：$(1652)_{10}&#x3D;1652D$</li></ol><h5 id="不同进制数间的相互转换"><a href="#不同进制数间的相互转换" class="headerlink" title="不同进制数间的相互转换"></a>不同进制数间的相互转换</h5><ol><li><p><strong>二进制转换八进制数和十六进制数</strong></p><p>在进行转换时，应以小数点为界。3位（4位）二进制转为1位<strong>八进制（十六进制）</strong>，若整数不足3位（4位）则需在左侧补0补齐位数，而若浮点数部分不足3位（4位）则需在右侧补0齐位数。</p><p>例：将1111000010.01101分别转换为八进制和十六进制数。</p><p>解：</p><p><strong>转八进制</strong><br>$$<br>(1111000010.01101)_2 &#x3D;(001\ 111\ 000\ 010.011\ 010)_2\<br>&#x3D;(1702.32)_8<br>$$<br><strong>转十六进制</strong><br>$$<br>(1111000010.01101)_2 &#x3D;(0011\ 1100\ 0010.0110\ 1000)<em>2\<br>&#x3D;(3C2.68)</em>{16}<br>$$<br>同样，由八进制（十六进制）转二进制，只需将每位改成2位（4位）二进制数即可。</p></li><li><p><strong>任意进制转十进制数</strong></p><p>将任意进制数的各位数码与它们的权值相乘，再把乘积相加即可得到对应的十进制数。</p><p>例：$(11011.1)_2$转为十进制：<br>$$<br>(11011.1)<em>2&#x3D;1\times 2^4 + 1\times 2^3 +0\times 2^2 + 1\times 2^1 + 1 \times 2^0 + 1 \times 2^{-1} &#x3D; (27.5)</em>{10}<br>$$</p></li><li><p><strong>十进制数转换为任意进制数</strong></p><p>一个十进制数转换为任意进制数，常用基数乘除法，即对整数部分用除基取余法，对小数部分用乘基取余法，最后将整数部分和小数部分的转换结果拼接即可。</p><p>例：$(75.3)_{10}$转二进制：</p><p>整数部分计算（“…”后面为余数）：<br>$$<br>75\div 2&#x3D;37\dots1\<br>37\div 2&#x3D;18\dots1\<br>18\div 2&#x3D;9\dots0\<br>9\div 2&#x3D;4\dots1\<br>4\div 2&#x3D;2\dots0\<br>2\div 2&#x3D;1\dots0\<br>1\div 2&#x3D;0\dots1\<br>$$<br>下面为高位，上面为低位，可得整数部分二进制为$(75)_{10}&#x3D;(1001011)_2$</p><p><img src="https://img-blog.csdnimg.cn/1efbb9508c1e40f4b52da4f9eb64402e.png" alt="1-1"></p><p>小数部分$(0.3)<em>{10}$计算：<br>$$<br>0.3\times 2&#x3D; 0.6 &#x3D; 0 + 0.6\<br>0.6\times 2&#x3D; 1.2 &#x3D; 1 + 0.2\<br>0.2\times 2&#x3D; 0.4 &#x3D; 0 + 0.4\<br>0.4\times 2&#x3D; 0.8 &#x3D; 0 + 0.8\<br>0.8\times 2&#x3D; 1.6 &#x3D; 1 + 0.6\<br>\dots<br>$$<br>小数部分无法精确转换，到出现相同值即可$(0.3)</em>{10}&#x3D;(01001\dots)_2$</p><p><img src="https://img-blog.csdnimg.cn/afba45b13793407e8697a6d4add5319c.png" alt="1-2"></p></li></ol><p>所以$(75.3)_{10}&#x3D;(1001011.01001\dots)_2$</p><h5 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h5><p>日常生活中，通常用正号、负号来表示正数和负数，如+15、-8等。这种带“+”或“-”符号的数<strong>称为真值</strong>。<strong>真值是机器数所代表的实际值</strong>。</p><p>在计算机中，通常用“0”表示“正”，“1”表示“负”。这种把符号“数字化”的数称为<strong>机器数</strong>。常用的由源码、补码和反码表示。例：0,101（”,”区分符号位与数值位）表示+5。</p><h3 id="BCD-Binary-Coded-Decimal-码"><a href="#BCD-Binary-Coded-Decimal-码" class="headerlink" title="BCD(Binary-Coded Decimal)码"></a>BCD(Binary-Coded Decimal)码</h3><p>二进制编码的十进制通常用4位二进制数来表示一位十进制中的0~9这10个数码。可得必有6种状态为冗余状态。</p><p>常用的BCD码：</p><ol><li><p><strong>8421码（常用）</strong>：它是一种有权码，设其各位的数值为$b_3,b_2,b_1,b_0$，则权值从高到低依次为8,4,2,1，它表示的十进制数为$D&#x3D;8b_3+4b_2+2b_1+1b_0$。如 8-&gt;1000; 9-&gt;1001;</p><p>若两个8421码相加之和大于或等于$(1010)<em>2$，即$(10)</em>{10}$，则需要加6修正（从1010到1111这6个无效码），并向高位进位。</p><p>例：$(0100)<em>{8421}+(1001)</em>{8421}&#x3D;(1101)<em>{8421}$，即$4+9&#x3D;13$需要进行修正：<br>$$<br>(1101)</em>{8421}+(0110)_{8421}&#x3D;(10011)_2<br>$$</p></li><li><p><strong>余3码</strong>：它是一种无权码，是在8421码的基础上加$(0011)_2$形成的，因每个数都多余”3“，因此称为余3码。如8-&gt;1011; 9-&gt;1100。</p></li><li><p><strong>2421码</strong>：它是一种有权码，权值由高到低分别为2，4，2，1，<strong>特点是大于或等于5的4位二进制数中最高位为1，小于5的最高位为0</strong>。</p></li></ol><h3 id="定点数的编码表示"><a href="#定点数的编码表示" class="headerlink" title="定点数的编码表示"></a>定点数的编码表示</h3><p>根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。</p><p><strong>定点数</strong>：即小数点位置固定。例：996.007    （小数点位置<strong>会</strong>随数的大小发生变化）</p><p><strong>浮点数</strong>：即小数点的位置不固定。 例：$9.96007\times 10^2$    （小数点位置<strong>不会</strong>随数的大小发生变化，科学计数法）</p><h4 id="机器数的定点表示"><a href="#机器数的定点表示" class="headerlink" title="机器数的定点表示"></a>机器数的定点表示</h4><p><strong>无符号数</strong>：无符号数就是整个机器字长全部二进制位均为数值位，没有符号位，相当于数的绝对值。</p><p><strong>无符号数表示范围（通常只有无符号整数，而没无符号小数）</strong>：</p><p>​若有8位二进制数：则有$2^8$种不同的状态，即$(0000\ 0000)_2\ $<del>$  (1111\ 1111)_2$，十进制为0</del>255种状态。</p><p>​可得<strong>n位的无符号数的表示范围</strong>：0~$2^n-1$</p><p><strong>有符号数的定点表示法</strong>用来表示定点小数和定点整数。</p><ol><li>定点小数：即约定符号位之后、有效数值最高位前位小数点位置，就是符号位后就是小数部分。</li><li>定点整数：即在整数部分最低位之后为小数点。</li></ol><p><img src="https://img-blog.csdnimg.cn/c39c99ea35d94572b773c1884719a951.png" alt="1-3"></p><p>注：可用<strong>原码、反码、补码</strong>三种表示定点整数和定点小数，可用<strong>移码</strong>来表示定点整数。</p><p>若<strong>真值为x</strong>，则用$[x]_原、[x]_反、[x]_补、[x]_移$分别表示对应的原、反、补、移码。</p><h4 id="原码、补码、反码、移码"><a href="#原码、补码、反码、移码" class="headerlink" title="原码、补码、反码、移码"></a>原码、补码、反码、移码</h4><h5 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h5><p>用机器数的<strong>最高位</strong>表示数的符号，其余各位表示数的绝对值。</p><p>例：机器字长为8位，那么最高位为符号位，剩下7位为数的有效位。</p><p><strong>定点整数的原码</strong>表示：</p><p><img src="https://img-blog.csdnimg.cn/8057d96d89f14f3589dc6bc8ad2a7ee3.png" alt="1-4"></p><p>若存入的值是$+19D$，那么此时存储的二进制为$[x]_原&#x3D;0,0010011$。</p><p>若存入的值是$-19D$，那么此时存储的二进制为$[x]_原&#x3D;1,0010011$。</p><p>此时小数点默认隐含在最低位的右边。</p><p><strong>定点小数的原码</strong>表示：</p><p><img src="https://img-blog.csdnimg.cn/6c792fd36bd64ef7a3ea7e6e9f9fb598.png" alt="1-5"></p><p>若存入的值是$+0.75D$，那么此时存储的二进制为$[x]_原&#x3D;0.1100000$。</p><p>若存入的值是$-0.75D$，那么此时存储的二进制为$[x]_原&#x3D;1.1100000$。</p><p>此时小数点默认隐含在最低位的右边。</p><p>**可得若机器字长为n+1位，则尾数占n位。 **</p><p><strong>原码整数的表示范围</strong>：$-(2^n-1)\leq x \leq 2^n-1 $。真值0有**+0和-0**两种形式。</p><p><strong>原码小数的表示范围</strong>：$-(1-2^{-n})\leq x \leq 1-2^{-n} $。真值0有**+0和-0**两种形式。</p><h5 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h5><p>若<strong>符号位为0</strong>（即为正数），则反码与原码相同。</p><p>若<strong>符号位为1</strong>（即为负数），则数值位全部取反则为反码。</p><p>例：<br>$$<br>x&#x3D;+19D \quad [x]_原&#x3D;0,0010011\<br>\qquad  [x]_反&#x3D;0,0010011\<br>x&#x3D;-19D \quad [x]_原&#x3D;1,0010011\<br>\qquad  [x]_反&#x3D;1,1101100\<br>x&#x3D;+0.75D \quad [x]_原&#x3D;0.1100000\<br>\qquad  [x]_反&#x3D;0.1100000\<br>x&#x3D;-0.75D \quad [x]_原&#x3D;1.1100000\<br>\qquad  [x]_反&#x3D;1.00111111\<br>$$<br>若机器字长n+1位，</p><p><strong>反码整数的表示范围</strong>：$-(2^n-1)\leq x \leq 2^n-1 $。真值0有**+0和-0**两种形式。</p><p><strong>反码小数的表示范围</strong>：$-(1-2^{-n})\leq x \leq 1-2^{-n} $。真值0有**+0和-0**两种形式。</p><h5 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h5><p>若设机器字长为8位，那么计算机会自动完成$mod\ 2^8$的运算，可以通过补码来让加法操作实现减法操作，来节省硬件成本。</p><p>若<strong>符号位为0</strong>（即为正数），则补码与原码相同。</p><p>若<strong>符号位为1</strong>（即为负数），则在反码基础上末位+1<strong>（要考虑进位）</strong>。</p><p>例：<br>$$<br>x&#x3D;+19D \quad [x]_原&#x3D;0,0010011\<br>\qquad  [x]_反&#x3D;0,0010011\<br>\qquad [x]_补&#x3D;0,0010011\<br>x&#x3D;-19D \quad [x]_原&#x3D;1,0010011\<br>\qquad  [x]_反&#x3D;1,1101100\<br>\qquad [x]_补&#x3D;1,1101101\<br>x&#x3D;+0.75D \quad [x]_原&#x3D;0.1100000\<br>\qquad  [x]_反&#x3D;0.1100000\<br>\qquad  [x]_补&#x3D;0.1100000\<br>x&#x3D;-0.75D \quad [x]_原&#x3D;1.1100000\<br>\qquad  [x]_反&#x3D;1.00111111\<br>\qquad  [x]_补&#x3D;1.01000000\<br>$$</p><p><strong>补码的真值0只有一种表示形式</strong></p><p>定点整数补码$[x]_补&#x3D;1,0000000$表示$x&#x3D;-2^7$。</p><p>若机器字长n+1位，</p><p><strong>补码整数的表示范围</strong>：$-2^n\leq x \leq 2^n-1 $。</p><p>定点小数补码$[x]_补&#x3D;1,0000000$表示$x&#x3D;-1$。</p><p><strong>补码小数的表示范围</strong>：$-1\leq x \leq 1-2^{-n} $。</p><h5 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h5><p>移码是补码的基础上将符号位取反即可。<strong>注意：移码只能用于表示整数</strong><br>$$<br>x&#x3D;+19D \quad [x]_原&#x3D;0,0010011\<br>\qquad  [x]_反&#x3D;0,0010011\<br>\qquad [x]_补&#x3D;0,0010011\<br>\qquad [x]_移&#x3D;1,0010011\<br>x&#x3D;-19D \quad [x]_原&#x3D;1,0010011\<br>\qquad  [x]_反&#x3D;1,1101100\<br>\qquad [x]_补&#x3D;1,1101101\<br>\qquad [x]_移&#x3D;0,1101101\<br>$$<br>若机器字长n+1位，</p><p><strong>移码整数的表示范围</strong>：$-2^n\leq x \leq 2^n-1 $（与补码相同）。</p><p>使用移码表示的整数很方便的可以进行对比大小，<strong>移码通常用于表示阶码，不用来表示定点小数</strong>。</p><h3 id="运算方法和运算电路"><a href="#运算方法和运算电路" class="headerlink" title="运算方法和运算电路"></a>运算方法和运算电路</h3><h4 id="基本运算部件"><a href="#基本运算部件" class="headerlink" title="基本运算部件"></a>基本运算部件</h4><h5 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h5><p>全加器（FA，Full Adder）是最基本的加法单元，有加数$A_i$、加数$B_i$与低位传来的进位$C_{i-1}$共三个输入，有本位和$S_i$与向高位进位$C_i$共两个输出。全加器的逻辑表达式如下：</p><p><strong>和表达式</strong>：$S_i&#x3D;A_i⊕B_i⊕C_{i-1}$（$A_i、B_i、C_{i-1}$中有奇数个1时，$S_i&#x3D;1$；否则$S_i&#x3D;0$）</p><p><strong>进位表达式</strong>：$C_i&#x3D;A_iB_i+(A_i⊕B_i)C_{i-1}$</p><p>全加器逻辑结构图：</p><p><img src="https://img-blog.csdnimg.cn/a3789f414d63498eaad52b5f65c5081f.png" alt="2-1"></p><p>逻辑符号：</p><p><img src="https://img-blog.csdnimg.cn/1a49308fbe3b4f70b39956338ff49755.png" alt="2-2"></p><h5 id="n串行进位加法器"><a href="#n串行进位加法器" class="headerlink" title="n串行进位加法器"></a>n串行进位加法器</h5><p>把n各全加器相连可得到<strong>n位加法器</strong>，称为串行进位加法器，如图2-3所示。串行进位又称行波进位，每级进位直接依赖于前一位的进位。</p><p><img src="https://img-blog.csdnimg.cn/dba291f080f0477ab43d3b0ef1c8602d.png" alt="2-3"></p><p>将n位加法器进行封装，则可得到图2-4.</p><p><img src="https://img-blog.csdnimg.cn/02806fa799114d90beba2ccbb7a553aa.png" alt="2-4"></p><p>在串行进位加法器中，依赖前一位的进位导致计算速度取决于进位产生和传递的速度。位数越多，运算速度越慢。</p><h5 id="并行进位加法器"><a href="#并行进位加法器" class="headerlink" title="并行进位加法器"></a>并行进位加法器</h5><p>由于串行进位加法器依赖前一位的进位会导致速度变慢，要解决就可以通过在产生进位时用CLA部件来接受进位信息，从而达到并行进位的效果。</p><p><img src="https://img-blog.csdnimg.cn/bfc14b7d5f514a878a698986e0553c6f.png" alt="2-5"></p><p>由于<strong>所有信息都是同时产生的</strong>，运行速度会比“串行进位加法器”更快。</p><p>并行加法器可以通过串行加法器以下式子来推出：<br>$$<br>C_i&#x3D;A_iB_i+(A_i⊕B_i)C_{i-1}\<br>C_{i-1}&#x3D;A_{i-1}B_{i-1}+(A_{i-1}⊕B_{i-1})C_{i-2}\<br>C_{i-2}&#x3D;A_{i-2}B_{i-2}+(A_{i-2}⊕B_{i-2})C_{i-3}\<br>\dots \<br>C_1&#x3D;A_{1}B_{1}+(A_{1}⊕B_{1})C_{0}<br>$$<br>串行加法器中迟早会从$C_i$中展开到$C_0$。</p><p>根据上方$C_i$就可以等于：<br>$$<br>C_i&#x3D;A_iB_i+(A_i⊕B_i)C_{i-1}（C_{i-1}用上方式子来替代）\<br>C_i&#x3D;A_iB_i+(A_i⊕B_i)(A_{i-1}B_{i-1}+(A_{i-1}⊕B_{i-1})C_{i-2})\<br>C_i&#x3D;A_iB_i+(A_i⊕B_i)(A_{i-1}B_{i-1}+(A_{i-1}⊕B_{i-1})(A_{i-2}B_{i-2}+(A_{i-2}⊕B_{i-2})C_{i-3}))\<br>\dots<br>$$<br>而$A_i、B_i、A_{i-1}、B_{i-1}\dots A_0,B_0$和$C_0$的数据在一开始就已经获取到了，因此就可以无需等算出进位在进行下一步，可以直接根据前方数据来算出相应的进位值。相应的要算越后面的进位则电路设计越复杂，一般实际应用中会算到第4位的进位值即可，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/c066dce603e6461bb6d17f34d7e35610.png" alt="CLA"></p><h5 id="带标志加法器"><a href="#带标志加法器" class="headerlink" title="带标志加法器"></a>带标志加法器</h5><p>无符号数加法器只能用于两个无符号数相加，不能进行带符号整数的加减运算。为了能进行带符号整数的加减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能进行加减运算，还能生成相应的标志信息。</p><p><img src="https://img-blog.csdnimg.cn/dcd0f1066c4a4a4db35da9a739aad185.png" alt="2-6"></p><p>在图2-4的基础上，增加标识位，这样就能实现带标志的加法器图2-6。</p><p>各标志的意义为：</p><ul><li>OF(Overflow Flag)：溢出标志，用于判断<strong>带符号数</strong>加减运算是否溢出。<font color=#FF0000 size=3 face="微软雅黑">OF&#x3D;1 溢出； OF&#x3D;0 未溢出</font></li><li>SF(Sign Flag)：符号标志，用于判断<strong>带符号数</strong>加减运算结果的正负性。<font color=#FF0000 size=3 face="微软雅黑">SF&#x3D;1 结果为负； SF&#x3D;0 结果为正</font></li><li>ZF(Zero Flag)：零标志，用于判断加减运算结果是否为0。<font color=#FF0000 size=3 face="微软雅黑">ZF&#x3D;1 表示结果为0； ZF&#x3D;0 表示结果不为0</font></li><li>CF(Carry Flag)：进位&#x2F;借位标志，用于判断<strong>无符号数</strong>加减运算是否溢出。<font color=#FF0000 size=3 face="微软雅黑">CF&#x3D;1 溢出； CF&#x3D;0 未溢出</font></li></ul><p>各标志的逻辑表达式：</p><ul><li><p>$OF&#x3D;C_n⊕C_{n-1}$——最高位的进位<strong>同或</strong>次高位的进位。反映<strong>带符号数</strong>加减运算是否溢出。</p></li><li><p>$SF&#x3D;S_n$——也就是取运算结果的最高位（符号位）。反映<strong>带符号数</strong>加减运算的正负性。</p></li><li><p>$ZF&#x3D;\overline{S_n+\dots+S_2+S_1}$——仅当运算结果所有bit全0时，ZF才为1，此时表示运算结果为0。</p></li><li><p>$CF&#x3D;C_{out}⊕C_{in}&#x3D;C_n⊕C_0$——反映<strong>无符号数</strong>加减运算是否溢出。</p></li></ul><p>各标志的逻辑图：</p><p><img src="https://img-blog.csdnimg.cn/98323020536b4f4084a127e766bf97e8.png" alt="2-7"></p><h5 id="算数逻辑单元（ALU，Arithmetic-and-Logic-Unit）"><a href="#算数逻辑单元（ALU，Arithmetic-and-Logic-Unit）" class="headerlink" title="算数逻辑单元（ALU，Arithmetic and Logic Unit）"></a>算数逻辑单元（ALU，Arithmetic and Logic Unit）</h5><blockquote><p>ALU是一种功能较强的组合逻辑电路，它能进行多种算数运算和逻辑运算。ALU的核心是带标志加法器，同时也能执行“与” “或” “非”等逻辑运算。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/7a9c6bd57ec744d298aab4c9a195f84f.png" alt="2-8"></p><p>CPU想进行运算时，会通过控制器来解析指令，并根据指令功能发出相应的控制信号。然后运算器会对数据进行处理，此时就会通过ALU来进行运算，因此<strong>ALU是运算器的核心</strong>，而由于加减乘除等运算都基于“加法”来实现，因此<strong>加法器是ALU的核心</strong>。</p><p><img src="https://img-blog.csdnimg.cn/d9bceb66654c427688bda6ebfe11d40a.png" alt="2-9"></p><p>若将图2-9进行封装，不显示细节，并添加几个标志位，可得下图2-10.</p><p><img src="https://img-blog.csdnimg.cn/d1990f91808c46e7a0bd85a4db99f6ef.png" alt="2-10"></p><p><strong>ALU有以下几个需要注意点：</strong></p><ul><li>如果<font size="3" color="#ff0000">ALU支持k种功能</font>，则控制信号位数<font size="3" color="#ff0000">$m\geq [\log_2k]$</font></li><li><font size="3" color="#96CDCD">ALU的运算数、运算结果位数</font>与计算机的<font size="3" color="#96CDCD">机器字长相同</font>。</li><li><font size="3" color="#66CDAA">ZF&#x2F;OF&#x2F;SF&#x2F;CF 标志位</font>，用于表示本次运算结果的特征（ZF表示运算结果是否为零、OF表示有符号数运算结果是否溢出、SF表示有符号数运算结果的正负性、CF表示无符号数运算结果是否溢出）</li><li>这些<font size="3" color="#66CDAA">标志信息通常会倍送入PSW程序状态寄存器中</font></li><li>PSW寄存器也称为<font size="3" color="#66CDAA">“标志寄存器FR(Flag Register)”</font></li><li>Cin是进位输入信号、Cout是进位输出信号（类似于带标志位的加法器）</li></ul><h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><h4 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h4><blockquote><p>算术移位的对象是有<strong>符号数</strong>，在移位过程中符号位保持不变。</p><p>通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。</p></blockquote><h5 id="原码的算数移位"><a href="#原码的算数移位" class="headerlink" title="原码的算数移位"></a>原码的算数移位</h5><p>原码的算数移位：符号位保持不变，仅对数值位进行移位。</p><p><strong>算数右移</strong>：</p><p>高位补0，低位超过小数点部分舍去。若当<strong>舍弃的位$\neq$0</strong>，<font color="\#00CED1">则会丢失精度</font>。</p><p>例：</p><p>$-20D$的用8位二进制表示形式为$1\ 0010100.$，最高位为符号位。</p><p>进行算数右移可得$1\ 0001010.$，十进制为-10D，右移一位相当于：$-20\div 2^1$</p><p><strong>算数左移</strong>：</p><p>低位补0，高位舍弃。若<strong>舍弃的位$\neq$0</strong>，则会出现<font color="#FF6347">严重误差。</font></p><p>例：</p><p>$-20D$的用8位二进制表示形式为$1\ 0010100.$，最高位为符号位。</p><p>进行算数左移可得$1\ 0101000.$，十进制为-40D，右移一位相当于：$-20\times 2^1$。</p><p>若-80D用8位二进制表示$1\ 1010000$，最高位为符号位。</p><p>进行算数左移可得$1\ 0100000$，结果为-32D，出现严重误差。</p><h5 id="反码的算数移位"><a href="#反码的算数移位" class="headerlink" title="反码的算数移位"></a>反码的算数移位</h5><p><strong>正数的反码表示和原码表示相同</strong>，所以正数的移位规则和原码相同。</p><p>反码<font color="#FF6347">负数</font>的数值位与原码相反，因此<font color="#FF6347">负数反码的移位运算</font>规则下：</p><p><strong>算数右移</strong>： 高位补1，低位舍弃。</p><p>高位补1，低位超过小数点部分舍去。若当<strong>舍弃的位&#x3D;0</strong>，<font color="\#00CED1">则会丢失精度</font>。</p><p><strong>算数左移</strong>： 低位补1，高位舍弃。</p><p>低位补1，高位舍弃。若<strong>舍弃的位&#x3D;0</strong>，则会出现<font color="#FF6347">严重误差。</font></p><h5 id="补码的算数移位"><a href="#补码的算数移位" class="headerlink" title="补码的算数移位"></a>补码的算数移位</h5><p><strong>正数的补码表示和原码表示相同</strong>，所以正数的移位规则和原码相同。</p><p><font color="#FF6347">负数</font>补码&#x3D;反码末位+1导致反码最右边几个连续的1都因进位而变0，直到进位碰到第一个0为止。</p><p><font color="#FF6347">规律——负数补码中，最右边的1及其最右边同原码。最右边的1的左边同反码</font></p><p><strong>算数右移（同反码）</strong>：高位补1，低位舍弃。</p><p><strong>算数左移（同原码）</strong>：低位补0，高位舍弃。</p><p>总结可为如下图：</p><p><img src="https://img-blog.csdnimg.cn/67166846fa6547d88ee058f6ec608f53.png" alt="2-11"></p><p><strong>由于位数优先，因此有时候无法用算数移位精确的等效乘除法。</strong></p><p><strong>算数移位的应用举例：</strong></p><p>若要实现$-20 \times 7$ ， 将7D转换为二进制$111B$，原式可变为$-20 \times(2^0+2^1+2^2)$。</p><p>即相当于 不左移+左移1位+左移两位 即可实现。<br>$$<br>-20\times 7 &#x3D; 1\ 0010100+ 1\ 0101000+1\ 1010000&#x3D;-160D<br>$$</p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><blockquote><p>逻辑移位将操作数视为无符号数。</p></blockquote><p>逻辑移位的规则很简单，<strong>逻辑右移时</strong>，高位补0，低位舍弃。<strong>逻辑左移时</strong>，低位补0，高位舍弃。</p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><blockquote><p>循环移位是分带进位标志位CF的循环移位（大循环）和不带进位标志位的循环移位（小循环）。</p></blockquote><p>循环移位的特点是，移出的数位又移入到数据中，而是<strong>否带进位则要看是否将进位标志位加入循环位移</strong>。</p><p><img src="https://img-blog.csdnimg.cn/c3d301b9e3a445629e3e33eb2feca077.png" alt="2-12"></p><h3 id="定点数的加减运算"><a href="#定点数的加减运算" class="headerlink" title="定点数的加减运算"></a>定点数的加减运算</h3><blockquote><p>在计算机内部中并没有小数点，只是人为约定了小数点的位置，小数点约定在最左边就是定点小数，小数点约定在最右边就是定点整数。因此在运算过程中只需关心符号位和数值位即可。</p></blockquote><h4 id="原码的加减运算"><a href="#原码的加减运算" class="headerlink" title="原码的加减运算"></a>原码的加减运算</h4><p>在原码加法中，若直接用加法器对其原码进行加法运算可能出错，如$14D&#x3D;0001110$和$-14D&#x3D;1001110$的二进制进行相加，结果为$10011100$，显然结果不正确。所以要用其他方法实现。</p><p>则可以归纳出原码的加法运算：</p><p>正+正 -&gt; 绝对值做加法，结果为正（结果可能溢出）</p><p>负+负 -&gt; 绝对值做加法，结果为负（结果可能溢出）</p><p>正+负 -&gt; 绝对值大的减绝对值小的，符号同绝对值大的数</p><p>负+正 -&gt; 绝对值大的减绝对值小的，符号同绝对值大的数</p><p>而原码的减法运算只需将“减数”的符号取反，即可转变为相应的加法运算。</p><h4 id="补码的加减运算"><a href="#补码的加减运算" class="headerlink" title="补码的加减运算"></a>补码的加减运算</h4><p>由于原码想用电子器件实现过于复杂，所以计算机中一般适用补码来进行加减运算。</p><p><strong>补码的加法运算</strong>：将符号位一同参与运算，即可得出相应的补码。</p><p>例：设机器字长为8位（含1位符号位），A&#x3D;15，B&#x3D;-24，则：<br>$$<br>[A+B]_补&#x3D;0,0001111+1,11010000&#x3D;1,1110111<br>$$<br>A+B的原码为10001001，真值为-9与十进制加法结果一致。</p><p><strong>补码的减法运算只需把负号看成被减数的符号数即可转变为加法运算</strong>。</p><h5 id="补码溢出判别方法"><a href="#补码溢出判别方法" class="headerlink" title="补码溢出判别方法"></a>补码溢出判别方法</h5><p>补码仅当在“正数+正数”才会<strong>上溢</strong>——正+正&#x3D;负，“负数+负数”才会<strong>下溢</strong>——负+负&#x3D;正</p><p>计算机来判断补码溢出方法有三种：</p><ol><li><p><strong>采用一位符号位</strong></p><p>设A的符号为$A_S$，B的符号为$B_S$，运算结果的符号为$S_S$，则溢出表达式为<br>$$<br>V&#x3D;A_SB_S\overline{S_S}+\overline{A_S} \overline{B_S}S_S<br>$$<br>若V&#x3D;0，表示无溢出；</p><p>若V&#x3D;1，表示有溢出。</p></li><li><p><strong>采用一位符号位</strong>，根据数据位进位情况判断溢出符号位的进位$C_s$，最高数值位的进位$C_1$。</p><p>当$C_s&#x3D;0,C_1&#x3D;1$时，就发生了上溢。</p><p>当$C_s&#x3D;1,C_1&#x3D;0$时，就发生了下溢。</p><p><strong>即当$C_s$和$C_1$不同时就有溢出</strong>，此时逻辑表达式为$V&#x3D;C_s⊕C_1$，若V&#x3D;0，表示无溢出；V&#x3D;1，表示有溢出。</p></li><li><p><strong>采用双符号位</strong></p><p>正数符号为00，负数符号为11</p><p>例：设机器字长8位（含1位符号位），A&#x3D;15，B&#x3D;-24，C&#x3D;124</p><p>$[A+C]_补&#x3D;00,0001111+00,1111100&#x3D;01,0001011$，结果真值-117</p><p>$[B-C]_补&#x3D;11,1101000+11,0000100&#x3D;10,1101100$，结果真值+108</p><p>记两个符号位为$S_{s1},S_{s2}$，则情况如下：</p><ol><li>$S_{s1}S_{s2}&#x3D;00$：表示结果为正数，无溢出。</li><li>$S_{s1}S_{s2}&#x3D;01$：表示结果上溢，正溢出。</li><li>$S_{s1}S_{s2}&#x3D;10$：表示结果下溢，负溢出。</li><li>$S_{s1}S_{s2}&#x3D;11$：表示结果为负数，无溢出。</li></ol><p>溢出逻辑判断表达式为$V&#x3D;S_{s1}⊕S_{s2}$，若V&#x3D;0，表示无溢出；V&#x3D;1，表示有溢出。</p></li></ol><p><strong>双符号位补码又称：模4补码（实际存储时只存储1个符号位，运算时会复制一个符号位），单符号位补码又称：模2补码</strong></p><h4 id="补码加减运算电路"><a href="#补码加减运算电路" class="headerlink" title="补码加减运算电路"></a>补码加减运算电路</h4><p><img src="https://img-blog.csdnimg.cn/903d1050f0f14cb096e3a4076988972e.png" alt="2-13"></p><p>根据图2-13，设这为4位加法器（最高位为符号位）被加数$X&#x3D;0011B$，加数$Y&#x3D;0100B$，此时加数为正，所以多路选择器的$Sub&#x3D;0$，A和B会直接进行运算，最后加和结果为$0111B$会通过最上方的线直接输出。</p><p>若进行减法运算，此时多路选择器$Sub&#x3D;1$，由于Cin和Sub相连，当$Sub&#x3D;1$时，$Cin&#x3D;1$，就实现了把原码变为补码的步骤。</p><h4 id="无符号数的加减运算"><a href="#无符号数的加减运算" class="headerlink" title="无符号数的加减运算"></a>无符号数的加减运算</h4><p>无符号整数的<strong>加法</strong>：从最低位开始，<strong>按位相加</strong>，并往更高位<strong>进位</strong>。</p><p>由于n位寄存器自动实现$mod2^n$，假设要算$B-A$所以$A+A_反+1&#x3D;2^n$，可以将A等价为$A_反+1$，然后$B-A&#x3D;B+A_反+1$，必会产生高位进1，导致溢出，从而根据$mod2^n$，从而可将减法变为加法运算。</p><p>无符号整数的<strong>减法</strong>：</p><ol><li>“被减数”不变，<strong>“减数”全部位按位取反（可以获得减数的补数）</strong>、末位+1，减法变加法</li><li>从最低位开始，按位相加，并往更高位进位</li></ol><h5 id="无符号数加法-x2F-减法溢出判断"><a href="#无符号数加法-x2F-减法溢出判断" class="headerlink" title="无符号数加法&#x2F;减法溢出判断"></a>无符号数加法&#x2F;减法溢出判断</h5><p>n bit无符号整数表示范围$0~2^n-1$，超出此范围则溢出。</p><p>计算机判断溢出方法：</p><ul><li>无符号<strong>加法</strong>的溢出判断：最高位产生进位&#x3D;1时，发生溢出，否则未溢出。</li><li>无符号<strong>减法</strong>的溢出判断：减法变加法，最高位产生的进位&#x3D;0时，发生溢出，否则未溢出</li></ul><h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><h4 id="原码的乘法运算"><a href="#原码的乘法运算" class="headerlink" title="原码的乘法运算"></a>原码的乘法运算</h4><p>乘法运算可以通过累加和右移的操作来实现。</p><p><strong>手算二进制乘法：</strong>手算二进制乘法和十进制的乘法如出一辙，根据十进制乘法相乘并错位相加即可。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/4b192c2499d84f308418b778bbc89e14.png" alt="2-14"></p><p>而拆分为2进制的运算，各位相乘并相加可得：<br>$$<br>0.1011&#x3D;1\times 2^{-1} +0\times 2^{-2}+1\times 2^{-3}+1\times 2^{-4}\<br>0.1101&#x3D;1101\times 2^{-4}(小数点左移四位)\<br>即:0.1101\times 0.1011 &#x3D;(1101\times 1\times 2^{-8})+(1101\times 1 \times 2^{-7})+(1101\times 0 \times 2^{-6})+(1101\times 1\times 2^{-5})<br>$$</p><p>若考虑用机器实现则有以下几个问题需要思考：</p><ul><li>实际数字有正负，符号位如何处理？</li><li>乘积的位数扩大一倍，如何处理？</li><li>4个位积都要保存下来最后统一相加？</li></ul><p>由上面的问题我们就可以引出定点数的乘法运算：</p><h5 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h5><p>原码一位乘法的特点是<strong>符号位与数值位是分开计算</strong>，乘积符号由两个数的符号位“异或”形成，而乘积的数值部分则是两个数的绝对值相乘之积。</p><p>设$[x]_原&#x3D;x_sx_1x_2\dots x_n,[y]_原&#x3D;y_sy_1y_2\dots y_n$，运算规则如下：</p><ol><li>被乘数 x 和乘数 y 均<strong>取绝对值</strong>参与yu你算，看作无符号数，符号位$x_s⊕y_s$。</li><li><strong>部分积</strong>是乘法过程的中间结果。乘数每一位$y_i$乘以被乘数得$X\times y_i$后，将该结果与前面所得的结果累加，就是部分积，初值为0。</li><li>从乘数的最低为$y_n$开始判断：**若$y_n&#x3D;1$<strong>，则部分积加上被乘数x，然后右移一位；</strong>若$y_n&#x3D;0$**，则部分积加上0，然后右移一位。</li><li>重复步骤 3 ，判断n次。</li></ol><p>例：</p><p>设机器字长位n+1&#x3D;5（含一位符号位），$[x]_原&#x3D;1.1101,[y]_原&#x3D;0.1011$，采用原码一位乘法求xy。</p><p>符号位进行单独处理，此时**符号位&#x3D;$x_s⊕y_s$**，而将x和y的数值位取绝对值，将被乘数x放入X（通用操作数寄存器）中，将乘数y放入MQ（乘商寄存器）中，并将ACC（累加器）清零，可得如下图2-15。</p><p><img src="https://img-blog.csdnimg.cn/7e921a4adcc74cd48968b655a1828ab8.png" alt="2-15"></p><p>此时会先从01011（乘数）的最低位开始计算，若<strong>最低位&#x3D;1</strong>，则ACC中会加上01101（被乘数），若<strong>最低位&#x3D;0</strong>，则ACC加上0（即什么都不加）。</p><p>显然此时为1，因此ACC中会变乘01101，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/d51b51267a4346a9b010aa8a82bd1d55.png" alt="2-16"></p><p>此时要算第二个位积，因为算第二个位积和第一位位积会产生一个错位，就可以通过ACC和MQ同时逻辑右移1位实现。高位补0，超过范围的最低位则直接丢弃，如下图。</p><p><img src="https://img-blog.csdnimg.cn/613d706ed16e4e469ca7e1fd06f0a544.png" alt="2-17"></p><p>然后反复重复上方步骤，可得最终结果：</p><p><img src="https://img-blog.csdnimg.cn/147c3f18fd204c7899e302a14ff36032.png" alt="2-18"></p><p>结果为$0.10001111$，与手算的结果一致，最后再加上符号位就为$-0.10001111$</p><h4 id="补码的一位乘法（booth-算法）"><a href="#补码的一位乘法（booth-算法）" class="headerlink" title="补码的一位乘法（booth 算法）"></a>补码的一位乘法（booth 算法）</h4><p>设$[x]_补&#x3D;x_sx_1x_2\dots x_n,[y]_补&#x3D;y_sy_1y_2\dots y_n$，运算规则如下：</p><ol><li>符号位参与运算，运算的数均以补码表示。</li><li>被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数取单符号位。</li><li>乘数末位增设附加位$y_{n+1}$，初值为0.</li><li>根据$(y_n,y_{n+1})$的取值来确定操作。</li><li>移位按补码右移规则进行。</li><li>按照上述规则进行n+1步操作，但第n+1步不再移位（进行n+1次累加和n次右移），仅根据$y_n$与$y_{n+1}$的比较结果做相应的运算。</li></ol><p>可归纳为：</p><p>进行n轮加法、移位，最后再多来一次加法，每次**加法可能$+0、+[x]_补、+[-x]_补$ **，最终加什么是根据当前MQ中的最低位（乘数y的最低位）、辅助位来确定加什么。</p><ul><li>辅助位 - MQ中最低位 &#x3D; 1 时， <strong>(ACC) + $[x]_补$</strong></li><li>辅助位 - MQ中最低位 &#x3D; 0 时， <strong>(ACC) + 0</strong></li><li>辅助位 - MQ中最低位 &#x3D; -1 时， <strong>(ACC) + $[-x]_补$</strong></li></ul><p>且每次右移的规则是<strong>补码的算数右移</strong>，并且<strong>符号位参与运算</strong>。</p><p>设机器字长为5位（含1位符号位，n&#x3D;4），$x&#x3D;-0.1101,y&#x3D;+0.1011,[x]_补&#x3D;1.0011,[y]_补&#x3D;0.1011$，将x和y的补码放入运算器中，如下图：</p><p><img src="https://img-blog.csdnimg.cn/99a51015caad402aafc6c0be8836cdf2.png" alt="2-19"></p><p>由图可得除了MQ中均有双符号位参与运算。</p><p><img src="https://img-blog.csdnimg.cn/9ecb0c31eb794742aeaee825248ab645.png" alt="2-20"></p><p>在图中加和值都会存到ACC中，然后ACC和MQ每次加完会统一进行算术右移。</p><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="符号拓展"><a href="#符号拓展" class="headerlink" title="符号拓展"></a>符号拓展</h5><blockquote><p>在算数运算中，有时必须把带符号的定点数转换成具有不同位数的表示形式。例如，某个程序要将8位整数与32位整数相加，要想得到正确的结果，在8位和32位整数相加之前，必须将8位转换成32位整数形式，这称为“符号拓展”。</p></blockquote><h5 id="正数的符号扩展"><a href="#正数的符号扩展" class="headerlink" title="正数的符号扩展"></a>正数的符号扩展</h5><p>正数的符号扩展非常简单，即符号位不变，新表示形式的所有扩展位都用0进行填充。</p><h5 id="负数的符号扩展"><a href="#负数的符号扩展" class="headerlink" title="负数的符号扩展"></a>负数的符号扩展</h5><p>原码表示的负数的符号拓展与正数相同，只不过此时符号位为1。</p><p><strong>补码表示负数</strong>的符号拓展方法：<strong>新表示的所有附加位都用1（对于正数）或0（对于小数）进行补充</strong>。</p><h5 id="手算除法（二进制）"><a href="#手算除法（二进制）" class="headerlink" title="手算除法（二进制）"></a>手算除法（二进制）</h5><p>设机器字长为5位（含1位符号位，n&#x3D;4），$x&#x3D;0.1011,y&#x3D;0.1101$求x&#x2F;y。</p><p>模仿十进制除法规则，可得二进制除法：</p><p><img src="https://img-blog.csdnimg.cn/9282371b98d1474793397af240453fc9.png" alt="2-21"></p><p>最后算出的余数由于先前右移了4位所以要再左移4位，即为$0.00000111$，结果就为$x&#x2F;y&#x3D;0.1101$，余数$0.00000111$</p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><p><strong>对于原码的正负性会单独用异或运算来进行处理，即$x_s⊕y_s$，数值位取绝对值进行除法计算。</strong></p><p>设机器字长为5位（含1位符号位，n&#x3D;4），$x&#x3D;0.1011,y&#x3D;0.1101$求x&#x2F;y。</p><p>此时$|x|&#x3D;0.1011,|y|&#x3D;0.1101,[|y|]_补&#x3D;0.1101,[-|y|]_补&#x3D;1.0011$，将x，y放入运算器中：</p><p><img src="https://img-blog.csdnimg.cn/bbea071c1d734f2ba9eaf12a106d2d60.png" alt="2-22"></p><p>由于计算机并不直到除数和被除数谁更大，所以规定<strong>默认先上商1，如果搞错了再改上商0，并“恢复余数”（恢复余数通过加上除数y来进行恢复）</strong></p><p><img src="https://img-blog.csdnimg.cn/14dfbf2a7f5d4ec0895d10e8072556fa.png" alt="2-23"></p><p>第一次运算 ACC-除数（通用寄存器）-&gt; $|x|+[-|y|]_补&#x3D;01011+10011&#x3D;11110$，此时计算结果为负数，说明上商1为错误，所以需要恢复余数再重新该上商0.</p><p><img src="https://img-blog.csdnimg.cn/e3496bb503d14c58909874f382ae4032.png" alt="2-24"></p><p>此时图2-24就为商错，需要恢复余数后再重新商0.</p><p><img src="https://img-blog.csdnimg.cn/f0a11fcfacce4f709c6556b4b6a0b63d.png" alt="2-25"></p><p>由于余进行下一步运算要错位，所以ACC可以通过逻辑左移实现错位的功能，即将MQ的最高位移至ACC的最低位。</p><p><img src="https://img-blog.csdnimg.cn/fa82b45a382b4928959b789200d49f5a.png" alt="2-26"></p><p>进行下一次运算计算机还是会默认商1，若商错再恢复余数商0，如此循环可得到最终结果和余数：</p><p><img src="https://img-blog.csdnimg.cn/59e5ca2e75ff43d1ac6d5ab4e0c25532.png" alt="2-27"></p><p>此时MQ中就存放着商的结果，ACC中则存放着余数，与手算结果一致。</p><h5 id="手算实现恢复余数法"><a href="#手算实现恢复余数法" class="headerlink" title="手算实现恢复余数法"></a>手算实现恢复余数法</h5><p><img src="https://img-blog.csdnimg.cn/caca2dc07db243019c7f0e824a13a7dd.png" alt="2-28"></p><p>模仿计算机每次都先商1，若商错则通过$+[|y|]_补$恢复余数后再商0，如此往复可得到最终结果。</p><h5 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h5><p>在恢复余数法的基础上，若商1为负时，可以通过直接将<strong>余左移一位，加上$[|y|]_补$可以直接实现得到恢复余数后的结果</strong>。<strong>符号位同样通过异或单独确定</strong>，即$x_s⊕y_s$。</p><p><img src="https://img-blog.csdnimg.cn/26825a4b9d784e45be0dd72a2e64c25d.png" alt="2-29"></p><p><strong>注：当最后一步余数为负时，需要商0，再加上$[|y|]_补$后才能获得正确余数</strong></p><h4 id="补码的除法运算"><a href="#补码的除法运算" class="headerlink" title="补码的除法运算"></a>补码的除法运算</h4><p>补码的除法运算主要以加减交替法为主，因此和原码的加减交替法会有很多相似的地方。</p><p>补码除法的特点是：</p><ul><li>符号位与数值位一起参加运算，商符自然形成。补码的被除数、余数、除数回采用双符号位。</li><li>若<strong>被除数与除数同号</strong>，商<strong>1</strong>，<strong>余数左移一位减去除数</strong></li><li>若<strong>被除数与除数异号</strong>，商<strong>0</strong>，<strong>余数左移一位加上除数</strong></li></ul><p>例：</p><p>设机器字长为5位（含1位符号位，n&#x3D;4），$x&#x3D;+0.1000,y&#x3D;-0.1011$，采用补码加减交替法求x&#x2F;y，$[x]_补&#x3D;00.1000,[y]_补&#x3D;11.0101,[-y]_补&#x3D;00.1011$。</p><p><img src="https://img-blog.csdnimg.cn/140acfa24dc24a39a46a1f68fb5cf08e.png" alt="2-30"></p><p><strong>注：若对商的精度没有特殊要求，则一般采用“末位商恒置1”</strong></p><h3 id="C语言中整数类型及类型转换"><a href="#C语言中整数类型及类型转换" class="headerlink" title="C语言中整数类型及类型转换"></a>C语言中整数类型及类型转换</h3><p><strong>注：C语言中定点整数都是用“补码”的形式进行存储</strong></p><p>C语言中用<code>unsigned</code>关键字来修饰就代表是无符号类型。</p><p>先观察以下代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">short</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span><span class="token comment">//short型占用2个字节</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span> <span class="token comment">//赋值会带符号位一起赋值给y。</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">165537</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">34991</span><span class="token punctuation">;</span><span class="token comment">//int型占用4个字节</span>    <span class="token keyword">short</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>a<span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token comment">//short型占用2个字节  将长整数变短整数会高位截断，保留低位。</span>        <span class="token keyword">short</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">//将短整形转长整形是直接符号拓展，若符号位1则全补1，符号位为0则全补0</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> p <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="数据的“大小端模式”"><a href="#数据的“大小端模式”" class="headerlink" title="数据的“大小端模式”"></a>数据的“大小端模式”</h4><blockquote><p>在存储数据时，数据从低位到高位可以按从左往右排列，也可以按从右往左排列。因此，无法用最左和最右来表示数据的最高位和最低为，通常用<strong>最低有效字节（LSB）和最高有效字节（MSB）来表示数的低位和高位</strong>。例如，在32位计算机中，一个int型变量 i 的机器数位 01 23 45 67H，其最高有效字节MSB &#x3D; 01H， 最低有效字节 LSB &#x3D; 67H。</p></blockquote><p>多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种排列方式： 大端方式（big endian）、小端方式（little endian）。</p><p>假设存4字节int: 01 23 45 67 H，</p><p><img src="https://img-blog.csdnimg.cn/dd269471b4a04c30b0452d013cd0977f.png" alt="2-31"></p><p><strong>大端模式</strong>是按从<strong>最高有效字节到最低有效字节</strong>的顺序存储数据，即最高有效字节放在前面；</p><p><strong>小端方式</strong>是按从<strong>最低有效字节到最高有效字节</strong>的顺序存储数据，即最低有效字节放在前面；</p><h4 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h4><p>现代计算机通常按字节编址，即每个字节对应1个地址</p><p>通常也支持按字、按半字和字寻址。假设存储字长为32位，则1个字 &#x3D; 32bit，半字 &#x3D; 16 bit。每次访存只能读&#x2F;写1个字。</p><p><img src="https://img-blog.csdnimg.cn/95429b73308a43f297c2b4e7bbe056d8.png" alt="2-32"></p><p><strong>边界对齐就是用空间换时间的一种存储方式</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 数制与编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数电-门电路</title>
      <link href="/2023/11/04/shu-dian-men-dian-lu/"/>
      <url>/2023/11/04/shu-dian-men-dian-lu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="门电路（Gate-Circuit）"><a href="#门电路（Gate-Circuit）" class="headerlink" title="门电路（Gate Circuit）"></a>门电路（Gate Circuit）</h4><p>门电路是指以实现基本逻辑关系和复合逻辑关系的电子电路。</p><h5 id="高电平和低电平的含义"><a href="#高电平和低电平的含义" class="headerlink" title="高电平和低电平的含义"></a>高电平和低电平的含义</h5><p>高电平和低电平为某规定范围（由门电路的种类决定）的电位值，而非一固定值。</p><p><img src="https://img-blog.csdnimg.cn/72a394d94cb343d5ac32675166318806.png" alt="1-1"></p><p>若无特殊声明，在日常生活中均以正逻辑体制来表示高低电平。</p><h3 id="二极管的开关特性"><a href="#二极管的开关特性" class="headerlink" title="二极管的开关特性"></a>二极管的开关特性</h3><h4 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h4><p><strong>导体基本概念：</strong></p><p>导体：自然界中容易导电的物质。</p><p>绝缘体：电阻率很高的物质，几乎不导电。</p><p>半导体：导电特性处于导体和绝缘体之间的物质。</p><p>现代电子学中，用的最多的半导体是硅和锗，最外层电子（价电子）都是4个。</p><p>本征半导体：完全纯净的、结构完整的半导体晶体。</p><blockquote><p>在硅和锗晶体中，原子按四角形系统组成晶体点阵，每个原子都处在正四面体的中心，而四个其他原子位于四面体的顶点，每个原子与其相邻的原子之间形成<strong>共价键</strong>，共用一对价电子。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c583473eaf5445fcb352a2b1d3885aa8.png" alt="1-2"></p><blockquote><p>共价键中的两个电子被紧紧束缚在共价键中，称为束缚电子，常温下束缚电子很难脱离共价键成为自由电子，因此本征半导体中的自由电子很少，导电能力很弱。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4640ca406f0647a5a1b5777e4c09b2b6.png" alt="1-3"></p><h5 id="本征半导体的导电机理"><a href="#本征半导体的导电机理" class="headerlink" title="本征半导体的导电机理"></a>本征半导体的导电机理</h5><ol><li><p>载流子、自由电子和空穴</p><p>在绝对0度（T&#x3D;0K）和没有外界激发时，价电子完全被共价键束缚着，本征半导体中没有可以运动的带点粒子（即<strong>载流子</strong>），它的导电能力为0，相当于绝缘体。</p><p>在常温下，由于热激发（<strong>本征激发</strong>），使一些价电子获得足够的能量而脱离共价键的束缚，成为<strong>自由电子</strong>，同时共价键上留下一个空位，称为<strong>空穴</strong>。</p><p><img src="https://img-blog.csdnimg.cn/55b0a895f5d6452eb265b42a091ed1fa.png" alt="1-4"></p></li><li><p>导电机理</p><p>本征半导体中存在数量相等的两种载流子，即自由电子和空穴。</p><p>本征半导体中电流由两部分组成：</p><ol><li>自由电子移动产生的电流。</li><li>空穴移动产生的电流。</li></ol><blockquote><p>温度越高，载流子的浓度越高。因此本征半导体的导电能力越强，温度使影响半导体性能的一个重要的外部因素，这是半导体的一大特点—<strong>温敏特性</strong>。</p></blockquote><p>本征半导体的导电能力取决于载流子的浓度。</p></li></ol><h4 id="N型、P型半导体"><a href="#N型、P型半导体" class="headerlink" title="N型、P型半导体"></a>N型、P型半导体</h4><p>在本征半导体中掺入微量的杂质（某种元素），形成杂志半导体—<strong>掺杂特性</strong>。</p><p>掺杂后自由电子数目大量增加，自由电子导电称为这种半导体的主要导电方式，称为电子半导体或<strong>N型半导体</strong>。</p><p>在N型半导体中<strong>自由电子是多数载流子，空穴是少数载流子</strong>。</p><p>而掺杂后空穴数目大量增加就称为空穴半导体或<strong>P型半导体</strong>。</p><p>在P型半导体中<strong>空穴是多数载流子，自由电子是少数载流子</strong>。</p><p><strong>无论N型和P型半导体都是中性的，对外不显电性。</strong></p><p>将PN结与管壳和引线所结合就形成了二极管，符号如图1-5所示。</p><p><img src="https://img-blog.csdnimg.cn/75d40811160b4542b08adb99641d13bb.png" alt="1-5"></p><h4 id="二极管的静态开关特性"><a href="#二极管的静态开关特性" class="headerlink" title="二极管的静态开关特性"></a>二极管的静态开关特性</h4><p><img src="https://img-blog.csdnimg.cn/50c8a902cef24716af4461527647f282.png" alt="1-6"></p><p><img src="https://img-blog.csdnimg.cn/69be8a2abe5749fcbc6f9e1855fbe1fb.png" alt="1-7"></p><p>当输入电流为低电平时，二极管反向截至，相当于开关断开。而输入电流为高电平时，二极管正向导通，可等效于具有0.7V压降的闭合开关（相当于越过0.7V死区电压）。</p><h3 id="MOS管的开关特性"><a href="#MOS管的开关特性" class="headerlink" title="MOS管的开关特性"></a>MOS管的开关特性</h3><p>场效应晶体管只有一个载流子（多数载流子）参与导电，又称为单极型三极管。场效应晶体管是利用<strong>电场（电压）控制</strong>半导体中载流子运动的一种有源器件。目前场效应管应用最多是以二氧化硅作为绝缘介质的金属—氧化物—半导体绝缘栅型场效应管（Metal-Oxide-Semiconductor-Field-Effect Transistor），简称MOS管。</p>]]></content>
      
      
      <categories>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-排序</title>
      <link href="/2023/11/03/shu-ju-jie-gou-pai-xu/"/>
      <url>/2023/11/03/shu-ju-jie-gou-pai-xu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><p>排序算法的稳定性：若进行排序算法后，关键字相同的元素在排序之后相对位置保持不变，就称算法是稳定的，反之为不稳定。</p><p><img src="https://img-blog.csdnimg.cn/b6dac648225d4117a08aae43cf3ecc8b.png" alt="1-1"></p><p>如图1-1，若3的元素相对位置发生改变即为不稳定。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的基本思想是每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部插入完成。</p><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>直接插入排序算法就是，就是一个个从左往右比较大小，将大的放在后面，小的放在前面。</p><p>算法实现代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>temp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//若后一位小于前一位则交换位置</span>            temp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token comment">//检查排好序中是否有更大的数</span>                A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>直接插入排序的空间复杂度为O(1)，最坏情况下时间复杂度为$O(n^2)$。</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>由于结构是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可同一地向后移动元素。</p><p>代码实现：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//该算法空出A[0]作为哨兵，A[0]不存放元素</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//一次将A[2]~A[n]插入前面的已排序序列</span>        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将要排序的元素暂存到A[0]</span>        low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//设置折半查找的范围</span>        high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span><span class="token comment">//默认递增，从i后的数进行排序</span>        <span class="token comment">//折半查找核心代码，仅当low小于high时进行循环</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//取中间点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//在左半边查找</span>                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment">//在右半边查找</span>                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//统一后移元素，空出插入位置</span>            <span class="token punctuation">&#125;</span>            A<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//插入操作</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>当low&gt;high时，折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]赋值到low所指位置。当A[mid]&#x3D;&#x3D;A[0]时，为了保证算法的”稳定性”，应继续在mid所指位置右边寻找插入位置。</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序的基本思想是：先将待排序表分割成若干形如$L[i,i+d,i+2,\dots,i+kd]$的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已经是“基本有序”时，再对全体记录进行一次直接插入排序。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/75c0fd11c0274597bf3a5ddabc3ef111.png" alt="1-2"></p><p>若想将图1-2进行排序，设第一趟的，$d_1&#x3D;n&#x2F;2&#x3D;4$（n为表长，0不算做元素，为暂存单元）。则可将相离为$d_1&#x3D;4$的看为同一个子表，即49和76为同一子表，38和13为同一子表，65和27为同一子表，97和49为同一子表。</p><p><img src="https://img-blog.csdnimg.cn/b7b540a8b89449e08b74b87374ee429e.png" alt="1-3"></p><p>然后再对各个子表进行字节插入排序，可得图1-4：</p><p><img src="https://img-blog.csdnimg.cn/d620be4cb6234a3a939013cfab84d575.png" alt="1-4"></p><p>最后再放回原先表中。</p><p><img src="https://img-blog.csdnimg.cn/9dc192f5b977493f8e45913f2b09fab9.png" alt="1-5"></p><p>再进行第二趟的处理，在原先基础上$d_2&#x3D;d_1&#x2F;2&#x3D;4&#x2F;2&#x3D;2$，第二趟每个元素相隔2个元素，即49、27、76、65为同一子表，13、49、38、97为同一子表。然后再对子表进行直接插入排序，排序后可得图1-6。</p><p><img src="https://img-blog.csdnimg.cn/ba06cdd5ce2f4205b16b4ce854624cf9.png" alt="1-6"></p><p>后再放回原表中。</p><p><img src="https://img-blog.csdnimg.cn/5b1fcc0097ee437889e91a46ebe21521.png" alt="1-7"></p><p>再进行第三趟，此时$d_3&#x3D;d_2&#x2F;2&#x3D;1$，则每个元素间隔为1为一个子表，显然就是无序再拆分表，而直接对整个表进行直接插入排序。</p><p><img src="https://img-blog.csdnimg.cn/1126f27c142f48b8a59ca5480daacee4.png" alt="1-8"></p><p>最后就成功获得一个全局有序的递增排序的表。</p><p><strong>希尔排序代码实现</strong>：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> dk<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token comment">//dk为增量</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>dk<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>dk<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>dk<span class="token operator">=</span>dk<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//假设dk=n/2为每次的缩小增量</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>dk<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span>dk<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//将A[i]插入到有序增量子表中</span>                A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//暂存再A[0]</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>dk<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">-=</span>dk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//记录后移，查找插入的位置</span>                <span class="token punctuation">&#125;</span>                A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//插入</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>希尔排序算法性能分析</strong>：</p><p>空间效率：仅使用了常数个辅助单元，空间复杂度为O(1)。</p><p>时间效率：当n在某个特定范围内，希尔排序的时间复杂度约为$O(n^{1.3})$。在最坏情况下希尔排序的时间复杂度为$O(n^2)$。</p><p>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变他们之间的相对次序，因此希尔排序是一种不稳定排序方法。</p><p>适用性：希尔排序算法仅适用于线性表为顺序存储的情况。</p><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序的基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换他们，直到排序比较完。称这样过程为“一趟”冒泡排序。</p><p><strong>冒泡排序算法实现：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        bool flag <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token comment">//表示本趟冒泡是否发生交换的标志</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//一趟冒泡过程</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//若后值比前置小，则交换</span>                ElemType temp <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                flag <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span>false<span class="token punctuation">)</span><span class="token comment">//若没有进行交换，则说明表已经有序</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>冒泡排序性能分析</strong>：</p><p>空间复杂度：O(1)。</p><p>时间复杂度：在最坏情况下（所有值都为逆序）则需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较。则<br>$$<br>比较次数&#x3D;\sum^{n-1}<em>{i&#x3D;1}(n-i)&#x3D;\frac{n(n-1)}{2}，移动次数&#x3D;\sum^{n-1}</em>{i&#x3D;1}3(n-i)&#x3D;\frac{3n(n-1)}{2}<br>$$<br>因此，最坏时间复杂度为$O(n^2)$，平均时间复杂度为$O(n^2)$ .</p><p>稳定性：由于i&gt;j且A[i]&#x3D;A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序方法。</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序的基本思想是基于分治法：在待排序表$L[1\dots n]$中任取一个元素pivot作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分$L[1\dots k-1]$和$L[k+1\dots n]$，使得$L[1\dots k-1]$中的所有元素小于pivot，$L[k+1\dots n]$中的所有元素大于或等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次划分。然后重复上述过程，直至每部分内只有一个元素或空为止。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/8d5bede523df42df92e7e4326207cba4.png" alt="2-1"></p><p>在图2-1中，将49设为枢轴，要将其他小于49的放在49的左半部分，大于的放在49的右半部分，从而完成一次划分。</p><p><img src="https://img-blog.csdnimg.cn/895fac2429fa43598d08ceb6a8a6a45c.png" alt="2-2"></p><p>通过low和high指针来进行，保证high指针的右边都是大于等于枢轴49的值，low指针左边都是小于枢轴49的值。</p><p>此时high指针所指元素为49，等于枢轴元素，所以high指针往左移，移到27。</p><p><img src="https://img-blog.csdnimg.cn/ca9db0246f1a443494dd2687dab70340.png" alt="2-3"></p><p>而27要小于枢轴元素49，则需要放在low所指为止，即0为27，且low指针往右移。</p><p><img src="https://img-blog.csdnimg.cn/760b56f8610541549a6a947fe511f272.png" alt="2-4"></p><p>显然此时low所指元素38也小于基准元素49，则low指针再次右移，到指向65的元素，而65要大于基准元素49，则需放到high所指位置（即6），后high指针向左移。</p><p><img src="https://img-blog.csdnimg.cn/1d3611c62aac47c982b03459e5422eb2.png" alt="2-5"></p><p>此时high所指元素13要小于基准49，则放到low所指位置，然后low指针右移。</p><p><img src="https://img-blog.csdnimg.cn/71c4936156734629999aa3dadf3f4fee.png" alt="2-6"></p><p>而low所指元素97要大于基准49，需将97放到high所指位置，后high左移到76元素位置，而76元素也大于49，则high指针继续左移。</p><p><img src="https://img-blog.csdnimg.cn/bba1a596b9f34f36a38278df9420a56b.png" alt="2-7"></p><p>当low&#x3D;high时，说明元素已经排序完成，可以将基准元素49放到low所指的位置。此时就完成了一次划分。接下来就是对左子表和右子表进行划分，过程基本相同，就不再过多赘述。</p><p><strong>快速排序代码实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//递归结束条件</span>        <span class="token keyword">int</span> pivotpos <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Partition()就是划分操作，将表A划分为满足上述条件的两个子表</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>pivotpos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//依次对两个子表进行递归排序</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>pivotpos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//一趟划分</span>    ElemType pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将当前表中第一个元素设置为枢轴，对表进行划分</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//循环跳出条件</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">>=</span>pivot<span class="token punctuation">)</span> <span class="token operator">--</span>high<span class="token punctuation">;</span>        A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将比枢轴小的元素移动到左端</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>low <span class="token operator">&lt;=</span> pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>low<span class="token punctuation">;</span>        A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将比枢轴大的元素移动到右端</span>    <span class="token punctuation">&#125;</span>    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span><span class="token comment">//枢轴元素存放到最终位置</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token comment">//返回存放枢轴的最终位置</span><span class="token punctuation">&#125;</span></code></pre><p><strong>快速排序算法性能分析</strong>：</p><p>空间效率：快排需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的深度一致。最好情况下为$O(log_2n)$；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O（n）；平均情况下，栈的深度为$O(log_2n)$。</p><p>时间效率：快排的运行时间与划分是否对称有关，快排最坏情况下，对应区域基本不对称，时间复杂度为$O(n^2)$。快排的时间复杂度和递归深度息息相关，若<code>Partition()</code>可能做道最平衡的划分，得到两个子问题的大小都不可能大于n&#x2F;2，这种情况下，平均时间复杂度为$O(nlog_2n)$。</p><p>稳定性：在划分算法中，有可能会将两个相同的值的相对位置发生变化，即快排是一种不稳定的排序算法。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>简单选择排序的思想：假设排序表为$L[1\dots n]$，第i趟排序即从$L[i\dots n]$中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可以使得整个排序表有序。</p><p><strong>简单选择排序代码实现</strong>：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//一共进行n-1趟</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//记录最小元素位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//在[i..n-1]中选择最小的元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> min<span class="token operator">=</span>j<span class="token punctuation">;</span><span class="token comment">//更新最小元素位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//若当前位置的元素和最小值不同就移动位置</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>            A<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>简单选择排序效率</strong>：</p><p>空间效率：仅使用常熟个辅助单元，故空间效率为O(1)。</p><p>时间效率：在简单排序过程中不会超过3(n-1)次。但元素间比较的次数与序列的初始状态无关，始终是n(n-1)&#x2F;2次，因此时间复杂度始终是$O(n^2)$。</p><p>稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发生改变。</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆的定义如下，n个关键字序列$L[1\dots n]$称为堆，当且仅当该序列满足：</p><ol><li>$L(i)\geq L(2i)且L(i)\geq L(2i+1)$  （大根堆）或</li><li>$L(i)\leq L(2i)且L(i) \leq L(2i+1)$ （小根堆） $(1\leq i \leq [n&#x2F;2])$</li></ol><p>例：</p><p><img src="https://img-blog.csdnimg.cn/8d0b9a7d3da948bd8a66a3bac5d4704f.png" alt="3-1"></p><p>如图3-1，若大根堆中$i&#x3D;1，则L(1)&#x3D;87 \geq L(2)&#x3D;45且L(1)&#x3D;87 \geq L(2+1)&#x3D;78 $，小根堆同理。</p><p>堆数据结构可以视为一棵完全二叉树用顺序存储后的结果，如图3-2所示</p><p><img src="https://img-blog.csdnimg.cn/1bec03e5c49a452195f3795e8354dde5.png" alt="3-2"></p><p>大根堆以完全二叉树视角来看，即$根\geq 左、右$。小根堆则相反，$根\leq 左、右$</p><p><strong>堆排序的思路</strong>：</p><p>首先将存放在L[1…n]中的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆低元素送入堆顶，此时根节点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再继续输出堆顶元素。如此反复。</p><p>而堆排序的关键就是构造初始堆。</p><h5 id="堆构造"><a href="#堆构造" class="headerlink" title="堆构造"></a>堆构造</h5><p>以大根堆为例，若有图3-3这一初始序列$L(53,17,78,9,45,65,87,32)$，并将序列以二叉树形式展示。</p><p><img src="https://img-blog.csdnimg.cn/0dbfa1185bea4314a30f313b645e5e87.png" alt="3-3"></p><p>思路：把所有非终端结点都检查一遍，看是否满足大根堆的要求（根大于左右子树的值），不满足则进行调整，而在顺序存储的完全二叉树中，非终端结点编号$i\leq [n&#x2F;2]$，图上则i&#x3D;[8&#x2F;2]&#x3D;4。即对53，17，78，09进行检查，从右往左进行检查，从而从i&#x3D;4，即09开始判断。</p><p><img src="https://img-blog.csdnimg.cn/fc0cc4b6f68042f48e695c20097b0b27.png" alt="3-4"></p><p>获取09的左孩子通过完全二叉树的性质也得左孩子&#x3D;2i&#x3D;2*4&#x3D;8，即以8为下标的位置为09的左孩子，即32。要保证大根堆的特性，所以要将根结点和左孩子进行交换。</p><p><img src="https://img-blog.csdnimg.cn/a549de1a2da3408d984cbb774bbebebb.png" alt="3-5"></p><p>然后再检查i&#x3D;3（结点78），根据完全二叉树的性质，左孩子&#x3D;2i&#x3D;2*3&#x3D;6（结点65），右孩子&#x3D;2i+1&#x3D;6+1&#x3D;7（结点87）。后再将根节点分别与左右孩子进行比较。将最大的（右孩子结点87）值与根节点交换。</p><p><img src="https://img-blog.csdnimg.cn/67f8b11492164ee7b8d71590846c626a.png" alt="3-6"></p><p>同样的，最后就可以将i&#x3D;1和i&#x3D;2进行以大根堆性质的交换，可得最后结果。</p><p><img src="https://img-blog.csdnimg.cn/cd2b801791984698a46dcb1b12e88a75.png" alt="3-7"></p><p>而此时导致以53为根的子树不满足大根堆的特性，以此要再次对53为根的子树进行调整。</p><p><img src="https://img-blog.csdnimg.cn/7cb8546e7a654570a9746a0ceee04655.png" alt="3-8"></p><p>最后调整完成即可使整个树符合大根堆特性。</p><p><strong>建立大根堆代码实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//建立大根堆</span><span class="token keyword">void</span> <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//从i=[n/2]~1 反复调整堆</span>        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将以k为根的子树调整为大根堆</span><span class="token keyword">void</span> <span class="token function">HeadAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//A[0]暂存子树的根节点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//每次都将i赋值为左孩子</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//左孩子比右孩子小，就用右孩子和根进行比较</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//根比左右孩子都大，就无需交换</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将左右孩子大的值调整到双亲结点上</span>            k <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//修改k的值，以便继续向下筛选</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//for循环结束</span>        A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//被筛选结点的值放入最终位置</span><span class="token punctuation">&#125;</span></code></pre><p><strong>堆排序算法实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始建堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//n-1趟交换堆顶元素和堆底元素位置以及建堆过程</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//堆顶元素和堆底元素交换</span>        A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换后再对剩下的i-1个元素整理成堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>算法效率分析</strong>：</p><p>空间效率：仅使用了常数个辅助单元，所以空间复杂度尾O(1)。</p><p>时间效率：</p><p>设树高为h，某结点再第i层，则将这个结点向下调整最多只需要“下坠”h-i层，关键字对比次数不超过2(h-i)次，而n个结点的完全二叉树树高$h&#x3D;[log_2n]+1$。</p><p>第i层最多有$2^{i-1}$个结点，而只有第1~(h-1)层的结点才有可能需要“下坠”调整（最后一层无需调整），将整棵树调整为大根堆，关键字对比次数不超过<br>$$<br>\sum^{1}<em>{i&#x3D;h-1}2^{i-1}2(h-i)&#x3D;\sum^{1}</em>{i&#x3D;h-1}2^{i}(h-i)&#x3D;\sum^{h-1}_{j&#x3D;1}2^{h-j}j<br>$$<br>将高度$h&#x3D;[log_2n]+1$带入第三式子中，得<br>$$<br>\sum2^{[log_2n]+1-j}j&#x3D;\sum2^{[log_2n]+1}2^{-j}j\leq \sum2^{log_2n}2^{1-j}j&#x3D;\sum 2n2^{-j}j\leq 4n<br>$$<br>所以**建堆时间复杂度为O(n)**，而每次调整的时间复杂度为O(h)，n-1趟的总时间复杂度为$O(nlog_2n)$，故平均的情况下，堆排序的时间复杂度为$O(nlog_2n)$。</p><p>稳定性：进行筛选时，有可能会调整值相同的元素，所以堆排序是不稳定的排序方法。</p><h5 id="在堆中插入新元素"><a href="#在堆中插入新元素" class="headerlink" title="在堆中插入新元素"></a>在堆中插入新元素</h5><p>以小根堆为例，若想在堆中插入元素，会先将新元素放到表尾，与父节点对比，若新元素比父节点更小，则两者互换。再一路向上与根结点比较，直至到无法继续上升位置。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/42d1fa9343de4e90a06135d7bca06c02.png" alt="3-9"></p><p>在表尾插入13，需要与父节点进行比较，即和i&#x3D;[9&#x2F;2]&#x3D;4（32元素），显然13比32小，就将13与父节点进行交换。</p><p><img src="https://img-blog.csdnimg.cn/9ac035521c884d2e8e7710a62624b94e.png" alt="3-10"></p><p>后13在和父节点i&#x3D;[4&#x2F;2]&#x3D;2（17元素）对比，显然13更小，就再与父节点进行交换。</p><p><img src="https://img-blog.csdnimg.cn/0754ebb580f14fcca73fc7373742f669.png" alt="3-11"></p><p>此时在与父节点i&#x3D;[2&#x2F;1]&#x3D;1（9元素）对比，父节点9更小，就无需再进行交换。此时即满足小根堆特性，插入成功。</p><h5 id="在堆中删除元素"><a href="#在堆中删除元素" class="headerlink" title="在堆中删除元素"></a>在堆中删除元素</h5><p>以小根堆为例，若删除非表尾元素则需以表尾元素来替代删除元素的位置，后再通过不断的“下坠”来恢复小根堆的特性。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/1b6bf5434bc54c1f8de4420f2ae9f484.png" alt="3-12"></p><p>在图3-12中，若想删除2位置的元素13。删除后会用表尾46来替代2位置的元素。</p><p><img src="https://img-blog.csdnimg.cn/982ef43ef01d4553a75098ebaa117f3b.png" alt="3-13"></p><p>后再通过46和左右孩子(2i&#x3D;4和2i+1&#x3D;5)进行比较，恢复回小根堆的特性，依次比较可得最后结果：</p><p><img src="https://img-blog.csdnimg.cn/389468b1e15c471caf0de6337c24fd6c.png" alt="3-14"></p><h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并（Merge）：把两个或多个以及有序的序列合并成一个。</p><p>以二路归并（二路归并即将两个表合成一个表）为例：</p><p><img src="https://img-blog.csdnimg.cn/fc89899a5cc14d3997d2140e31b447bb.png" alt="4-1"></p><p>将图4-1的左右两个表合并到一个新表中，可以通过设置i,j,k三个指针来实现，首先，先让i与j所指的值进行比较，即目前12&gt;7，则将7放到k所指位置，然后使<code>j++</code>，i和j再进行比较。</p><p><img src="https://img-blog.csdnimg.cn/daa19a79a61c4d909ed9ddd3f182c97b.png" alt="4-2"></p><p>如此反复，当j超出下标所指范围时，就只会将i所指后面的元素放入到新表中，最后即可得到最后合并的结果：</p><p><img src="https://img-blog.csdnimg.cn/d93d8713705f41fc89cd3c10f82174a0.png" alt="4-3"></p><p><strong>代码实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个长度为n的辅助数组B</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> mid <span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//表A的两段A[low...mid]和A[mid+1...high]各自有序，将它们合并成一个有序表</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>low<span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        B<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将A中所有元素复制到B中</span>    <span class="token comment">//将 i设为第一个表中的头指针 j为第二表中的头指针  k为新表的头指针</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span> j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">=</span>i<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//比较B的左右两端中的元素</span>            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将大的赋值到k所指位置并使指针向右移</span>        <span class="token keyword">else</span>            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span>A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//若第一个表未检测完，复制</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span>A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//若第二个表未检测完，复制</span><span class="token punctuation">&#125;</span></code></pre><p><strong>合并代码实现</strong>：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//从中间划分两个子序列</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对左侧子序列进行递归排序</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对右侧子序列进行递归排序</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token comment">//归并</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>2路归并排序算法性能分析</strong>：</p><p>空间效率：Merge()操作中，辅助单元为n个单元，所以空间复杂度为O(n)。</p><p>时间效率：每趟归并的时间复杂度为O(n)，共需进行$[log_2n]$趟归并，所以算法时间复杂度为$O(nlog_2n)$。</p><p>稳定性：由于Merge()操作不会改变相同元素的相对次序，所以归并排序是稳定的算法。</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。</p><p>假设长度为n的线性表中每个结点$a_j$的关键字由d元组（$k_j^{d-1},k_j^{d-2},\dots,k_j^1,k_j^{0}$）组成，满足$0\leq k_j^i\leq r-1 \quad (0\leq j&lt;n,0\leq i\leq d-1)$。其中$k_j^{d-1}$为最主位关键字，$k_j^0$为最次位关键字，r为基数。</p><p>以<strong>递减</strong>序列为例：</p><p><img src="https://img-blog.csdnimg.cn/8de0cf9d779c421d951f3e5066ae7ca0.png" alt="4-4"></p><p>此时该表的”个十百“均有十种不同的取值（即取0,1,2,3,4,5,6,7,8,9），则基数为10。最次位关键字为个位，最主位关键字为百位。</p><p>若要对图4-4表进行基数排序，首先会新建队列，在第一趟排序中会将所有数按照”个位“进行”分配”。</p><p><img src="https://img-blog.csdnimg.cn/d0b3685920d44680869f7a0a94e5d9ea.png" alt="4-5"></p><p>如图4-5所示，从左往右按“个位”将每个关键字放到对应的队列中，后再根据队列最大的值进行收集，每个元素会从队头出队。</p><p><img src="https://img-blog.csdnimg.cn/6f1e9b4166a44433a220f04271d6a528.png" alt="4-6"></p><p>收集完成后会得到一个“个位”递减的序列。然后再从左往右根据”十位“进行第二趟排序。</p><p><img src="https://img-blog.csdnimg.cn/1b23e471e8074ecd916584a87fa474d5.png" alt="4-7"></p><p>再进行队头关键词出队收集。</p><p><img src="https://img-blog.csdnimg.cn/14102c7b59e848f78b12bf2c6ee1cb28.png" alt="4-8"></p><p>就可以获得”十位“递减的序列，后再根据”百位“，进行第三趟排序。</p><p><img src="https://img-blog.csdnimg.cn/dd2b429af48c49ab8c286743a47bfe3d.png" alt="4-9"></p><p>再对该队列进行收集。</p><p><img src="https://img-blog.csdnimg.cn/40539d3b89ad413ba5ced1e50b935aee.png" alt="4-10"></p><p>最后就可以得到一个”百位“递减的序列，同时若”百位“相等，则根据”十位“递减，同样的，”十位“相等，根据”个位“递减。就获得了一个递减的表。</p><h5 id="基数排序算法性能分析"><a href="#基数排序算法性能分析" class="headerlink" title="基数排序算法性能分析"></a>基数排序算法性能分析</h5><p>空间效率：一趟排序需要的辅助存储空间为r（r个队列：r个队头指针和r个队尾指针），空间复杂度为O(r)。</p><p>时间效率：基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)（r为基数），所以基数排序的时间复杂度为O(d(n+r))。</p><p>稳定性：对于基数排序算法而言，很重要一点就是按位排序时必须是稳定的。因此基数排序一定是稳定的。</p><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><blockquote><p>文件通常是按块存储在磁盘上的，磁盘的读&#x2F;写以”块“为单位，数据读入内存后才能被修改，修改完成后还需写回磁盘，因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即I&#x2F;O数。</p></blockquote><p>外部排序通常采用归并排序法，与内部排序归并相似，先将每个文件块读入缓存，再将读入的记录进行排序，将排序完的有序子文件重新写回外存，最后再对这些文件块逐趟归并，使有序子文件逐渐由小到大，直至得到整个有序文件为止。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/6011a61925774801a9d2d2432a23f765.png" alt="5-1"></p><p>若想将图5-1中文件块有序，需先读入部分文件块使先做到部分有序。</p><p><img src="https://img-blog.csdnimg.cn/f99c88ff152845c4a79a3442958f618b.png" alt="5-2"></p><p>此时读入了两块文件块，对其进行排序。</p><p><img src="https://img-blog.csdnimg.cn/db8b2ce50e014db18d961518261834cb.png" alt="5-3"></p><p>再依次放到输出缓冲区，写回磁盘中。</p><p><img src="https://img-blog.csdnimg.cn/ee19efa7c87f4c4db1cd14b008dd2a74.png" alt="5-4"></p><p>此时这两块文件块就是有序，即可将这两块文件块称为一个有序的”归并段“，然后依次再对剩下的文件块进行读入排序再写回。</p><p><img src="https://img-blog.csdnimg.cn/51b5e6ee26314feea20b8f08c05eae75.png" alt="5-5"></p><p>经过16次读和16次的写，就可以获得8个有序”归并段“，此时就可以根据”归并段“进行归并排序。</p><p><img src="https://img-blog.csdnimg.cn/9bc4c7d8b8c44aa48096792a29d27db4.png" alt="5-6"></p><p>此时将”归并段1“和”归并段2“中的两块子文件放入缓冲区进行排序，当凑满3个关键字就写回磁盘中。</p><p><img src="https://img-blog.csdnimg.cn/acd86994f0b24a60bc4ed47f8d37e9f8.png" alt="5-7"></p><p>此时就凑满3个最小关键字就写回到磁盘中，此时为了方便接下来继续使用二路归并，物理上会新建一个新文件块来存储要写回的关键字，将原先空间归还给系统。</p><p><img src="https://img-blog.csdnimg.cn/678221d791a14bd397ef195624864949.png" alt="5-8"></p><p>然后继续进行归并，而当输入缓冲区有一块为空时，就会立刻从磁盘中再读新的文件快来填补。</p><p><img src="https://img-blog.csdnimg.cn/d9678fa445be42c4a9a2cd3872789363.png" alt="5-9"></p><p>这样就能保证归并永远是从归并段中最小的记录开始。</p><p><img src="https://img-blog.csdnimg.cn/296022b077b14c04aa866ac9fc6fb67e.png" alt="5-10"></p><p>最后就能归并一个更长的“归并段”。</p><p><img src="https://img-blog.csdnimg.cn/d7d9d4e61ea24536b054f2c526e0164e.png" alt="5-11"></p><p>依次再将剩下的归并，可得：</p><p><img src="https://img-blog.csdnimg.cn/78e7f66380f846dfbcee25f8b35978e0.png" alt="5-12"></p><p>然后依据这个思路，扩充为8、16个文件块为以归并段进行归并，就能获得最终有序文件。</p><p>一般情况下，外部排序中实现两两归并时，会进行大量数据读出、写入磁盘，而这会耗费大量的时间。一般<strong>外部排序的总时间 &#x3D; 内部排序所需的时间 + 外存信息读写的时间 + 内部归并所需的时间</strong>。</p><p>由上二路归并所示，生成一个归并段就会进行了读、写外部信息，而读写的次数&#x3D;32 + 32*3 &#x3D;128（初始生成归并段进行读、写各16次，读、写各16次，共三趟归并）。</p><p>若想进行优化，可采用4归并排序，仅需2趟归并，此时外部读、写次数减至32+ 32 *2 &#x3D; 96次。</p><p><strong>结论</strong>：</p><p>对用r个初始归并段，做k路归并，则归并书可用k叉树表示，若树高为h，则$归并趟数&#x3D;h-1&#x3D;[\log_kr]$，<strong>若k越大，r越小，归并趟数越少，读写磁盘次数越少</strong>。</p><h4 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h4><p>败者树可视为一棵完全二叉树。k个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较（即让更小的进行下一步比较，根节点为要比较的结点中最小的值），一直到根结点。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/c20e026756ca4086a41f8e119cd7ca54.png" alt="5-13"></p><p>败者树中会将每个归并段中第一个最小的关键字进行比较，更小的将继续上升继续下一轮比较。</p><p><img src="https://img-blog.csdnimg.cn/d9834dab86a141b9bec30379e3da5882.png" alt="5-14"></p><p>从左往右看27和12进行比较，12失败，记录失败者的归并段1，12进行下一场比拼。1和17比较，1失败，记录失败者的归并段4，1进入下一场比拼。2和9比较，2失败，记录失败者的归并段6，2进行下一场比拼。11和4比较，4失败，记录失败者的归并段7，4进入下一场比拼，每次都会进行最小关键字的比较，比较到最后可得最小关键字为1，来自归并段3（树中放的是关键字来自哪个归并段）。</p><p><img src="https://img-blog.csdnimg.cn/3d7dc3d362ee444eac12a2a20646d849.png" alt="5-15"></p><p>然后进行下一轮比较，直接可从归并段3中使6出队，与剩下的进行比较。</p><p><img src="https://img-blog.csdnimg.cn/d56bdfd7769847f18e5e602b8cede7b7.png" alt="5-16"></p><p>依次进行比较，后面就不再过多赘述。</p><p><strong>对于k路归并，第一次构造败者树需要对比关键字k-1次，有了败者树，选出最小元素只需对比关键字$[\log_2k]$次</strong></p><h4 id="置换-选择排序（生成初始归并段）"><a href="#置换-选择排序（生成初始归并段）" class="headerlink" title="置换-选择排序（生成初始归并段）"></a>置换-选择排序（生成初始归并段）</h4><blockquote><p>若磁盘要排序总的记录个数为n，每个归并段的长度为l，则初始归并段的个数$r&#x3D;[n&#x2F;l]$。若用内部排序方法得到各个初始归并段，它就依赖于内部排序时可用内存工作区的大小。因此，可用置换-选择算法来产生更长的初始归并段。</p></blockquote><p>设初始代排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置换-选择排序步骤如下：</p><ol><li>从FI输入w个记录到工作区WA。</li><li>从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。</li><li>将MINIMAX记录输出到FO中去。</li><li>若FI不空，则从FI输入下一个记录到WA中。</li><li>从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li><li>重复3和5的步骤，直至WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中。</li><li>重复2和6的步骤，直至WA为空。</li></ol><p>例子（构造递增归并段）：</p><p><img src="https://img-blog.csdnimg.cn/76e4fe19f05f4f988a3d852e0b957622.png" alt="5-17"></p><p>如图5-17，有24个初始待排序记录，设内存工作区WA只能容纳3个记录，会先读取FI中开头的三个记录3、4、9，加入到WA中，然后选出最小的记录为MINIMAX记录并放到归并段1中。</p><p><img src="https://img-blog.csdnimg.cn/7ac072b464164ef6adb739c633f66ae2.png" alt="5-18"></p><p>此时WA中出现空位，就会从FI中再读入新的记录。</p><p><img src="https://img-blog.csdnimg.cn/c4ecccb8057a48bbb53d177b073a9535.png" alt="5-19"></p><p>此时WA中最小值为6，并且比$MINIMAX&#x3D;4$要大，所以将6放入到归并段1中，并且把MINIMAX修改为6，再从FI中读入13。</p><p><img src="https://img-blog.csdnimg.cn/585a23d98d00490595b0b4e137063b9e.png" alt="5-20"></p><p>不断重复上方步骤，直至读入10时：</p><p><img src="https://img-blog.csdnimg.cn/30bacbf8543141048250ccfe5b71c7d5.png" alt="5-21"></p><p>此时10要小于$MINIMAX&#x3D;13$，从而要将MINIMAX改成第二小的14（保证归并段1中递增），并将14放入放入归并段1中。</p><p><img src="https://img-blog.csdnimg.cn/e063ffdd51e64747856acb27c773673d.png" alt="5-22"></p><p>再继续进行上方步骤，直至WA中都比归并段1中末尾值要小。说明此时就应该截止。</p><p><img src="https://img-blog.csdnimg.cn/add5f4fc027b4c288fb10dac4abd78aa.png" alt="5-23"></p><p>后面剩下的记录和上方步骤一样，即可获得最终3个归并段。</p><p><img src="https://img-blog.csdnimg.cn/1b2040ca9e05495296b78bf3f31852f9.png" alt="5-24"></p><h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4><p>最佳归并树是将长度不等的初始归并段来归并排序，并使I&#x2F;O次数最少。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/be1a611048f34f52801b6577cbf10102.png" alt="5-25"></p><p>若有图5-25五个归并段R1,R2,R3,R4,R5，记录个数分别为2,5,1,6,2。此时使用二路归并，来生成归并树:</p><p><img src="https://img-blog.csdnimg.cn/accd33c2703b42f2aec7da7d6568c502.png" alt="5-26"></p><p>先将R2和R3进行二路归并，将R2中5个记录和R3中1个记录读入到内存，在内存中进行归并后再写回磁盘，来回就读、写各（5+1）次，R4和R5同理，读、写各（6+2）次，然后再将他们归并好的记录个数6和记录个数8进行归并成有14记录的归并段，最后再和R1归并，即最终的含有16个记录的归并段。</p><p>此时上方<strong>读磁盘的次数&#x3D;写磁盘的次数&#x3D;6+8+14+16&#x3D;44次</strong>，而此时归并树的带权路径长度$WPL&#x3D;2<em>1+5</em>3+1<em>3+6</em>3+2*3&#x3D;44$，和读、写磁盘的次数相同。</p><p><strong>由此可得$I&#x2F;O次数&#x3D;2\times WPL$。</strong></p><p>若想让I&#x2F;O次数最少，即WPL最少，就可以使用哈夫曼树来构建，哈夫曼树（以二路归并为例）就是以两个结点权值最小的组成一个树，此时根节点为两个结点权值之和，后再根据权值最小的两个结点进行归并。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/f11efe61e6744c41ad6e465431a9d5e5.png" alt="5-27"></p><p>图2-27中构建哈夫曼树先R3和R1构成一棵树，根节点的权值为3，根节点3再与R5构建树，根节点权值为5，再与R2构建树，根节点权值为10，再与R4构建树，根节点权值为16。</p><p><img src="https://img-blog.csdnimg.cn/5f341abaf883454fad55f3b8e3a357eb.png" alt="5-28"></p><p>此时树的$WPL&#x3D;1<em>4+2</em>4+2<em>3+5</em>2+6*1&#x3D;34$，而此时I&#x2F;O次数只需68次，先前图5-25进行归并则需I&#x2F;O88次，明显用哈夫曼树效率提高。</p><p>而当进行k叉归并时，若<strong>初始归并段的数量无法构成严格的k叉归并树，则需要补充几个权值为0的“虚段”</strong>，再进行k叉哈夫曼树的构造。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/8ece6b66cca8402d93d54be5052407bd.png" alt="5-29"></p><p>此时图2-29若想进行3路归并，显然会少一个结点，此时就可以填补一个虚段0，从而满足严格3叉归并树。</p><p><img src="https://img-blog.csdnimg.cn/b4790fa1c7ef4ac99399bee9d2271985.png" alt="5-30"></p><p>再构建3叉哈夫曼树：</p><p><img src="https://img-blog.csdnimg.cn/df0646c468dc48f3a25f93bdbf558cf7.png" alt="5-31"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-查找</title>
      <link href="/2023/10/25/shu-ju-jie-gou-cha-zhao/"/>
      <url>/2023/10/25/shu-ju-jie-gou-cha-zhao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="查找表的基本概念"><a href="#查找表的基本概念" class="headerlink" title="查找表的基本概念"></a>查找表的基本概念</h4><ol><li>查找：在数据集合中寻找满足某种条件的数据元素的过程叫查找。</li><li>查找表（查找结构）：用于查找的数据集合称为查找表，由同一类型的数据元素组成。</li><li>静态查找表：若查找表只涉及搜索和插入操作，无需动态的修改查找表，则称此类表为静态查找表。</li><li>关键字：数据元素中唯一标识该元素的某个数据项的值。</li><li>平均查找长度：在查找过程中，进行关键字比较次数的平均值，数学定义为：</li></ol><p>$$<br>ASL&#x3D;\sum_{i&#x3D;1}^{n}P_iC_i<br>$$</p><p>n是查找表的长度；$P_i$是查找第i各数据元素的概率，一般认为每个数据元素的查找概率相等，即$P_i&#x3D;\frac{1}{n}$；$C_i$是找到第i各元素所需进行的比较次数。</p><h3 id="顺序查找和折半查找"><a href="#顺序查找和折半查找" class="headerlink" title="顺序查找和折半查找"></a>顺序查找和折半查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><blockquote><p>顺序查找又称线性查找，它对于顺序表和链表都适用。对于顺序表，可通过数组下标递增来顺序扫描每个元素；对于链表，可通过next来依次扫描每个元素。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。</p></blockquote><h5 id="一般线性表的顺序查找"><a href="#一般线性表的顺序查找" class="headerlink" title="一般线性表的顺序查找"></a>一般线性表的顺序查找</h5><p>作为最直观的查找方法，基本思想就是从一端逐个检查关键字是否满足给定的条件。</p><p>算法实现：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token comment">//查找表的数据结构</span>    ElemType <span class="token operator">*</span>elem<span class="token punctuation">;</span><span class="token comment">//动态数组基址</span>    <span class="token keyword">int</span> TableLen<span class="token punctuation">;</span><span class="token comment">//表的长度</span><span class="token punctuation">&#125;</span>SSTable<span class="token punctuation">;</span><span class="token comment">//顺序查找</span><span class="token keyword">int</span> <span class="token function">Search_Seq</span><span class="token punctuation">(</span>SSTable ST<span class="token punctuation">,</span>ElemType key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> ST<span class="token punctuation">.</span>TableLen <span class="token operator">&amp;&amp;</span> ST<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>key<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//查找成功返回元素下标</span>    <span class="token keyword">return</span> i<span class="token operator">==</span>ST<span class="token punctuation">.</span>TableLen <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>ASL计算</strong></p><p>对于有n各元素的表，给定值key与表中的第i各元素相等，即定位第i各元素时，需进行$n-i+1$次关键字的比较，即$C_i&#x3D;n-i+1$。查找成功时，顺序查找的平均长度为<br>$$<br>ASL_{成功}&#x3D;\sum_{i&#x3D;1}^n P_i(n-i+1)<br>$$<br>当每个元素的查找概率相等，即$P_i&#x3D;\frac{1}{n}$时，有<br>$$<br>ASL_{成功}&#x3D;\sum_{i&#x3D;1}^n P_i(n-i+1)&#x3D;\frac{n+1}{2}<br>$$<br>上方式子实际也就是：<br>$$<br>ASL_{成功}&#x3D;\sum_{i&#x3D;1}^n P_i \frac{i}{n}&#x3D;\frac{n+1}{2}<br>$$<br>若查找不成功时，与表中关键字比较的次数显然是n+1次，**即$ASL_{不成功}&#x3D;n+1$**。</p><h5 id="有序表的顺序查找"><a href="#有序表的顺序查找" class="headerlink" title="有序表的顺序查找"></a>有序表的顺序查找</h5><p>若在查找之前就知道表是有序的，则查找失败时可以不用再进行后序的遍历到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。</p><p>设有一个表<code>L[6]=&#123;7,13,19,29,37,43&#125;</code>，若要查找的<code>key=21</code>，当顺序查找到29时，$key&#x3D;21&lt;29$，因为表是顺序递增，所以就可以终止查找从而来增加查找效率。</p><p><img src="https://img-blog.csdnimg.cn/ce3840427e274bc789154fd9f2bb787a.png" alt="1-1"></p><p>根据上方表即可绘制出图1-1的查找树。</p><p>一个成功结点的查找长度&#x3D;自身所在层数。</p><p>一个失败结点的查找长度&#x3D;其父结点所在层数。</p><p><strong>ASL计算</strong></p><p>对于有n各元素的表，给定值key与表中的第i各元素相等，即定位第i各元素时，需进行$n-i+1$次关键字的比较，即$C_i&#x3D;n-i+1$。查找成功时，顺序查找的平均长度为<br>$$<br>ASL_{成功}&#x3D;\sum_{i&#x3D;1}^n P_i \frac{i}{n}&#x3D;\frac{n+1}{2}<br>$$<br>而若查找失败，设每次查找的概率相同，即$P_i&#x3D;\frac{1}{n+1}$，则有<br>$$<br>ASL_{不成功}&#x3D;\frac{1+2+3+\dots +n+n}{n+1}&#x3D;\frac{n}{2}+\frac{n}{n+1}<br>$$</p><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>折半查找，又称二分查找，仅适用于有序的顺序表。</p><p>折半查找的基本思想：首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能再中间元素以外的前半部分或后半部分。然后在缩小的范围内继续进行同样的查找，如此重复。</p><p>算法实现：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Binary_Search</span><span class="token punctuation">(</span>SSTable L<span class="token punctuation">,</span>ElemType key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> low<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>high<span class="token operator">=</span>L<span class="token punctuation">.</span>TableLen<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//获取中间位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span><span class="token comment">//查找成功</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">)</span><span class="token comment">//中间元素大于要查找的元素，所以要从前半部分继续查找</span>            high<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            low<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//否则从后半部分进行查找</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//查找失败</span><span class="token punctuation">&#125;</span></code></pre><p>在<strong>折半查找判定树的构造</strong>中，如果当前<code>low</code>和<code>high</code>之间有<strong>奇数个</strong>元素，则<code>mid</code>分隔后，<strong>左右两部分元素个数相等。</strong></p><p>如果当前<code>low</code>和<code>high</code>之间有<strong>偶数个</strong>元素，则<code>mid</code>分隔后，<strong>左半部分比右半部分少一个元素。</strong></p><p>折半查找的判定树中，若<code>mid=[(low + high)/2]</code>，则对于任何一个结点，必有：<strong>右子树结点数-左子树结点数&#x3D;0或1</strong></p><p><strong>ASL计算</strong></p><p><img src="https://img-blog.csdnimg.cn/ab28b500c87241c280e73d13b9ffc1c0.png"></p><p>通过上方的折半查找判定树，设在等概率的情况下查找时，<strong>查找成功</strong>的查找平均长度为：<br>$$<br>ASL_{成功}&#x3D;\frac{1<em>1+2</em>2+3<em>4+4</em>4}{11}&#x3D;3<br>$$<br>树从上往下看，第一层元素进行一次对比，第二层元素进行两次对比，第三层元素进行四次对比，第四层元素也进行四次对比，从而再乘上概率得出ASL。</p><p>若<strong>查找失败</strong>，则有<br>$$<br>ASL_{失败}&#x3D;\frac{3<em>4+4</em>8}{12}&#x3D;\frac{11}{3}<br>$$<br>同样地树从上往下看，第三层失败进行了四次对比，第四层失败进行了八次对比，从而再乘上概率得出ASL。</p><p>折半查找的判定树中，<strong>只有最下面一层是不满的</strong>，因此可以通过平衡二叉树得元素个数为n时树高$h&#x3D;[\log_2(n+1)]$。</p><p>从树高可得折半查找成功的$ASL\leqslant n$，同样的查找失败的$ASL\leqslant n$。</p><p>从而在查找等概率情况下有查找成功的平均长度为<br>$$<br>ASL&#x3D;\frac{1}{n}(1\times 1 + 2\times 2 + \dots + h \times 2^{h-1})&#x3D; \frac{n+1}{2}\log_2(n+1)-1\approx \log_2(n+1)-1<br>$$</p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块间的元素是有序的，即第一块中的最大关键字小于第二块中的所有记录的关键字，第二个块中的最大关键字小于第三块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/ccce657834a14b2eb4943e103ff2f4b9.png" alt="1-2"></p><p>在图中将要查找的表进行分块，然后取出每个块中最大的元素。然后依次来将要查找的关键字和每个块中的最大元素进行比较。按顺序查找，若关键字大于当前块中最大的元素，则往后与下一个块的最大元素进行比较，直到关键字小于等于块的最大元素。</p><p>然后再到分块中进行顺序查找，直到找到相匹配的关键字，若找不到则为查找失败。</p><p><strong>若在分块查找中使用折半查找，有可能会出现<code>low&gt;high</code>，而当前查找元素却存在于分块的元素中，就有可能出现查找错误。</strong></p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/097f6ce55bfc42c3b7345baf352abc23.png" alt="1-3"></p><p>此时上方折半查找<code>low==high==mid</code>，由于<code>key&lt;mid</code>，所以按照折半查找的规则会让<code>high--</code>，导致成图1-4的结果，此时就会判定为查找失败。</p><p><img src="https://img-blog.csdnimg.cn/149c159a57a34c379796105bf26e6988.png" alt="1-4"></p><p>然而查找元素就在20的分块中，所以需要而外的查找，每当索引表最终停在<code>low&gt;high</code>时，<strong>要在low所指分块中查找（因为此时只有low所指向的分块中<code>key&lt;mid</code>，所以要是能查找到必定是在low所指向的分块中）</strong>。</p><p><img src="https://img-blog.csdnimg.cn/e8f88b864c7c433b9cf86633fd06418a.png" alt="1-5"></p><p><strong>ASL计算</strong></p><p>设索引查找和块内查找的平均查找长度分别为$L_1,L_S$，则分块查找的平均查找长度为<br>$$<br>ASL&#x3D;L_1+L_S<br>$$<br>将长度为n的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引表中均用顺序查找，则平均查找长度为<br>$$<br>L_1&#x3D;\sum_{i&#x3D;1}^b \frac{i}{b}&#x3D; \frac{b+1}{2}\<br>L_1&#x3D;\sum_{i&#x3D;1}^s \frac{i}{s}&#x3D; \frac{s+1}{2}\<br>ASL&#x3D; \frac{b+1}{2} + \frac{s+1}{2}<br>$$<br>而基于查找表为b，每块记录为s，可得长度$n&#x3D;sb$，则有$b&#x3D;\frac{n}{s}$，带入到ASL的式子中，有<br>$$<br>ASL&#x3D;\frac{s^2+2s+n}{2s}<br>$$<br>当$s&#x3D;\sqrt{n}$（可用求导求最值证明），则平均查找长度取最小值$\sqrt{n}+1$。</p><h3 id="树型查找"><a href="#树型查找" class="headerlink" title="树型查找"></a>树型查找</h3><h4 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h4><blockquote><p>构造一棵二叉排序树的目的并不是为了排序，而是为了提高查找、插入和删除关键字的速度，二叉排序树这种非线性结构也有利于插入和删除的实现。</p><p>二叉排序树的特性：</p><ol><li>若<strong>左子树</strong>非空，则左子树上所有结点的值均<strong>小于根结点</strong>的值。</li><li>若<strong>右子树</strong>非空，则右子树上所有结点的值均<strong>大于根结点</strong>的值。</li><li>左、右子树也分别是一颗二叉排序树。</li></ol><p>对二叉排序树进行中序遍历，可以得到一个递增的有序序列。</p></blockquote><h5 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h5><p>查找是从根节点开始，然后沿某个分支逐层向下比较。</p><p><strong>二叉排序树查找实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//二叉排序树数据结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BSTNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">BSTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>BSTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BSTree<span class="token punctuation">;</span><span class="token comment">//二叉排序树查找</span>BSTNode <span class="token operator">*</span><span class="token function">BST_Search</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span> ElemType key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">!=</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//若树非空且要搜索的值不等于根节点值，则进行循环</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> T<span class="token operator">-></span>data <span class="token punctuation">)</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>lchild<span class="token punctuation">;</span><span class="token comment">//若关键字小于根节点的值，则必定在左子树中，就从左子树继续搜索</span>        <span class="token keyword">else</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>rchild<span class="token punctuation">;</span><span class="token comment">//否则关键字大于根节点的值，就从右子树中上查找</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h5><p>插入过程：若二叉排序树为空，则直接插入；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树中。插入的结点一定是新的叶子。</p><p><strong>二叉排序树插入实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//若树为空，则插入的记录为根结点</span>        T <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BSTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        T<span class="token operator">-></span>data <span class="token operator">=</span> k<span class="token punctuation">;</span>        T<span class="token operator">-></span>lchild <span class="token operator">=</span> T<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回1，表示插入成功</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token comment">//树中存在相同关键字的结点，插入失败</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token comment">//关键字小于当前结点的值，递归插入到左子树中</span>        <span class="token keyword">return</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token comment">//关键字大于当前结点的值，递归插入到右子树中</span>        <span class="token keyword">return</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h5><p>从一棵空树出发，一次输入元素并将他们插入到二叉排序树中的合适位置。、</p><p><strong>二叉排序树插入实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//T为要构造的树 str为元素  n为元素的个数</span><span class="token keyword">void</span> <span class="token function">Creat_BST</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> KeyType str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    T <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//初始时T为空树</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//一次将关键字插入到二叉排序中</span>        <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>例：</p><p>若按照序列<code>str=&#123;50,66,60,26,21,30,70,68&#125;</code>建立BST，得图2-1：</p><p><img src="https://img-blog.csdnimg.cn/03f253dcbaa64d3097a4486a26293bdd.png" alt="2-1"></p><p>而若按照序列<code>str=&#123;26,21,30,50,60,66,68,70&#125;</code>建立BST，得图2-2：</p><p><img src="https://img-blog.csdnimg.cn/c95251337c8e471bb5b99f398e4e42cd.png" alt="2-2"></p><h5 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h5><p>在二叉排序中删除一个结点，若该结点有子树，则需要把被删除结点从存储二叉排序树的链表上摘下，后再删除结点并再和原先树连接起来。</p><p>删除操作的实现有3种情况：</p><ol><li>若被删除结点为叶结点，直接删除。</li><li>若结点z只有一棵左子树或右子树，则让z的子树称为z父结点的子树，代替z的位置。</li><li>若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树种删除这个直接后继（或直接前驱），转换成第一或第二种情况。</li></ol><p>例（讨论第三种情况）：</p><p><img src="https://img-blog.csdnimg.cn/251a7324f0984b7b996991d066fb2c1d.png" alt="2-3"></p><p>图2-3中若要删除z结点，则以直接后继来替代z，则需要右子树中值为最小的数，即右子树通过中序遍历（二叉排序数可通过中序遍历来获得一个递增的有序序列）可得结点p为最小值。所以以p来替换z的位置，后再填补上p的位置，可得结果图2-4。</p><p><img src="https://img-blog.csdnimg.cn/6fb530f3254541249be742159d2725dc.png" alt="2-4"></p><p>而若使用直接前驱来替换z结点的话，则需要通过中序遍历获得左子树中最大的结点，后再替换z再进行同样的操作，可得图2-5</p><p><img src="https://img-blog.csdnimg.cn/f7e9ec9bc43e44c4a64bf3ff901ae0e6.png" alt="2-5"></p><h6 id="二叉排序树查找效率分析"><a href="#二叉排序树查找效率分析" class="headerlink" title="二叉排序树查找效率分析"></a>二叉排序树查找效率分析</h6><p>二叉排序的查找效率，主要取决于树的高度。若二叉排序树左右子树的高度之差的绝对值不超过1，它的平均查找长度为$O(\log_2n)$。若二叉排序树是一个只有右（左）子树的单支树，则其平均查找长度为$O(n)$。</p><h4 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h4><blockquote><p>平衡二叉树就是保证任意结点的左、右子树高度差的绝对值不超过1。</p><p>在此定义结点左子树与右子树的高度差为该结点的平衡因子，<strong>结点的平衡因子&#x3D;左子树高-右子树高</strong>，所以平衡二叉树结点的平衡因子的值只可能是-1、0或1.</p></blockquote><p><strong>平衡二叉树的结构</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">AVLNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span><span class="token comment">//数据域</span>    <span class="token keyword">int</span> balance<span class="token punctuation">;</span><span class="token comment">//平衡因子</span>    <span class="token keyword">struct</span> <span class="token class-name">AVLNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>AVLNode<span class="token punctuation">,</span> <span class="token operator">*</span>AVLTree<span class="token punctuation">;</span></code></pre><h5 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h5><p>二叉排序树保持平衡的基本思想是：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否会因此次操作导致不平衡。若导致不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</p><p><strong>注：每次调整的对象都是离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。</strong></p><p>平衡二叉树在调整时可归纳为下列四种情况：</p><p><strong>LL平衡旋转（右单旋转）</strong>：由于在结点A的左孩子（L）的左子树（L）上插入了新结点，导致A的平衡因子由1增长到2，导致以A为根的子树失去平衡，需要进行一次右转操作来重新保持平衡。</p><p><img src="https://img-blog.csdnimg.cn/b03cc53cba0b4820b665f4d76c41aad0.png" alt="2-6"></p><p>右旋即让图2-6中B称为根节点，A成B的右子结点，而B的原右子树则作为A结点的左子树。（$AR&gt;A&gt;BR&gt;B&gt;BL$）</p><p><img src="https://img-blog.csdnimg.cn/cd25ffbb91e440a2ad25653873fb6d30.png" alt="2-7"></p><p><strong>RR平衡旋转（左单旋转）</strong>：由于在结点A的右孩子（R）的右子树（R）上插入了新结点，A的平衡因子由-1减至-2。导致以A为根的子树失去平衡，需要进行一次向左旋转操作。</p><p><img src="https://img-blog.csdnimg.cn/25f957fc31eb4ac68bb8930da6cf611e.png" alt="2-8"></p><p>左旋即让B成为根结点，A结点成为B的左子树根节点，而B的原左子树则作为A结点的右子树。（$BR&gt;B&gt;BL&gt;A&gt;AL$）</p><p><img src="https://img-blog.csdnimg.cn/c9e417702eb246ddad63192cd7a6de76.png" alt="2-9"></p><p><strong>LR平衡旋转（先左后右双旋转）</strong>：由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。</p><p><img src="https://img-blog.csdnimg.cn/c694add98b7f42789a2b0560a3993998.png" alt="2-10"></p><p>假设BR为结点C，设新结点插入到C结点的右子树中，先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把C结点向右上旋转提升到A的位置，如图2-11所示。（<strong>BL&lt;B&lt;CL&lt;C&lt;CR&lt;A&lt;AR</strong>）</p><p><img src="https://img-blog.csdnimg.cn/5f0fe3e02b294ef98d8cc5cd02517aa8.png" alt="2-11"></p><p><strong>RL平衡旋转（先右后左双旋转）</strong>：由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。</p><p><img src="https://img-blog.csdnimg.cn/f1f0f0ede7cf423ab4d016197f9ac143.png" alt="2-12"></p><p>假设BL为结点C，设新结点插入到C结点的左子树中（左右的结果都是相同），先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把C结点向左上旋转提升到A的位置。（<strong>AL&lt;A&lt;CL&lt;C&lt;CR&lt;B&lt;BR</strong>）</p><p><strong>查找效率分析</strong></p><p>若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找插座的时间复杂度不可能超过O(h)。</p><p>由于平衡二叉树的左子树和右子树高度之差不超过1。</p><p>假设$n_h$表示深度为h平衡树中含有最少结点树。</p><p>则高度为h的结点数量$n_h&#x3D;n_{h-1}+n_{h-2}+1$，基于这公式可得树最大高度$h_{max}&#x3D;O(\log_2n)$，即为平衡二叉树的平均查找长度。</p><p>.</p><h5 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h5><p>平衡二叉树的删除有以下几个步骤（以删除结点w为例）：</p><ol><li>用二叉排序树的方法对结点w执行删除操作。</li><li>若导致了不平衡，则从结点w向上开始回溯，找到第一个不平衡的结点z（即最小不平衡子树）；y为结点z的高度最高的孩子结点；x是结点y的高度最高的孩子结点。</li><li>然后对以z为根的子树进行平衡调整，其中x、y和z可能的位置有四种情况：</li></ol><ul><li>y是z的左孩子，x是y的左孩子（LL，右单旋转）；</li><li>y是z的左孩子，x是y的右孩子（LR，先左后右旋转）；</li><li>y是z的右孩子，x是y的右孩子（RR，左单旋转）；</li><li>y是z的右孩子，x是y的左孩子（RL，先右后左旋转）；</li></ul><p>四种情况操作基本和插入操作调整方式一样。<strong>不同之处</strong>在于，插入仅需要对z以根的子树进行平衡调整；则删除操作需要，先对以z为根的子树进行平衡调整，如果调整后以后上方二叉树中存在不平衡，则需要对z的祖先结点进行平衡调整。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/d19c74f47bcd409680d9bbdef8511cd6.png" alt="2-13"></p><p>若要删除图2-13的第32位置的结点，会导致第44位置的结点成为最小不平衡子树，需要对44位置的结点进行平衡调整，将50结点先右旋到78结点位置再左旋到50位置即可成功调整会平衡二叉树。</p><p><img src="https://img-blog.csdnimg.cn/d9c9f8cb6b64437da2e5be2f23f008dd.png" alt="2-14"></p><p>而此时又导致了33结点出现的不平衡，所以需要再对33结点进行平衡调整。在33结点的子树中找到高度最高的孩子10结点，然后再找到高度最高的孙结点20。对20结点进行左旋后右旋就可以再次调整回平衡二叉树。</p><p><img src="https://img-blog.csdnimg.cn/bd79a931a3da4f909d0cb1f5d5dba1b6.png" alt="2-15"></p><h4 id="红黑树（Red-Black-Tree-RBT）"><a href="#红黑树（Red-Black-Tree-RBT）" class="headerlink" title="红黑树（Red-Black Tree,RBT）"></a>红黑树（Red-Black Tree,RBT）</h4><h5 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h5><p>为了保持AVL树的平衡性，插入和删除操作需要频繁地调整树的拓扑结构，代价较大，所以引入了红黑树。</p><p>一棵红黑树，如图2-16，是满足如下红黑性质的二叉排序树（$左子树结点值\leqslant 根结点值 \leqslant 右子树结点值$）：</p><ol><li>每个结点是红色或黑色。</li><li>根结点是黑色的。</li><li>叶结点（虚构的外部结点、NULL结点）都是黑色的。</li><li>不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。</li><li>对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。</li></ol><p><img src="https://img-blog.csdnimg.cn/f2ffb6cab5ce4892a53c2170a9eff35a.png" alt="2-16"></p><p>从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的<strong>黑高（记为bh）</strong>，根节点的黑高称为红黑树的黑高。</p><p>根据性质可得出结论：</p><p><strong>结论1：从根到叶结点的最长路径不大于最短路径的2倍。</strong></p><p><strong>结论2：有n个内部结点的红黑树的高度$h\leqslant 2\log_2(n+1)$，即查找操作时间复杂度为$O(log_2n)$</strong></p><h5 id="红黑树的查找"><a href="#红黑树的查找" class="headerlink" title="红黑树的查找"></a>红黑树的查找</h5><p>与BST、AVL相同，从根出发，左小右大，若查找到空叶结点，则查找失败。</p><h5 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h5><p>红黑树的插入过程和二叉查找树的过程基本类似，不同在于红黑树中插入新结点后需要调整（通过重新着色或旋转操作），以满足红黑树的性质。</p><p>若新节点是<strong>根结点</strong>染为黑色，若是<strong>非根</strong>染为红色。</p><p>设结点z为新插入的结点。插入过程如下：</p><ol><li>用二叉查找树插入法插入，并将结点z染为红色。若结点z的<strong>父节点是黑色</strong>，无须做任何调整，此时就是标准的红黑树。</li><li>如果z结点的父节点z.p是红色，则分为三种情况，区别在于z的叔结点y（父节点的兄弟结点）的颜色不同，因父节点z.p为红色，所以爷结点z.p.p必然为黑色。所以分情况需要进行旋转或染色：</li></ol><p><strong>若叔结点为黑色</strong>，需要旋转加染色。</p><ul><li>LL型：右单旋，父换爷+染色。</li><li>RR型：左单旋，父换爷+染色。</li><li>LR型：左、右双旋，儿换爷+染色。</li><li>RL型：右、左双旋，儿换爷+染色。</li></ul><p><strong>若叔结点为红色</strong>，需要把叔结点、父结点、爷结点都染色（即红变黑，黑变红），再把爷结点视为新结点，以新节点给规则再做判断。</p><p>叔父爷染色，爷变为新结点。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/7d1bc00e00b243e3a49fb0228e609375.png" alt="2-14"></p><p>在图2-14再插入结点5，先染为红色，再看父节点10的兄弟结点为黑色，且新插入的结点为LL型（即插入到爷结点的左孩子的左孩子中）。</p><p><img src="https://img-blog.csdnimg.cn/0933271eec994122ac001b1fa19c2363.png" alt="2-15"></p><p>对于LL型处理方法：需要进行右单旋，父结点和爷结点交换并染色。</p><p><img src="https://img-blog.csdnimg.cn/ef00c6f6c38b4dd2b372c0feda0c340b.png" alt="2-16"></p><p>然后最后再把10结点染为黑色，20结点染为红色，如图2-17。</p><p><img src="https://img-blog.csdnimg.cn/b620ac59bdfc47baa8487b97df6e9465.png" alt="2-17"></p><h5 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h5><p>红黑树的插入操作容易导致连续的两个红结点，会导致破环红黑树的性质。而删除操作容易造成子树黑高的变化，导致从一个结点到任意叶结点的简单路径上，黑结点数量不同。（<strong>后续再补充</strong>）</p><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><h4 id="B树及其基本操作"><a href="#B树及其基本操作" class="headerlink" title="B树及其基本操作"></a>B树及其基本操作</h4><p>所谓m阶B树是所有结点的平衡因子均等于0的<strong>m路平衡查找树</strong>。</p><p>一颗m阶B树或为空树，或为满足如下特性的m叉树：</p><ol><li><p>树中每个结点至多有m棵子树，即至多含有m-1个关键字。</p></li><li><p>若根结点不是叶结点，则至少有两棵子树。</p></li><li><p>除根结点外的所有非叶结点至少有[m&#x2F;2]棵子树，即至少含有[m&#x2F;2]-1个关键字。</p></li><li><p>所有非叶结点的结构如下：</p><p><img src="https://img-blog.csdnimg.cn/50f25632244f4c56a45f9258d45ad694.png" alt="3-1"></p><p>其中，Ki(i&#x3D;1,2,…,n)为结点关键字，且满足$K1&lt;K2&lt;\dots&lt;Kn$；Pi(i &#x3D; 0,1,…,n)为指向子树根结点的指针，且指针Pi-1所指子树中所有结点的关键字均小于Ki，Pi所指子树中所有结点的关键字均大于Ki，n（$[m&#x2F;2]-1\leqslant n\leqslant m-1$）为结点中关键字的个数。</p></li><li><p>所有的叶结点都出现再同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点）。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/10b3617a34234c979fa8d58a530c4a27.png" alt="3-2"></p><h5 id="B树的高度（磁盘存取次数）"><a href="#B树的高度（磁盘存取次数）" class="headerlink" title="B树的高度（磁盘存取次数）"></a>B树的高度（磁盘存取次数）</h5><p>设B树的高度不包括最后的不带任何信息的叶结点所处的那一层，若$n\geqslant 1$，则对任何一棵包含n个关键字、高度为h、阶数为m的B树：</p><ol><li><p>因为B树种每个结点最多有m棵子树，m-1个关键字，所以在一棵高度为h的m阶B树中关键字的个数应满足$n\leq (m-1)(1+m+m^2+\dots +m^{h-1})&#x3D;m^h-1$，因此有<br>$$<br>h\geq \log_m(n+1)<br>$$</p></li><li><p>若让每个结点中的关键字个数最少，则容纳同样多关键字的B树的高度达到最大。第一层至少有1个结点；第二层至少有2个结点；除根节点外的每个非叶结点至少有[m&#x2F;2]棵子树，则第三层至少有2[m&#x2F;2]个结点……..第h+1层至少有$2([m&#x2F;2])^{h-1}$个结点，注意到第h+1层是不包含任何信息的叶结点。对于关键字个数为n的B树，叶结点的个数为n+1，由此有$n+1\geq 2([m-2])^{h-1}$，即$h\leq \log_{[m&#x2F;2]}((n+1)&#x2F;2)+1$。</p></li></ol><h5 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h5><p>B树的插入有以下步骤：</p><ol><li>定位。利用B树的查找算法（查找和二叉查找树基本一致），找出插入该关键字的最底层中的某个非叶结点（在B树种查找key时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的位置。<strong>注意：插入位置一定是最底层中的某个非叶结点</strong>）。</li><li>插入。在B树种，每个非失败结点的关键字个数都在区间$[[m&#x2F;2]-1,m-1]$内。插入后的关键字个数小于m，可直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于m-1时，必须对结点进行分裂。</li></ol><p>分裂的方法是：取一个新结点，在插入key后原结点中，右部分包含的关键字放到新结点中，中间位置([m&#x2F;2])的结点插入原结点的父节点。若此时导致父节点关键字个数也超过上限，则继续分裂操作。</p><p>例：</p><p>在5阶B树中，如图3-3，已经插入<code>&#123;25,38,49,60&#125;</code>，后再想插入80，则要进行分裂操作。</p><p><img src="https://img-blog.csdnimg.cn/967acf408d1842d59dc399beecd5069e.png" alt="3-3"></p><p><img src="https://img-blog.csdnimg.cn/adc4769298ba48d6bf15c96c3315ec31.png" alt="3-4"></p><p>如图3-4所示中间49关键字为第[m&#x2F;2]个结点就作为原结点的父节点，右结点包含的关键字就放到新结点中。</p><p>再一个例子：</p><p><img src="https://img-blog.csdnimg.cn/f01297e31f2c4ee9872474fbd4b704cd.png" alt="3-5"></p><p>若在图3-5中插入75则会导致需要B树在此进行分裂，此时就应该将73关键字放到父节点中。</p><p><img src="https://img-blog.csdnimg.cn/fec31e49627f4122b90f59580b0f55ee.png" alt="3-6"></p><p>此时就会导致父节点的关键字也超过了m-1个，需要再次进行分裂。</p><p><img src="https://img-blog.csdnimg.cn/2c16cdad5bb84f67a05e6088c6f9cb88.png" alt="3-7"></p><p>最后就会让第[m&#x2F;2]个关键字成为根结点中唯一的关键字。</p><h5 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h5><p>B树的删除要使删除后的结点中的$关键字个数\geq [m&#x2F;2]-1$，因此将涉及结点的合并问题。</p><p>当被删关键字k不在终端结点（最底层的非叶结点）中时，可以用k的前驱（或后继）k’来替代k，然后在相应的结点中删除k’，关键字k’必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/128afe53fc1640a9bfcd7955aefbe9f6.png" alt="3-8"></p><p>若要删除80，则需要用直接前驱或直接后继来替代80的位置，此时80的直接前驱为77，所以就用77来替代80。</p><p><img src="https://img-blog.csdnimg.cn/682b107d8e644eca9e3bb07ff9d50c64.png" alt="3-9"></p><p>此时就把非终端结点删除转换成了对终端节点的删除操作（直接后继同理）。</p><p>当被删关键字在终端结点中时，有下列三种情况：</p><ol><li><p>直接删除关键字。若被删关键字所在结点的$关键字个数\geq [m&#x2F;2]$，表明删除该关键字后仍满足B树的定义，则直接删去该关键字。</p></li><li><p>兄弟够借。若被删关键字所在结点删除前的关键字个数&#x3D;[m&#x2F;2]-1，且与该结点相邻的右（或左）兄弟结点的关键字个数$\geq[m&#x2F;2]$，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到平衡。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/37e8fe05526f4a188a711c6bd2f0d513.png" alt="3-10"></p><p>若要删除图3-10的第38个关键字。此时会导致结点<strong>低于下限[m&#x2F;2]<strong>，所以需要向兄弟结点</strong>借关键字</strong>，但不能直接将70移到38所在的结点中，会导致不满足B树的定义，所以需要将父结点的49移到38所在的结点中，再将70移到父节点中，就会产生下图3-11。</p><p><img src="https://img-blog.csdnimg.cn/03d4d860deae445bba0d00559751d1a0.png" alt="3-11"></p><p>此时再次满足B树的定义。</p></li><li><p>兄弟不够借。若被删关键字所在结点删除前的关键字个数&#x3D;[m&#x2F;2]-1，且此时该结点与相邻的左、右兄弟结点的关键字个数均&#x3D;[m&#x2F;2]-1，则将关键字删除后和左（或右）兄弟结点及双亲结点中的关键字进行合并。</p></li></ol><p>例：</p><p><img src="https://img-blog.csdnimg.cn/40abf861dcee4e6fbcf370dd46e047e6.png" alt="3-12"></p><p>若要删除图3-12中4+关键字，会导致49所在结点结点个数小于[m&#x2F;2]，而此时右兄弟同样关键字也不够填补，则需要进行合并操作，即将右兄弟结点合并，并将父节点中所指向这两结点的关键字一并合并到其中，如图3-13。</p><p><img src="https://img-blog.csdnimg.cn/87f240c591d24cefb9a07bdec900d651.png" alt="3-13"></p><p>而此时又导致父节点的关键字也不满足B树的定义，则需要对父节点也进行合并，即得到图3-14。</p><p><img src="https://img-blog.csdnimg.cn/627ffd6c2460444595ee0b47b561f4f0.png" alt="3-14"></p><p>此时根结点中没有任何关键字，则可进行删除，得到最终结果：</p><p><img src="https://img-blog.csdnimg.cn/db3b63b5ceff46b8b1c8f01a547aa48d.png" alt="3-15"></p><h4 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B+树的基本概念"></a>B+树的基本概念</h4><p>B+树是应数据库所需而出现的一种B树的变形树，如图3-16。</p><p>一棵m阶的B+树需满足下列条件：</p><ol><li>每个分支结点最多有m棵子树（孩子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有[m&#x2F;2]棵子树。</li><li><strong>结点的子树个数与关键字个数相等</strong>。</li><li>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互连接起来（支持顺序查找）。</li><li>所有<strong>分支结点</strong>（可视为索引的索引）中包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子节点的指针。</li></ol><p><img src="https://img-blog.csdnimg.cn/c4c69ea38c4142c2bb796f1ca962fbe9.png" alt="3-16"></p><p><strong>m阶的B+树和m阶的B树的主要差异：</strong></p><ol><li>在B+树中，具有n个关键字的结点只含有<strong>n棵子树</strong>，即每个关键字对应一棵子树；而在B树种，具有n个关键字的结点含有<strong>n+1棵子树</strong>。</li><li>在B+树中，每个结点的关键字个数n的范围是$[m&#x2F;2]\leq n \leq m(而根结点:1\leq n\leq m)$；而在B树种，每个结点（非根内部结点）的关键字个数n的范围是$[m&#x2F;2]-1\leq n \leq m-1(根结点:1\leq n \leq m-1)$。</li><li>在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。</li><li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用。而在B树中，叶结点和非叶结点均包含信息。</li></ol><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h4 id="散列表的基本概念"><a href="#散列表的基本概念" class="headerlink" title="散列表的基本概念"></a>散列表的基本概念</h4><blockquote><p>散列表（哈希表， Hash Table）：是一种可以根据数据元素的关键字计算出它在散列表的存储地址。</p><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)&#x3D;Addr(这里的地址可以是数组下标、索引或内存地址等)。</p></blockquote><p>例：</p><p><img src="https://img-blog.csdnimg.cn/74dadcd8764a48cd994f902ccb3a09c2.png" alt="4-1"></p><p>若想将19、14、23插入到散列表中，需要将值代入到散列函数，即<code>19%13=6</code>插入到6的位置，<code>14%13=1</code>插入到1的位置，<code>23%13=10</code>插入到10的位置。</p><p><img src="https://img-blog.csdnimg.cn/d6a44cb300d348ac90e3d0ecbe0b68c9.png" alt="4-2"></p><p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这样发生碰撞的不同关键字称为同义词。</p><h4 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h4><p>在构造散列函数时（核心目标：尽量减少冲突），需注意以下几点：</p><ol><li>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li><li>散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。</li><li>散列函数应尽量简单，能够在较短的时间内计算出任意一个关键字对应的散列地址。</li></ol><h5 id="常用的散列函数构造方法"><a href="#常用的散列函数构造方法" class="headerlink" title="常用的散列函数构造方法"></a>常用的散列函数构造方法</h5><p><strong>除留余数法—H（key）&#x3D; key % p</strong>：</p><p>设散列表表长为m，取一个不大于m但最接近或等于m的质数p</p><p>注：质数又称素数。指除了1和此整数自身外，不能被其他自然数整除的数。</p><p><strong>适用场景：关键字是整数即可。</strong></p><p><strong>直接定址法—H（key）&#x3D; key 或 H（key）&#x3D; a*key + b</strong>：</p><p>其中，a和b是常数。这种方法计算最简单，且不会产生冲突。若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p><p><strong>适用场景：关键字分布基本连续。</strong></p><p><strong>数字分析法—选取数码分布较为均匀的若干位作为散列地址</strong></p><p>设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选区数码分布较为均匀的若干位作为散列地址。</p><p><strong>适用场景：关键字集合已知，且关键字的某几个数码位分布均匀</strong></p><p><strong>平方取中法—取关键字的平方值的中间几位作为散列地址</strong></p><p>这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀。</p><p><strong>适用场景：关键字的每位取值都不够均匀。</strong></p><h4 id="散列表处理冲突的方法"><a href="#散列表处理冲突的方法" class="headerlink" title="散列表处理冲突的方法"></a>散列表处理冲突的方法</h4><h5 id="拉链法（链接法，chaining）"><a href="#拉链法（链接法，chaining）" class="headerlink" title="拉链法（链接法，chaining）"></a>拉链法（链接法，chaining）</h5><p>把所有“同义词”存储在一个链表中。</p><p>散列表（拉链法解决冲突）插入一个新元素：</p><ol><li>结合散列函数计算新元素的散列地址。</li><li>将新元素插入散列地址对应的链表（可用头插法，也可用尾插法）。</li></ol><p>例：</p><p>若散列表长度为13，散列函数H（key） &#x3D; key % 13，当列表中已经插入14,19,23。</p><p><img src="https://img-blog.csdnimg.cn/04ebb3b4e0534b1cadbcbd32c9dcab8a.png" alt="4-3"></p><p>而此时若想再插入1时，必定会和14冲突。所以则需要将14和1以链表形式连接（默认使用头插法）。</p><p><img src="https://img-blog.csdnimg.cn/58d5044b660e4b4e95e333ed5a952bd2.png" alt="4-4"></p><p>根据拉链法，再将<code>&#123;68,20,84,27,55,11,10,79&#125;</code>都插入到散列表中，即有：</p><p><img src="https://img-blog.csdnimg.cn/eefcc627b1fc4ad583f696a3b1e5a02f.png" alt="4-5"></p><p><strong>散列表拉链法查找操作</strong></p><p>若以图4-5来查找27，则会先通过散列函数H（key） &#x3D; key % 13来搜寻到目标元素存储地址：<code>27%13=1</code>，后再通过链表来搜寻到目标元素。</p><p><img src="https://img-blog.csdnimg.cn/f53c5aa4890747b28f923a11708cdf0a.png" alt="4-6"></p><p>删除和查找操作几乎相同就不再赘述。</p><h5 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h5><p>开放地址法是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。</p><p>如果发生“冲突”，就给新元素找另一个空闲位置。发生第i次冲突时，数学递推公式：<br>$$<br>H_i&#x3D;(H(key)+d_i)%m<br>$$<br>$H_i$：发生第i次冲突时的散列地址；H(key)：初始散列地址；$d_i$：偏移量；m：散列表表长。（**注：$0\leq i \leq m-1 $**）</p><p>四种常用构造探测序列$d_i$的方法：</p><ol><li><p><strong>线性探测法</strong></p><p>线性探测法就是按从左到右的顺序进行探测，当个发生冲突时，顺序查看表中下一个单元（探测到表尾m-1时，下一个探测地址是表首0），直到找到一个空闲单元。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/b18311d524a2473bb8dbf9ac44cd90d0.png" alt="4-7"></p><p>图4-7中若根据散列函数$H(key)&#x3D;key%13$，插入元素1为第地址1的位置，此时和14冲突，根据线性探测法从左往右查找到4号地址为空闲，则插入到4号地址中。</p></li><li><p><strong>平方探测法</strong></p><p>当$d_i&#x3D;0^2,1^2,-1^2,\dots,k^2,-k^2$时，称为平方探测法，其中$k\leq m&#x2F;2$，散列表长度m必须是一个可以表示成4k+3的素数，又称二次探测法。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/d5c8e35b9cd94d39a107a8846255497f.png" alt="4-8"></p><p>根据散列函数$H(key)&#x3D;key%13$，插入元素1为第地址1的位置，此时和14冲突，根据平方探测法（以此时要查找的单元为基准进行探测），先探测$1^2$位置，有元素2，则探测$-1^2$的位置，有元素13，后再探测$2^2$，为空单元，则将元素1放入其中。</p></li><li><p><strong>双散列法</strong></p><p>当$d_i&#x3D;Hash_2(key)$时，称为双散列法。需要使用两个散列函数，当通过第一个散列函数$H(key)$发生冲突时，则利用第二个散列函数$Hash_2(key)$计算该关键字的地址增量。具体形式如下：<br>$$<br>H_i&#x3D;(H(key)+i\times Hash_2(key))% m<br>$$</p></li><li><p><strong>伪随机序列法</strong></p></li></ol><p>​当$d_i&#x3D;伪随机数序列$时，称为伪随机法，伪随机序列为人为设计的序列。</p><p><strong>注：在开放定址的情况下，删除元素应该逻辑删除，而非物理删除，即删除一个元素可给flag来标记已经删除，而真实物理内存中并没有删除此元素，以至于下次查找不会出错。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复变函数-相关公式</title>
      <link href="/2023/10/19/fu-bian-han-shu-fu-shu-yu-fu-bian-han-shu/"/>
      <url>/2023/10/19/fu-bian-han-shu-fu-shu-yu-fu-bian-han-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="复数的基本概念"><a href="#复数的基本概念" class="headerlink" title="复数的基本概念"></a>复数的基本概念</h4><p>将$$z&#x3D;x+iy$$的数称为复数，其中i称为<strong>虚数单位</strong>，并规定$$i^2&#x3D;-1$$，或$$i&#x3D;\sqrt{-1}$$；x和y是任意实数，依次称为z的实部（real part）与虚部（imaginary part），分别表示：<br>$$<br>Re z&#x3D;x\quad Imz&#x3D;y<br>$$<br>例：$$z&#x3D;\sqrt{2}+i$$，有<br>$$<br>Re z&#x3D;\sqrt{2}\quad Imz&#x3D;1<br>$$<br>设$$z&#x3D;x+iy$$是一个复数，而称$$x-iy$$为z的<strong>共轭复数</strong>，记作$$\overline{z}$$，可得$$\overline{\overline{z}}&#x3D;z$$。</p><h4 id="复数的四则运算"><a href="#复数的四则运算" class="headerlink" title="复数的四则运算"></a>复数的四则运算</h4><p>设$$z_1&#x3D;x_1+iy_1$$，$$z_2&#x3D;x_2+iy_2$$。</p><p><strong>加法：</strong><br>$$<br>z_1+z_2&#x3D;(x_1+x_2)+i(y_1+y_2)<br>$$<br><strong>减法：</strong><br>$$<br>z_1-z_2&#x3D;(x_1-x_2)+i(y_1-y_2)<br>$$<br><strong>乘法：</strong><br>$$<br>z_1\cdot z_2 &#x3D; (x_1x_2-y_1y_2) + i(x_1y_2+x_2y_1)<br>$$<br>乘法证明：<br>$$<br>z_1 \cdot z_2 &#x3D; (x_1+iy_1)(x_2+iy_2)\<br>&#x3D;x_1x_2+ix_1y_2+iy_1x_2+iiy_1y_2\&#x3D;(x_1x_2-y_1y_2) + i(x_1y_2+x_2y_1)<br>$$<br><strong>除法：</strong><br>$$<br>\frac{z_1}{z_2}&#x3D;\frac{x_1x_2+y_1y_2}{x_2^2+y_2^2}+i\frac{x_2y_1-x_1y_2}{x_2^2+y_2^2}<br>$$<br>除法证明通过分母有理化即可。</p><h4 id="共轭复数的性质"><a href="#共轭复数的性质" class="headerlink" title="共轭复数的性质"></a>共轭复数的性质</h4><p>$$<br>\overline{z_1\pm z_2}&#x3D;\overline{z_1}+\overline{z_2}<br>$$</p><p>证明：<br>$$<br>\overline{z_1\pm z_2} &#x3D; (x_1+x_2)-i(y_1+y_2)\<br>(x_1-iy_1)+(x_2-iy_2)\<br>&#x3D;\overline{z_1}+\overline{z_2}<br>$$<br>以此可得：<br>$$<br>\overline{z_1\cdot z_2}&#x3D;\overline{z_1}\cdot \overline{z_2}\\<br>\overline{\frac{z_1}{z_2}}&#x3D;\frac{\overline{z_1}}{\overline{z_2}}\\<br>\overline{\overline{z}}&#x3D;z\\<br>z\cdot \overline{z}&#x3D;x^2+y^2&#x3D;|z|^2\\<br>z+\overline{z}&#x3D;2x&#x3D;2Re(z)\\<br>z-\overline{z}&#x3D;i2y&#x3D;2iIm(z)<br>$$</p><h4 id="复数的几何意义"><a href="#复数的几何意义" class="headerlink" title="复数的几何意义"></a>复数的几何意义</h4><p>将横轴x上的点表示实数，纵轴y上的点表示纯虚数。整个坐标平面可称为复平面。</p><p>$$z&#x3D;x+iy$$向量表示，设OP是连接原点的一条线，则$$|z|&#x3D;|\vec{OP}|&#x3D;\sqrt{x^2+y^2}$$。</p><p><strong>复数的加减法可用向量的三角法则或平行四边形来表示。</strong></p><p>结论：</p><p>$$|z|&#x3D;|\overline{z}|$$</p><p>$$z\overline{z}&#x3D;|z|^2&#x3D;|\overline{z}|^2$$</p><p>$$|Re(x)|\leqslant |z|$$，$$|Im(y)|\leqslant |z|$$</p><p>$$|z_1+z_2|\leqslant |z_1|+|z_2|$$（两边之和大于第三边）</p><p>$$|z_1-z_2|\geqslant |z_1|+|z_2|$$（两边之差小于第三边）</p><h4 id="复数的模与辐角"><a href="#复数的模与辐角" class="headerlink" title="复数的模与辐角"></a>复数的模与辐角</h4><p><img src="https://img-blog.csdnimg.cn/60f7728674b2404d8490f2bda1e925c3.png"></p><p>将图中的θ叫做$$z&#x3D;x+iy$$的辐角，记作$$\theta &#x3D;Arg(z)$$（每个辐角相差$$2k\pi$$）</p><p>将$$-\pi &lt; \theta_0 \leq \pi$$范围的辐角称为辐角主值（辐角主值是唯一的）。</p><p>Argz的主值argz可由$$arctan\frac{y}{x}$$来确定。</p><p>情况讨论：</p><ol><li>$$x&gt;0,y&#x3D;0$$，实轴正向：$$argz&#x3D;0$$。</li><li>$$x&gt;0,y&gt;0$$，第一象限：$$argz&#x3D;arctan\frac{y}{x}$$</li><li>$$x&#x3D;0,y&gt;0$$，虚轴正向：$$argz&#x3D;\frac{\pi}{2}$$</li><li>$$x&lt;0,y&gt;0$$，第二象限：$$argz&#x3D;\pi+arctanx\frac{y}{x}$$</li><li>$$x&lt;0,y&#x3D;0$$，实轴负向：$$argz&#x3D;\pi$$</li><li>$$x&lt;0,y&lt;0$$，第三象限：$$argz&#x3D;arctanx\frac{y}{x}-\pi$$</li><li>$$x&#x3D;0,y&lt;0$$，虚轴负向：$$argz&#x3D;-\frac{\pi}{2}$$</li><li>$$x&gt;0,y&lt;0$$，第四象限：$$argz&#x3D;arctan\frac{y}{x}$$</li></ol><p><strong>三角表示法</strong>：</p><p>令$$|z|&#x3D;r，Argz&#x3D;\theta$$，则$$z&#x3D;rcos\theta + irsin\theta &#x3D;r(cos\theta+isin\theta)$$</p><p><strong>指数表示法：</strong></p><p>由欧拉公式$$e^{i\pi}+1&#x3D;0$$可得：$$z&#x3D;r(cos\theta+isin\theta)&#x3D;re^{i\theta}$$</p><h4 id="复数的乘幂与方根"><a href="#复数的乘幂与方根" class="headerlink" title="复数的乘幂与方根"></a>复数的乘幂与方根</h4><p>设$$z_1&#x3D;r_1e^{i\theta_1},z_2&#x3D;r_2e^{i\theta_2}$$，则</p><p>$$z_1\cdot z_2&#x3D;r_1\cdot r_2e^{i(\theta_1+\theta_2)}$$。</p><p>$$\frac{z_2}{z_1}&#x3D;\frac{r_2}{r_1}e^{i(\theta_2-\theta_1)}$$</p><p>$$z^n&#x3D;r^ne^{in\theta}$$</p><p>棣莫弗（De Moivre）公式：$$(cos\theta+isin\theta)^n&#x3D;cosn\theta+isinn\theta$$</p><p>z的n次方根：$$w^n&#x3D;z$$，令$$w&#x3D;P(cost+isint)$$，则$$P^n(cosnt+isinnt)&#x3D;r(cos\theta+isin\theta)$$。</p><p>则$$w&#x3D;r^{\frac{1}{n}}(cos\frac{\theta+2k\pi}{n}+isin\frac{\theta+2k\pi}{n})$$</p><h4 id="复变函数的极限"><a href="#复变函数的极限" class="headerlink" title="复变函数的极限"></a>复变函数的极限</h4><p>复变函数极限有类似于一元实函数的情况相同，因此有类似于实函数极限的性质。</p><p>如果$$\displaystyle \lim_{z \to z_0}{f(z)}&#x3D;A，\displaystyle \lim_{z \to z_0}{f(z)}&#x3D;B$$，则有：</p><p>$$\displaystyle \lim_{z \to z_0}{[f(z)\pm g(z)]}&#x3D;A\pm B$$</p><p>$$\displaystyle \lim_{z \to z_0}{[f(z)\cdot g(z)]}&#x3D;A\cdot B$$</p><p>$$\displaystyle \lim_{z \to z_0}{\frac{f(z)}{g(z)} }&#x3D;\frac{A}{B}$$</p><h4 id="复变函数的导数"><a href="#复变函数的导数" class="headerlink" title="复变函数的导数"></a>复变函数的导数</h4><p>$$f’(z_0)&#x3D; \displaystyle \lim_{\Delta z \to 0 }\frac{f(z_0+\Delta z) - f(z_0)}{\Delta z}$$</p><h5 id="判断函数是否可导"><a href="#判断函数是否可导" class="headerlink" title="判断函数是否可导"></a>判断函数是否可导</h5><p>要判断一个函数可导，还是利用定义判别。如果$$z+\Delta z$$沿着不同的路径趋向于z时，极限值不同，则该函数不可导。</p><p><strong>可导与连续</strong></p><p>f(z)在$z_0$处可导，在$z_0$处一定连续，反之不一定成立。</p><p>（导数和微分的概念和高数的一元函数差不多就不再赘述了。）</p><h4 id="解析函数的概念"><a href="#解析函数的概念" class="headerlink" title="解析函数的概念"></a>解析函数的概念</h4><h5 id="解析函数的性质"><a href="#解析函数的性质" class="headerlink" title="解析函数的性质"></a>解析函数的性质</h5><p>如果$w&#x3D;f(z)$在点$z_0$处及$z_0$的邻域内处处可导，则称在点$z_0$处解析。</p><p>如果$w&#x3D;f(z)$在区域D内处处解析，则称为解析函数。</p><p><strong>注：</strong>f(z)在$z_0$解析，可推出f(z)在$z_0$处可导，反之不一定。</p><h5 id="奇点的定义"><a href="#奇点的定义" class="headerlink" title="奇点的定义"></a>奇点的定义</h5><p>如果$w&#x3D;f(z)$在$z_0$处不解析，则称$z_0$为$w&#x3D;f(z)$的奇点。</p><h4 id="函数解析的充要条件"><a href="#函数解析的充要条件" class="headerlink" title="函数解析的充要条件"></a>函数解析的充要条件</h4><p>函数$f(z)&#x3D;u(x,y)+iv(x,y)$在$z&#x3D;x+iy$处可导的充要条件是$u(x,y),v(x,y)$在点$(x,y)$处可微即：<br>$$<br>\frac{\partial u}{\partial x} &#x3D; \frac{\partial v}{\partial y}\<br>\frac{\partial u}{\partial y} &#x3D; -\frac{\partial v}{\partial x}<br>$$<br>上述方程为柯西-黎曼方程（简称C-R方程）。</p><p>并提供了$f’(z)&#x3D;\frac{\partial u}{\partial x}+ i \frac{\partial v}{\partial x}&#x3D;\frac{\partial v}{\partial y}-i\frac{\partial u}{\partial y}$求导方法。</p><h5 id="判断函数在D是否可导、解析的基本步骤："><a href="#判断函数在D是否可导、解析的基本步骤：" class="headerlink" title="判断函数在D是否可导、解析的基本步骤："></a>判断函数在D是否可导、解析的基本步骤：</h5><p>求$u(x,y)、v(x,y)$的偏导，若满足C-R方程，则求$u(x,y)、v(x,y)$的偏导是否连续，若连续则为解析函数。</p><h4 id="解析函数和调和函数的关系"><a href="#解析函数和调和函数的关系" class="headerlink" title="解析函数和调和函数的关系"></a>解析函数和调和函数的关系</h4><h5 id="调和函数的概念"><a href="#调和函数的概念" class="headerlink" title="调和函数的概念"></a>调和函数的概念</h5><p>若二元实函数$\varphi(x,y)$在区域D内有二阶连续偏导数，且满足二维拉普拉斯（Laplace）方程：<br>$$<br>\frac{\partial^2\varphi}{\partial x^2}+\frac{\partial^2\varphi}{\partial y^2} &#x3D; 0<br>$$<br>则称$\varphi(x,y)$为区域D内的调和函数。</p><p>若函数$f(z)&#x3D;u(x,y)+iv(x,y)$在区域D内<strong>解析</strong>，则$f(z)$的实部$u(x,y)$和虚部$v(x,y)$都是区域D内的调和函数。</p><h5 id="共轭调和函数"><a href="#共轭调和函数" class="headerlink" title="共轭调和函数"></a>共轭调和函数</h5><p>设函数$\varphi(x,y)$及$\psi(x,y)$均为区域D内的调和函数，且函数C-R方程<br>$$<br>\frac{\partial \varphi}{\partial x} &#x3D; \frac{\partial \psi}{\partial y}\<br>\frac{\partial \varphi}{\partial y} &#x3D; -\frac{\partial \psi}{\partial x}<br>$$<br>则称$\psi$是$\varphi$的共轭调和函数。</p><p>复变函数$f(z)&#x3D;u(x,y)+iv(x,y)$在区域D内<strong>解析的充要条件</strong>是在区域D内，$f(z)$的虚部$v(x,y)$是实部$u(x,y)$的共轭调和函数。</p><p>注：<strong>u(x,y)不一定是v(x,y)的共轭调和函数</strong>。</p><h4 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h4><h5 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h5><p>对于复数$z&#x3D;x+iy$，称$w&#x3D;e^z&#x3D;e^{x+iy}&#x3D;e^xe^{iy}&#x3D;e^x(cosy+isiny)$为指数函数。对于任意的实数y有$e^{iy}&#x3D;cosy+isiny$这个式子即为欧拉公式。</p><p><strong>指数函数的性质</strong></p><ol><li>$e^z\neq0$</li><li>$e^{z_1}\cdot e^{z_2}&#x3D;e^{z_1+z_2}$</li><li>$e^{z+2k\pi i}&#x3D;e^z \cdot e^{2k\pi i}&#x3D;e^z$，周期$T&#x3D;2k\pi i$</li><li>e^z处处解析</li><li>$|e^z|&#x3D;|e^x(cosy+isiny)|&#x3D;e^x$，$Arg(e^z)&#x3D;2k\pi + y$</li></ol><h5 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h5><p>满足方程$w&#x3D;e^z(z\neq 0)$的函数$w&#x3D;f(z)$称为对数函数，记作$w&#x3D;Lnz$。</p><p>令$z&#x3D;re^{i\theta},w&#x3D;u+iv$，则$u&#x3D;lnr&#x3D;ln|z|,v&#x3D;Argz&#x3D;\theta+2k\pi$</p><p>从而有$Ln(z)&#x3D;ln|z|+i(2k\pi+arg(z))$。</p><p>Ln(z)为多值函数，每个值相差$2k\pi(k&#x3D;0,1,\dots)$</p><p><strong>对数函数的性质</strong></p><ol><li>$Ln(z_1\cdot z_2)&#x3D;Lnz_1+Lnz_2$</li><li>$Ln(\frac{z_1}{z_2})&#x3D;Lnz_1-Lnz_2$</li><li>$\frac{dlnz}{dz}&#x3D;\frac{1}{z}$</li></ol><h5 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h5><p>对于任意复数，当$z\neq 0$时，$w&#x3D;z^a&#x3D;e^{aLnz}$称为幂函数。</p><p>$Lnz$套对数函数然后解幂函数即可。</p><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>由欧拉公式可得$e^{iy}&#x3D;cosy+isiny,e^{-iy}&#x3D;cosy-isiny$，两式相加相减得：</p><p>$cosy&#x3D;\frac{1}{2}(e^{iy}+e^{-iy}),$</p><p>$siny&#x3D;\frac{1}{2i}(e^{iy}-e^{-iy}),$</p><p>将实数y改成z即可的复数形式的三角函数。</p><h3 id="复变函数的积分"><a href="#复变函数的积分" class="headerlink" title="复变函数的积分"></a>复变函数的积分</h3><p>复积分和第二类曲线积分有类似的性质<br>$$<br>\int_c f(z)dz&#x3D;-\int_c -f(z)dz \<br>\int_c kf(z)dz &#x3D; k\int_c f(z)dz\<br>\int_c [f(z)+g(z)]dz&#x3D;\int_c f(z)dz+\int_c g(z)dz\<br>c的长度为L,|f(z)|\leq M, 则|\int_c f(z)dz|\leq \int_c |f(z)|ds\leq M\int_c ds&#x3D;ML<br>$$</p><p>积分计算方法：</p><p>1.可以使用二元实变函数的线积分来计算：<br>$$<br>\int_c f(z)dz&#x3D;\int_c <a href="dx+idy">u(x,y)+ iv(x,y)</a>\&#x3D;\int_c (u(x,y)dx - v(x,y)dy) + i\int_c (u(x,y)dy+v(x,y)dx)<br>$$<br>令参数方程来进行计算：<br>$$<br>C&#x3D;\begin{cases}<br>x&#x3D;x(t) \<br>y&#x3D;t(t)<br>\end{cases} \quad 起点:t1 \quad 终点:t2\<br>$$<br>然后带入上方第一个式子中进行计算。</p><p><strong>通过复平面的直线表示方法：</strong></p><p>设$z_1&#x3D;x_1+iy_1\quad z_2&#x3D;x_2+iy_2$</p><ol><li><p>$z&#x3D;z_1+t(z_1-z_1)$</p></li><li><p>$$<br>C&#x3D;\begin{cases}<br>x&#x3D;x_1+t(x_2-x_1) \<br>y&#x3D;y_1+t(y_2-y_1)<br>\end{cases} \quad 起点:t_1 \quad 终点:t_2\<br>$$</p></li></ol><p>重要结论：<br>$$<br>\oint_c \frac{1}{(z-z_0)^{n+1}}dz ,其中C:|z-z_0|&#x3D;r,正向路径\<br>则：<br>\begin{cases}<br>2\pi i &amp; n&#x3D;0 \<br>0 &amp; n\neq 0<br>\end{cases}<br>$$</p><h4 id="柯西-古萨定理"><a href="#柯西-古萨定理" class="headerlink" title="柯西-古萨定理"></a>柯西-古萨定理</h4><p>若f(z)在<strong>单连通区域</strong>内处处解析，f(z)沿着区域内任一条封闭曲线C的积分为0，即：<br>$$<br>\oint_c f(z)dz&#x3D;0<br>$$</p><h4 id="复合闭路定理"><a href="#复合闭路定理" class="headerlink" title="复合闭路定理"></a>复合闭路定理</h4><h5 id="闭路变形定理"><a href="#闭路变形定理" class="headerlink" title="闭路变形定理"></a>闭路变形定理</h5><p>设f(z)在<strong>多联通区域D</strong>内解析，$C_1,C_2$为D内任意两边正向简单闭曲线，以C1与C2为边界的D2包含在D内，则<br>$$<br>\int_{C_1}f(z)dz&#x3D;\int_{c_2}f(z)dz<br>$$<br>解析函数沿着曲线的积分<strong>不因闭曲线的连续变化而变化</strong>。</p><h5 id="复合闭路定理-1"><a href="#复合闭路定理-1" class="headerlink" title="复合闭路定理"></a>复合闭路定理</h5><p>设C为多联通区域D内的简单闭曲线，$C_1,C_2\dots C_n$是C内的简单闭曲线，如下图所示，各个互不包含也互不相交，且以$C_1,C_2\dots C_n$为边界的区域都含与D。</p><p><img src="https://img-blog.csdnimg.cn/direct/f4aa679815b7402595e89f776b4652c5.png"></p><p>如果f(z)在D内解析，那么<br>$$<br>\oint_cf(z)dz&#x3D;\oint_{c_1}+\oint_{c_2}+\dots+\oint_{c_n}f(z)dz<br>$$</p><h3 id="原函数与不定积分"><a href="#原函数与不定积分" class="headerlink" title="原函数与不定积分"></a>原函数与不定积分</h3><p>两个主要定理：</p><ol><li><p>如果f(z)在单连通区域D内处处解析，那么积分$\int_cf(z)dz$与起点、终点有关，与连接起点、终点的路径C无关。</p><p><img src="https://img-blog.csdnimg.cn/direct/ddc23bd515124a268626dbdfdf5059fe.png"><br>$$<br>\int_{C_1}f(z)dz&#x3D;\int{C_2}f(z)dz&#x3D;\int^{z_1}<em>{z_0}f(z)dz<br>$$<br>此时上方式子可以写为（类似于高数的变上限积分）<br>$$<br>F(z)&#x3D;\int^{z}</em>{z_0}f(z)dz<br>$$</p></li><li><p>如果f(z)在单连通区域D内处处解析，$F(z)&#x3D;\int^{z}_{z_0}f(z)dz$必为D中的解析函数，且$F’(z)&#x3D;f(z)$</p></li></ol><p><strong>复变函数中原函数定义和实变函数相同</strong></p><h4 id="不变积分的定义"><a href="#不变积分的定义" class="headerlink" title="不变积分的定义"></a>不变积分的定义</h4><p>f(z)的原函数的一般表达式F(z)+C为f(z)的不定积分，记为<br>$$<br>\int f(z)dz&#x3D;F(z)+C<br>$$</p><p>如果f(z)在单连通区域D内处处解析，G(z)为f(z)的一个原函数，则有<br>$$<br>\int_{z_0}^{z_1}f(z)dz&#x3D;G(z_1)-G(z_0)<br>$$</p><h3 id="柯西积分公式"><a href="#柯西积分公式" class="headerlink" title="柯西积分公式"></a>柯西积分公式</h3><p>如果f(z)在D内处处解析，C为D内任一条正向简单闭曲线，且C的内部全含于D中，$z_0$为C内任一点，则<br>$$<br>f(z_0)&#x3D;\frac{1}{2\pi i}\oint_c\frac{f(z)}{z-z_0}dz<br>$$</p><h3 id="解析函数的高阶导数"><a href="#解析函数的高阶导数" class="headerlink" title="解析函数的高阶导数"></a>解析函数的高阶导数</h3><p>解析函数有高阶导数，其导数仍为解析函数。</p><p>其定义上与实变函数相同，且n阶导$f^{(n)}(z)$的可能形式是<br>$$<br>f^{(n)}(z)&#x3D;\frac{n!}{2\pi i} \oint_c\frac{f(\zeta)}{(\zeta-z)^{n+1}}d\zeta<br>$$<br>由上方又可变形得<br>$$<br>\oint_c\frac{f(\zeta)}{(\zeta-z)^{n+1}}d\zeta&#x3D;\frac{2\pi i}{n!}f^{(n)}(z)<br>$$</p><h3 id="复数项级数"><a href="#复数项级数" class="headerlink" title="复数项级数"></a>复数项级数</h3><h4 id="复数序列的极限"><a href="#复数序列的极限" class="headerlink" title="复数序列的极限"></a>复数序列的极限</h4><p>若任意给定的$\varepsilon&gt;0$，存在正整数N，使当n&gt;N时，总有$|z_n-z_0|&lt;\varepsilon$成立，则称复数序列${z_n}$收敛于复数z0，记作<br>$$<br>\lim_{n\rightarrow\infty}z_n&#x3D;z_0<br>$$<br>若${z_n}$不收敛于z0，则称级数发散。</p><p>设$z_0&#x3D;x_0+iy_0,z_n&#x3D;x_n+iy_n(n&#x3D;1,2,\dots)$，则<br>$$<br>\lim_{n\rightarrow\infty}z_n&#x3D;z_0<br>$$<br>的充要条件是<br>$$<br>\lim_{n\rightarrow\infty}x_n&#x3D;x_0,\lim_{n\rightarrow\infty}y_n&#x3D;y_0<br>$$</p><p>复数项级数中正项级数敛散性的判别法和高等数学基本一致就不再赘述。</p><h3 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h3><p>设$f_n{z}(n&#x3D;1,2,\dots)$为区域D内的函数，则称<br>$$<br>\sum^{\infty}_{n&#x3D;1}f_n(z)&#x3D;f_1(z)+f_2(z)+\dots f_n(z)+ \dots<br>$$<br>为区域D内复变函数项级数，前n项的和称为级数的部分和。</p><p>而形如<br>$$<br>\sum^{\infty}_{n&#x3D;0}C_n(z-z_0)^n<br>$$<br>的复函数项级数称为幂级数，其中$C_n(n&#x3D;0,1,2,\dots)$及$z_0$均为复常数。</p><p>幂级数收敛等公式定理与高数一致就不再赘述。</p><h3 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h3><p>复变函数展开成泰勒级数需在D内解析，若f(z)在D内有奇点，则<strong>d到最近一个奇点之间的距离d&#x3D;|a-z_0|内解析</strong></p><p>当<br>$$<br>z_0&#x3D;0,f(z)&#x3D;\sum^{\infty}_{n&#x3D;0}\frac{f^{(n)}(0)}{n!}z^n<br>$$<br>则就称为麦克劳林级数（麦克劳林级数和高数的内容一致）。</p><p>任何解析函数在一点的泰勒级数都唯一，就是幂级数。</p><h3 id="洛朗级数"><a href="#洛朗级数" class="headerlink" title="洛朗级数"></a>洛朗级数</h3><h4 id="双边幂级数"><a href="#双边幂级数" class="headerlink" title="双边幂级数"></a>双边幂级数</h4><p>将<br>$$<br>\sum^{+\infty}<em>{-\infty}C_nz^n&#x3D;\sum</em>{n&#x3D;-1}^{-\infty}C_nz^n+\sum^{+\infty}_{n&#x3D;0}<br>$$<br>称为双边幂级数，左边部分称为负幂级数，右边部分称为正幂级数。</p><p>仅当负幂级数和正幂级数同时收敛时双边幂级数才收敛。</p><p>设函数f(z)在圆环域$R_1&lt;|z-z_0|&lt;R_2$内处处解析，则f(z)一定能在此圆环域中展开为<br>$$<br>f(z)&#x3D;\sum^{+\infty}_{n&#x3D;-\infty}C_n(z-z_0)^n<br>$$<br>其中<br>$$<br>C_n&#x3D;\frac{1}{2\pi i}\oint_c\frac{f(\zeta)}{(\zeta-z_0)^{n+1}}d\zeta<br>$$<br>C为此圆环域内绕$z_0$的任一简单闭曲线。</p><p>若$C_n$中$z_0$是奇点，则$f^{(n)}(z_0)$不存在，</p><p>$C_n$中$z_0$不是奇点，则n为负数时，柯西积分定理不存在，所以$C_n$不能表示为$\frac{f^{(n)}(z_0)}{n!}$</p><p>洛朗级数在同一收敛环内唯一，单同一函数f(z)在不同的收敛环中有不同的洛朗级数。</p><h3 id="孤立奇点"><a href="#孤立奇点" class="headerlink" title="孤立奇点"></a>孤立奇点</h3><p>f(z)在$z_0$处不解析，但在$z_0$的某一个去心邻域0&lt;$|z-z_0|&lt;\delta$内处处解析，则称z0为f(z)的孤立奇点。</p><p>例：z&#x3D;0是函数$e^{\frac{1}{z}},\frac{sinz}{z}的孤立奇点。$</p><h4 id="可取奇点"><a href="#可取奇点" class="headerlink" title="可取奇点"></a>可取奇点</h4><p>若对一切n&lt;0有Cn&#x3D;0，则称z0是函数f(z)的可去奇点。若令$f(z_0)&#x3D;C_0$，就能得到在整个圆盘$|z-z_0|&lt;\delta$内解析的函数f(z)。</p><h3 id="留数"><a href="#留数" class="headerlink" title="留数"></a>留数</h3><p>若$z_0$为f(z)的孤立奇点，C为$z_0$去心邻域内一条绕C的封闭正向简单曲线，则称$\frac{1}{2\pi i}\oint_cf(z)dz$为f(z)在点$z_0$处的留数，记为$Res[f(z),z_0]$，即<br>$$<br>Res[f(z),z_0]&#x3D;C_{-1}<br>$$</p><h4 id="留数定理"><a href="#留数定理" class="headerlink" title="留数定理"></a>留数定理</h4><p>设函数f(z)在区域D内除有限个孤立奇点外处处解析，C是D内包围各奇点的一条正向简单闭曲线，那么<br>$$<br>\oint_cf(z)dz&#x3D;2\pi i\sum^n_{k&#x3D;1}Res[f(z),z_k]<br>$$</p><h4 id="留数的求法"><a href="#留数的求法" class="headerlink" title="留数的求法"></a>留数的求法</h4><p>若$z_0$为f(z)的一级极点，则<br>$$<br>Res[f(z),z_0] &#x3D; \lim_{z\rightarrow z_0}(z-z_0)f(z)<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 复变函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图</title>
      <link href="/2023/10/17/shu-ju-jie-gou-tu/"/>
      <url>/2023/10/17/shu-ju-jie-gou-tu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><h4 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h4><blockquote><p>图G（Graph）由顶点集V（Vertex）和边集E（Edge）组成，记为$$G&#x3D;(V,E)$$，其中V(G)表示图G中顶点的有限非空集：E（G）表示图G中顶点之间的关系（边）集合，如图1-1。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0a338af844154f359093b0e2f0da2120.png" alt="1-1"></p><p><strong>注：</strong></p><p>线性表可以是空表，树可以是空树，但图不能是空图。图可以没有边，但不能没有顶点。</p><h5 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h5><p>有向图就是点与点之间相互有方向之间的关系，若设v,w为顶点，而&lt;v,w&gt;为从顶点v到顶点w，则有向图中$$&lt;v,w&gt;\neq&lt;w,v&gt;$$。</p><p><img src="https://img-blog.csdnimg.cn/1bf9eed4f72f4fa0abf3c67e21fbe0c1.png" alt="1-2"></p><h5 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h5><p>在无向图中，若设v,w为顶点，而&lt;v,w&gt;为从顶点v到顶点w，则有$$&lt;v,w&gt;&#x3D;&lt;w,v&gt;$$。</p><h5 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h5><p>简单图就是满足以下条件的图：</p><ol><li>不存在重复边。</li><li>不存在顶点到自身的边</li></ol><p>多重图就是图中某两个结点的边数多余一条，又允许顶点通过同一条边和自己关联，则G为多重图。</p><p><img src="https://img-blog.csdnimg.cn/748889253e4c4db58cefb8fa4c02d076.png" alt="1-3"></p><h5 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h5><p>对于无向图：顶点v的度是指依附于该顶点的边的条数，记为TD（v）。</p><p>在具有n个顶点、e条边的无向图中，无向图的全部顶点度的和等于边数的2倍：<br>$$<br>\sum_{i&#x3D;1}^nTD(v_i)&#x3D;2e<br>$$<br>对于有向图：</p><p>入度是以顶点v为终点的有向边的数目，记为ID(v)。</p><p>出度是以顶点v为起点的有向边的数目，记为OD(v)。</p><p>顶点v的度等于其入度和出度之和，即$$TD(v)&#x3D;ID(v)+OD(v)$$。</p><p>在具有n个顶点、e条边的有向图中，<br>$$<br>\sum_{i&#x3D;1}^nID(v_i)&#x3D;\sum_{i&#x3D;1}^nOD(v_i)&#x3D;e<br>$$<br>即出度和入度的数量相等且等于边数。</p><h5 id="路径、回路、距离"><a href="#路径、回路、距离" class="headerlink" title="路径、回路、距离"></a>路径、回路、距离</h5><p>路径：顶点$$v_p$$到顶点$$v_q$$之间的一条路径是指顶点序列，在<strong>有向图中的路径也是有向的</strong>。</p><p>回路：第一个顶点和最后一个顶点相同的路径称为回路或环。</p><p>简单路径：在路径序列中，顶点不重复出现的路径。</p><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p><p>路径长度：路径上边的数目。</p><p>点到点距离：顶点u到到顶点v的<strong>最短路径</strong>称为u到v的距离，若不存在路径，则记路径为无穷。</p><h5 id="连通、连通图、强连通图"><a href="#连通、连通图、强连通图" class="headerlink" title="连通、连通图、强连通图"></a>连通、连通图、强连通图</h5><p>连通：</p><ul><li>无向图中若顶点v到w有路径存在，则v和w是<strong>连通</strong>。</li><li>有向图中，若顶点v到w和从w到v都有路径，则v和w是<strong>强连通</strong>。</li></ul><p>连通图：若任意两个顶点都是连通的，则称为连通图，否则为非连通图。</p><p>强连通图：若图中任意一对顶点都是强连通，则称图为强连通图。</p><p><strong>注：</strong></p><p>对于n个顶点的<strong>无向图</strong>G，</p><p>若G是连通图，则<strong>最少有n-1条边</strong>。</p><p>若G是非连通图，则<strong>最多</strong>可能有$$C_{n-1}^2$$条边。</p><p>对于n个顶点<strong>有向图</strong>G，</p><p>若G是强连通图，则<strong>最少</strong>有n条边（形成回路）。</p><h5 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h5><p>如图1-4所示，右图的图是左图的子集，即称为子图。</p><p><img src="https://img-blog.csdnimg.cn/73012102bf1b4223b52aebc393bfa115.png" alt="1-4"></p><p>而若有满足V(G’)&#x3D;V(G)的子图G’，则称其为G的生成子图，图1-5即为生成子图，相比原图少了些边。</p><p><img src="https://img-blog.csdnimg.cn/f975507e562d4152832726a575880aab.png" alt="1-5"></p><h5 id="连通分量、强连通分量、生成树、生成森林"><a href="#连通分量、强连通分量、生成树、生成森林" class="headerlink" title="连通分量、强连通分量、生成树、生成森林"></a>连通分量、强连通分量、生成树、生成森林</h5><p>无向图中的极大连图子图（子图必须连通，同时保留尽可能多的边）称为连通分量。</p><p>有向图中的极大强连通子图（子图必须强连通，同时保留尽可能多的边）称为有向图的强连通分量。</p><p>连通图的<strong>生成树</strong>是包含图中全部顶点的极小连通子图。</p><p>在<strong>非连通图</strong>中，连通分量的生成树构成了非连通图的生成森林。</p><h5 id="边的权、带权图-x2F-网"><a href="#边的权、带权图-x2F-网" class="headerlink" title="边的权、带权图&#x2F;网"></a>边的权、带权图&#x2F;网</h5><p>边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</p><p>带权图&#x2F;网：边上带有权值的图称为带权图，也称网。</p><p>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度。</p><h3 id="图的存储及基本操作"><a href="#图的存储及基本操作" class="headerlink" title="图的存储及基本操作"></a>图的存储及基本操作</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><blockquote><p>邻接矩阵存储就是用一个一维数组存储顶点的信息，用二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点的邻接关系的二维数组称邻接矩阵。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/fe553480607345dba6623b7a0ea6171f.png" alt="2-1"></p><p>图2-1右边的矩阵就是无向图使用邻接矩阵后所在内存中存储的结构。</p><p>获取某个结点的度只需对所在<strong>行或列</strong>进行遍历，获取到的<strong>非零元素总和</strong>即为结点的度。</p><p><img src="https://img-blog.csdnimg.cn/303960bab8c2422d90701c723c895a9b.png" alt="2-2"></p><p>图2-2是有向图用邻接矩阵后所在内存中存储的结构。</p><p>获取某个结点的<strong>出度</strong>是对所在<strong>行</strong>进行遍历获取非零元素总和，获取<strong>入度</strong>则是对所在<strong>列</strong>进行遍历获取非零元素总和。</p><p>邻接矩阵存储结构定义：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxVertexNum</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//顶点数目最大值</span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexType<span class="token punctuation">;</span> <span class="token comment">//顶点的数据类型</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> EdgeType<span class="token punctuation">;</span> <span class="token comment">//带权图中边上权值的数据类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  VertexType Vex<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//顶点表</span>  EdgeType Edge<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵，边表</span>  <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>  <span class="token comment">//图的当前顶点数和弧度</span><span class="token punctuation">&#125;</span>MGraph<span class="token punctuation">;</span></code></pre><h5 id="邻接矩阵存储法的特点"><a href="#邻接矩阵存储法的特点" class="headerlink" title="邻接矩阵存储法的特点"></a>邻接矩阵存储法的特点</h5><ol><li>无向图的邻接矩阵一定是一个对称矩阵且唯一。因此，在实际存储邻接矩阵只需存储上（或下）三角矩阵的元素。</li><li>对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是顶点i的度TD(v)。</li><li>对于有向图，邻接矩阵的第i行非零元素（或非∞元素）的个数正好是顶点i的出度OD(v)；第i列非零元素（或非∞元素）的个数正好是顶点i的入度ID(v)。</li><li>用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图有多少条边，则必须按行、按列对每个元素进行检测。</li><li>稠密图适合用邻接矩阵的存储表示。</li><li>设图G的邻接矩阵为A，$$A^n$$的元素$$A^n[i][j]$$等于顶点i到顶点j的长度为n的路径数目。</li></ol><h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><p>邻接表法结合了顺序存储和链式存储，可以减少使用邻接矩阵对空间的浪费。</p><p>邻接表法是将图中的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点v的边（对于有向图则是以顶点v为尾的弧），这个单链表就称为顶点v的边表。</p><p><img src="https://img-blog.csdnimg.cn/b1be519cd2ac4970bbb14a495b1951ea.png" alt="2-3"></p><p>图邻接表的存储结构：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxVertexNum</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//顶点数目最大值</span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexType<span class="token punctuation">;</span> <span class="token comment">//顶点的数据类型</span><span class="token comment">//边表的结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ArcNode</span><span class="token punctuation">&#123;</span> <span class="token comment">//边表结点</span>  <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span> <span class="token comment">//该弧所指向的顶点的位置</span>  <span class="token keyword">struct</span> <span class="token class-name">ArcNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指向下一条弧的指针</span>  <span class="token comment">//InfoType info; //网的边权值</span><span class="token punctuation">&#125;</span>ArcNode<span class="token punctuation">;</span><span class="token comment">//图的各个结点的结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">VNode</span><span class="token punctuation">&#123;</span>  <span class="token comment">//顶点表结点</span>  VertexType data<span class="token punctuation">;</span>  <span class="token comment">//顶点信息</span>  ArcNode <span class="token operator">*</span>first<span class="token punctuation">;</span>  <span class="token comment">//指向第一条依附该顶点的弧的指针</span><span class="token punctuation">&#125;</span>VNode<span class="token punctuation">,</span> AdjList<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//此为图创建</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  AdjList vertices<span class="token punctuation">;</span>  <span class="token comment">//邻接表</span>  <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span> <span class="token comment">//图的顶点数和弧数</span><span class="token punctuation">&#125;</span>ALGraph<span class="token punctuation">;</span>  <span class="token comment">//是以邻接表存储的图类型</span></code></pre><h5 id="邻接表法的特点"><a href="#邻接表法的特点" class="headerlink" title="邻接表法的特点"></a>邻接表法的特点</h5><ol><li>若图为无向图，则所需存储空间为O(|V|+2|E|)；若G为有向图，则所需存储空间为O(|V|+|E|)。前者的倍数是2是由于每条边在邻接表中出现了两次。</li><li>对于稀疏图，采用邻接表可以极大地节省存储空间。</li><li>在邻接表中，给一顶点可以很容易找出它的邻边，因为只需读取它的邻接表即可。而对于有向图，邻接表查结点的入度不如邻接矩阵来的快。</li><li>图的邻接表表示并不唯一，它取决于建立邻接表的算法及边的输入次序。</li></ol><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><blockquote><p>十字链表是有向图的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点，如图所示。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2b369372ff5d4b04ab644f3ad5c3ab53.png" alt="2-4"></p><p><img src="https://img-blog.csdnimg.cn/77578121c61a4679a037f2e9bb5da89b.png" alt="2-5"></p><p>顺着<code>firstin</code>可以找到该结点所有的入边，顺着<code>firstout</code>可以找到该结点所有的出边。</p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><blockquote><p>邻接多重表是无向图的另一种链式存储结构。</p><p>在邻接表中，容易求得顶点和边的各种信息，而执行删除和求两个顶点之间是否存在边等操作时效率较低。所以就采用邻接多重表来解决，结构如图所示。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/9b2445fc6e884f5490b851282bac5d67.png" alt="2-6"></p><p><img src="https://img-blog.csdnimg.cn/bc41045d3f0c40c7b38fc280cabda8eb.png" alt="2-7"></p><p>邻接多重表可以根据所对应的顶点编号很快的找到顶点所有对应的边。</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h4><blockquote><p>广度优先的基本思想是：</p><p>先访问起始顶点v,接着由v出发，依次访问v的各个未访问过的顶点，然后依次通过这些顶点去访问其他没有访问过的顶点，直到所有顶点都被访问过为止。若图中有顶点尚未被访问，则重新从未被访问的顶点重复上述过程。</p></blockquote><p>广度优先遍历算法实现：</p><pre class="language-c" data-language="c"><code class="language-c">Queue Q<span class="token punctuation">;</span> <span class="token comment">//通过队列来安排访问顺序</span>bool visited<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//访问标记数组</span><span class="token keyword">void</span> <span class="token function">BFSTraverse</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//对图G进行广度优先遍历</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span> <span class="token comment">//将标记数组初始化，FALSE代表元素还未被访问</span>    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化辅助队列Q</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">//从0号顶点开始遍历</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//查看顶点是否被访问过</span>            <span class="token function">BFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将未被访问过的顶点进行遍历</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//从顶点v出发，广度优先遍历图G</span>    <span class="token function">visit</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问初始顶点v  visit()是一个函数，主要就是包含访问顶点要做的事</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>  <span class="token comment">//将访问过的顶点做已访问标记</span>    <span class="token function">Enqueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将顶点v入队列</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//若队列中有元素说明有需要遍历的顶点</span>        <span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遍历过后将顶点v出列接下来来检查顶点v周围是否有未被访问过的顶点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> w <span class="token operator">=</span> <span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> w <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">=</span> <span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//FirstNeighbor(G,v)用于获取图G中顶点v的第一个邻接点 NextNeighbor(G,v,w)是返回除w外的顶点v的下一个邻接点的顶点号 以此for循环就能检查与顶点v连接的所有邻接点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//w为v的邻接点中尚未访问过的顶点</span>                <span class="token function">visit</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//进行访问</span>                visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span> TRUE<span class="token punctuation">;</span><span class="token comment">//访问过后进行标记</span>                <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将顶点w入队，然后再次进行while循环时候就会访问w的邻接点相关信息</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>辅助数组<code>visited[]</code>标志顶点是否被访问过，初始状态为<code>FALSE</code>，一旦有顶点被访问就设置为<code>TRUE</code>，防止被多次访问</strong>。</p><h5 id="BFS算法性能分析"><a href="#BFS算法性能分析" class="headerlink" title="BFS算法性能分析"></a>BFS算法性能分析</h5><p>无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点均需入队一次，在最坏情况下，空间复杂度为O(|V|)。</p><p><strong>采用邻接表存储方式：</strong></p><p>每个顶点均需访问一次，所以时间复杂度为O(|V|)，而在访问任意顶点的邻接点时，每条边至少访问过一次，故时间复杂度为O(|E|)，总时间复杂度为O(|V|+|E|)。</p><p><strong>采用邻接矩阵存储方式：</strong></p><p>查找每个顶点的邻接点所需时间为O(|V|)，邻接点也是O(|V|)，所以总时间复杂度为$$O(|V|^2)$$。</p><h5 id="BFS算法求解单源最短路径问题"><a href="#BFS算法求解单源最短路径问题" class="headerlink" title="BFS算法求解单源最短路径问题"></a>BFS算法求解单源最短路径问题</h5><p>若图为非带权图，定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路径中最少的边数；若从u到v没有通路，则d(u,v)&#x3D;∞。</p><p><strong>BFS算法求解单源最短路径问题：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BFS_MIN_Distance</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//d[i]表示从u到i结点的最短路径</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>∞<span class="token punctuation">;</span><span class="token comment">//初始化路径长度</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">//对访问过的顶点进行标记 </span>    d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//设置路径长度为0</span>    <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将顶点u进行入队</span>    <span class="token comment">//BFS算法主过程</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//若队列中有元素说明有需要遍历的顶点</span>        <span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遍历过后将顶点v出列接下来来检查顶点v周围是否有未被访问过的顶点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> w <span class="token operator">=</span> <span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> w <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">=</span> <span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//w为v的邻接点中尚未访问过的顶点</span>                visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span> TRUE<span class="token punctuation">;</span><span class="token comment">//访问过后进行标记</span>                d<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>d<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//路径长度加1后再进行遍历</span>                <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将顶点w入队，然后再次进行while循环时候就会访问w的邻接点相关信息</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h5><p>在广度遍历过程中，可以得到一颗遍历树，就称为广度优先生成树，此树用邻接矩阵生成是唯一的，而用邻接表则是不唯一的。</p><p><img src="https://img-blog.csdnimg.cn/12dc169ca82a43cd91a5d52093a98cb7.png" alt="3-1"></p><p>如图3-1，若用邻接矩阵从2号顶点开始遍历生成树则是图3-3。</p><p><img src="https://img-blog.csdnimg.cn/ebbbd9e2456143298cca0b7f8959b0ca.png" alt="3-2"></p><p><img src="https://img-blog.csdnimg.cn/70d2ea9a71684d9b8257f203ed00bd02.png" alt="3-3"></p><p>而邻接表由于链表连接邻接点方式不唯一，所以生成树也是不唯一的。</p><h4 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h4><blockquote><p>深度优先遍历基本思想：</p><p>首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w，再访问w邻接且未被访问的任一顶点，以此重复。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至所有顶点均被访问过。</p></blockquote><p><strong>深度优先遍历算法实现：</strong></p><pre class="language-c" data-language="c"><code class="language-c">bool visited<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//标记访问数组</span><span class="token keyword">void</span> <span class="token function">DFSTraverse</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//对图G进行深度优先遍历</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> v<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>FALSE<span class="token punctuation">;</span><span class="token comment">//初始化已访问标记数组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> v<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span><span class="token comment">//进行图的深度优先遍历</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//若没被访问则进行访问</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//从顶点v出发，深度优先遍历图G</span>    <span class="token function">visit</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问顶点v</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>TRUE<span class="token punctuation">;</span><span class="token comment">//将已访问顶点进行标记</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token function">FistNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> w<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> w<span class="token operator">=</span><span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//w为v尚未访问的邻接顶点</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归往深度遍历</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="DPS算法性能分析"><a href="#DPS算法性能分析" class="headerlink" title="DPS算法性能分析"></a>DPS算法性能分析</h5><p>DFS算法作为一个递归算法要借助递归工作栈，故其空间复杂度为O(|V|)。</p><p><strong>邻接矩阵时间复杂度：</strong></p><p>以邻接矩阵表示时，与广度优先遍历同样需要遍历查找邻接点，故总的时间复杂度和广度优先遍历同为$$O(|V|^2)$$。</p><p><strong>邻接表时间复杂度：</strong></p><p>与广度优先遍历同样的搜索方式，且同为O(|V|+|E|)。</p><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><blockquote><p>对于一个带权连通无向图$G&#x3D;(V,E)$，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树。</p><ul><li>最小生成树可能由多个，但边的权值之和是唯一且最小的</li><li>最小生成树的边数&#x3D;顶点数-1</li></ul></blockquote><h5 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h5><p><strong>Prim算法</strong>:</p><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p><p><strong>Kruskal算法</strong></p><p>kruskal算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。</p><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><blockquote><p>解决无权图可以使用哦个广度优先搜索来解决最短路径问题，而对于带权图则需要另寻他法，即可分为：单源最短路径，即求图中某一顶点导其他各顶点的最短路径，可通过Dijkstra算法求解；二是求每对顶点间的最短路径，可通过Floyd算法求解。</p></blockquote><h5 id="Dijkstra算法求单源最短路径问题"><a href="#Dijkstra算法求单源最短路径问题" class="headerlink" title="Dijkstra算法求单源最短路径问题"></a>Dijkstra算法求单源最短路径问题</h5><p>单源指的就是单独一个源头，在Dijkstra算法中设置了一个集合S来记录已求得的最短路径的顶点，初始时把源头$v_0$放入到S，集合S每并入一个新顶点，都要修改源点$v_0$到集合S中顶点当前的最短路径长度值。</p><p>Dijkstra算法在构造的过程中还设置了两个辅助数组：</p><ul><li><code>dist[]</code>：记录从源头到其他各顶点的最短路径长度，若源头$v_0$到某个结点有路径，则<code>dist[i]</code>相应结点的位置标上路径长度，若源头到某个结点没有路径，则为∞。</li><li><code>path[]</code>：表示从源头到其他各顶点的最短路径前驱结点。在算法结束后，可根据其值追溯得到源点到其他顶点的最短路径。</li></ul><p><img src="https://img-blog.csdnimg.cn/16d50b061797473da55ac89190cf0216.png" alt="4-1"></p><p>上图以$v_0$为源头，$v_0$到自身的权值为0，到$v_1$的权值为10，到$v_2,v_3$目前没有路径则设置为∞，到$v_4$的路径权值为5，以此初始化<code>dist[]</code>。</p><p>路径前驱<code>path[]</code>则初始默认为-1，若与源头连接则设置为0。</p><p>Dijkstra算法开始时根据<code>final[]</code>数组，根据<code>final[]</code>值中为<code>false</code>且<code>dist[]</code>中目前权值最小的值来进行遍历搜索当前顶点未连接的结点，并将当前结点<code>final[]</code>中的值设置为<code>true</code>。</p><p><img src="https://img-blog.csdnimg.cn/a731219489f9435c97cf3fdcc2f5b5d3.png" alt="4-2"></p><p>如图4-2所示，当遍历$v_4$顶点时候，可以获得到顶点$v_1$比原先更短的路径长度8，并将<code>path</code>中的结点前驱改为4，而且获取了到$v_2,v_3$的路径长度14，7，并且结点前驱都为4。</p><p>后再进行遍历查询下一个除$v_4$以外<code>dist</code>中最短路径长度的$v_3$。并检查其他$v_1,v_2$这些尚未确定最短路径结点以$v_3$作为结点前驱会不会发生变化。</p><p><img src="https://img-blog.csdnimg.cn/eaa2c0ac2ebb42568832e983a618ecec.png" alt="4-3"></p><p>扫描$v_3$，显然到$v_2$经过$v_3$的路径长度13要小于从$v_4$直接到$v_2$的路径长度14，所以将$v_2$所对应的<code>dist</code>改为13，并将<code>path</code>直接前驱改为3。</p><p><img src="https://img-blog.csdnimg.cn/8b522325d9d54e569380b199dcfa0411.png" alt="4-4"></p><p>后再根据路径长度来扫描到$v_1$，而此时经过$v_1$到$v_2$的最短路径为5+3+1&#x3D;9，要小于原先的路径13，所以将$v_2$的<code>dist</code>设置为9，$path$为1。</p><p>最后$v_2$已经没有其他为false的顶点就直接设置为true即可。</p><p><strong>注：对于负权值带权图dijkstra算法可能失效！</strong></p><p><strong>Floyd算法求各顶点之间最短路径问题</strong></p><p>Floyd算法的基本思想是：递推产生一个n阶方阵序列$A^{(-1)},A^{(0)},\dots, A^{(n-1)}$，其中$A^{k}[i][j]$表示从顶点$v_i$到顶点$v_j$的路径长度，k表示绕行第k个顶点的运算步骤。</p><p><img src="https://img-blog.csdnimg.cn/8b54c206b43542b492aed0b11aaccd5b.png" alt="4-5"></p><p>若上图4-5允许在$v_0$中转，最短路径就是求$A^{(0)},path^{0}$，而所进行的就是对矩阵进行检查：<br>$$<br>若\quad A^{(-1)}[2][1]&gt;A^{(-1)}[2][0]+A^{(-1)}[0][1]&#x3D;11\<br>则\quad A^{(0)}[2][1]&#x3D;11\<br>\quad path^{(0))}[2][1]&#x3D;0<br>$$<br>进行以允许在$v_0$中转后，就可得到$v_2-&gt;v_1$的路径长度。</p><p><img src="https://img-blog.csdnimg.cn/39579ef2f6fd4ecea7054437d7fb497b.png" alt="4-6"></p><p>后再添加允许再$v_1$中转，此时对所有元素扫描后，只有$v_0-&gt;v_2$路径满足最短路径。由公式得：<br>$$<br>若\quad A^{(0)}[2][0]&gt;A^{(0)}[0][1]+A^{(0)}[1][2]&#x3D;10\<br>则\quad A^{(1)}[0][2]&#x3D;10\<br>\quad path^{(1))}[0][2]&#x3D;1<br>$$<br>即可得此时$v_0-&gt;v_2$的最短路径。</p><p><img src="https://img-blog.csdnimg.cn/2d5645d44f31476d8460b562ab482455.png" alt="4-7"></p><p>再允许$v_2$中转，此时对所有元素扫描后，只有$v_1-&gt;v_0$路径满足最短路径。由公式得：<br>$$<br>若\quad A^{(1)}[1][0]&gt;A^{(1)}[1][2]+A^{(1)}[2][0]&#x3D;9\<br>则\quad A^{(2)}[1][0]&#x3D;9\<br>\quad path^{(2))}[1][0]&#x3D;2<br>$$<br><img src="https://img-blog.csdnimg.cn/4900d86ad0fb47e58d724c20a6b56283.png" alt="4-8"></p><p>经过n论递推后得到图4-8，获得所有路径间的最短路径。</p><h4 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h4><blockquote><p>若一个有向图中部存在环路，则称为有向无环图，简称DAG图。</p></blockquote><p>有向无环图是描述含有公共子式的表达式的有效工具，例表达式：<code>((a+b)*(b*(c))+(c+d)*e)*((c+d)*e)</code>可以用下图的二叉树形式来表示：</p><p><img src="https://img-blog.csdnimg.cn/eb86fc4e43ae4e59a85fdd10ab7532c9.png" alt="4-9"></p><p>观察树或表达式，可以发现表达式<code>(c+d)</code>和<code>(c+d)*e</code>在二叉树中重复出现，即可利用有向无环图来实现相同子式的共享，从而节省存储空间。</p><p><img src="https://img-blog.csdnimg.cn/9a764df2543148f6916723af4c3f3d9c.png" alt="4-10"></p><p>利用有向无环图即可将图4-9的二叉树转换为图4-10的有向无环图。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><blockquote><p>AOV网：若用DAG图（有向无环图）表示一个工程，其顶点表示活动，用有向边$&lt;V_i,V_j&gt;$表示活动$V_i$必须先于活动$V_j$进行的一种关系，则将这种有向图称为顶点表示活动的网络，记为AOV网。</p><p>拓扑排序的概念：在图论中，由一个DAG图的顶点组成的序列且满足以下条件时，称为该图的拓扑排序：</p><ol><li>每个顶点出现且只出现一次。</li><li>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。</li></ol><p>拓扑排序通俗的讲就是找到每个顶点的先后顺序，然后根据先后进行排序即可。</p></blockquote><p>拓扑排序的实现：</p><ol><li>从AOV网中选择一个没有前驱（<strong>入度为0</strong>）的顶点并输出。</li><li>从网中删除该顶点和其他所有以它为起点的有向边。</li><li>重复1和2直到<strong>AOV网为空</strong>或当前<strong>网中部存在无前驱的顶点</strong>为止。</li></ol><p>拓扑排序算法实现（基于邻接表结构）：</p><pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">TopologicalSort</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化栈，存储入度为0的顶点</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//遍历图中的每个顶点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//若入度为0则入栈indegree[]用于记录每个顶点的入度为多少</span>            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录当前已经输出的顶点数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//栈不空，则存在入度为0的顶点，就进行遍历</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//栈顶元素出栈</span>        print<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//输出顶点iprint[]用于记录拓扑序列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>p<span class="token operator">=</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span> p<span class="token punctuation">;</span> p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//遍历该顶点邻接表相关的顶点</span>            v<span class="token operator">=</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">--</span>indegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//入度为0，则出栈</span>        <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>vexnum<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">//排序失败，有向图中有回路</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><blockquote><p>在带权有向图中，以<strong>顶点表示事件</strong>，以<strong>有向边表示活动</strong>，以<strong>边上的权值表示完成该活动的开销</strong>（如完成活动所需的时间），称之为用边表示活动的网络，简称<strong>AOE网</strong>（Activity On Edge NetWork）。</p><p>AOE网具有以下两个性质：</p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</li></ol><p>另外，有些活动是可以并行进行的。</p></blockquote><p>AOE网的概念：</p><ul><li>在AOE网中仅有一个入度为0的顶点，称为<strong>开始顶点（源点）</strong>。它表示整个工程的开始。</li><li>网中只存在一个出度为0的点，称为<strong>结束顶点（汇点）</strong>，它表示整个工程的结束。</li><li>从源点到汇点的有向路径可能有多条，而其中具有最大路径长度的路径称为<strong>关键路径</strong>，从而把关键路径上的活动称为<strong>关键活动</strong>。</li><li>事件$v_k$的最早发生时间$ve(k)$：决定了所有从$v_k$开始的活动能开工的最早时间。</li><li>活动$a_i$的最早开始时间$e(i)$：指该活动弧的起点所表示的事件的最早发生事件。</li><li>事件$v_k$的最迟发生事件$vl(k)$：指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</li><li>活动$a_i$的最迟开始时间$l(i)$：指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</li><li>活动$a_i$的时间余量$d(i)&#x3D;l(i)-e(i)$：表示在不增加完成整个工程所需总时间的情况下，活动$a_i$可以拖延的时间。</li><li>若一个活动的时间余量为零，则说明这活动$a_i$为<strong>关键活动</strong>。</li></ul><p>求关键路径的算法步骤：</p><ol><li>从源点出发，令$ve(源点)&#x3D;0$，按拓扑有序求所有时间的最早发生时间$ve()$。</li><li>从汇点出发，令$vl(汇点)&#x3D;ve(汇点)$，按逆拓扑有序求所有事件的最迟发生时间$vl()$。</li><li>求所有活动的最早发生时间$e()$。</li><li>求所有活动的最迟发生时间$l()$。</li><li>求所有活动的时间余量$d()$，而余量为0的就是关键活动，由关键活动可得关键路径。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路-电阻电路的等效变换</title>
      <link href="/2023/10/10/dian-lu-dian-zu-dian-lu-de-deng-xiao-bian-huan/"/>
      <url>/2023/10/10/dian-lu-dian-zu-dian-lu-de-deng-xiao-bian-huan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="电路的等效变换"><a href="#电路的等效变换" class="headerlink" title="电路的等效变换"></a>电路的等效变换</h3><blockquote><p>在了解电路的等效变换前先了解什么是电阻电路。</p><p>电阻电路就是仅由电源和线性电阻构成的电路。</p><p>分析方法：</p><ul><li>欧姆定律和基尔霍夫定律来分析。</li><li>等效变换的方法，也称化简。</li></ul></blockquote><p>电路的等效变换基于两端电路：两端电路即任何一个复杂的电路, 向外引出两个端钮，且从一个端子流入的电流等于从另一端子流出的电流，则称这一电路为二端网络 (或一端口网络)，如1-1所示。</p><p><img src="https://img-blog.csdnimg.cn/f00da5bbf95c4482bccf96f81f5abcfd.png" alt="1-1"></p><p><strong>两端电路等效的概念</strong></p><p>两个两端电路，端口具有相同的电压、电流关系,则称它们是等效的电路，即对于两个两端电路，他们电压和电流大小相同，参考方向也相同，即可将两个电路互相进行交换，并<strong>对外等效</strong>，如1-2图所示。</p><p><img src="https://img-blog.csdnimg.cn/6d0963c86d21419c9f5fad18a6bb6fe4.png" alt="1-2"></p><p><strong>电路等效变换的条件</strong></p><p>两电路具有相同的VCR，即电压电流电阻值相同即可等效变换。</p><h3 id="电阻的串联与并联"><a href="#电阻的串联与并联" class="headerlink" title="电阻的串联与并联"></a>电阻的串联与并联</h3><h4 id="电阻的串联"><a href="#电阻的串联" class="headerlink" title="电阻的串联"></a>电阻的串联</h4><blockquote><p>电阻串联的性质：</p><ol><li>电流相等，流过同一电流。</li><li>总电压等于各串联电阻的电压之和。</li><li>串联总电阻为电阻值相加。</li><li>电压之比等于电阻之比（串联分压）。</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/ffb51e3bd9eb40ea8f1bf3b12950a78a.png" alt="2-1"></p><h4 id="电阻的并联"><a href="#电阻的并联" class="headerlink" title="电阻的并联"></a>电阻的并联</h4><blockquote><p>电阻并联的性质：</p><ol><li>并联电路电压相等。</li><li>总电流等于各串联电阻的电流之和。</li><li>电流之比等于电阻的反比比（并联分流）。</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/61febf459ce44850882c8d937a4d4388.png" alt="2-2"></p><p>并联求总电阻公式：<br>$$<br>R_总 &#x3D;  \frac{1}{\frac{1}{R_1} + \frac{1}{R_2} + \dots + \frac{1}{R_n}}<br>$$</p><h3 id="电阻的Y形连接和∆形连接的等效变换"><a href="#电阻的Y形连接和∆形连接的等效变换" class="headerlink" title="电阻的Y形连接和∆形连接的等效变换"></a>电阻的Y形连接和∆形连接的等效变换</h3><p>Y形和∆形如图3-1和图3-2所示。</p><p><img src="https://img-blog.csdnimg.cn/7cdcbc5ba4e343559fe3b9b3e70f6937.png" alt="3-1"></p><p><img src="https://img-blog.csdnimg.cn/62150131e36041f3b938b1673a4215c4.png" alt="3-2"></p><h4 id="电阻的Y三角转换："><a href="#电阻的Y三角转换：" class="headerlink" title="电阻的Y三角转换："></a>电阻的Y三角转换：</h4><p><strong>从三角形变成Y形</strong></p><p>由图3-2转图3-1，电阻的等效变换可以变成对外等效，所以可以获得对外等效电阻的公式：<br>$$<br>R_1 &#x3D; \frac{R_{12}R_{31}}{R_{12}+R_{23}+R_{31}}\<br>R_2 &#x3D; \frac{R_{12}R_{23}}{R_{12}+R_{23}+R_{31}}\<br>R_3 &#x3D; \frac{R_{23}R_{31}}{R_{12}+R_{23}+R_{31}}\<br>$$<br><strong>Y形变成三角形</strong></p><p>由图3-1转图3-2，电阻的等效变换可以变成对外等效，所以可以获得对外等效电阻的公式：<br>$$<br>R_{12} &#x3D; \frac{R_{1}R_{2}+R_2R_3+R_3R_1}{R_3}\<br>R_{23} &#x3D; \frac{R_{1}R_{2}+R_2R_3+R_3R_1}{R_1}\<br>R_{31} &#x3D; \frac{R_{1}R_{2}+R_2R_3+R_3R_1}{R_2}\<br>$$</p><h3 id="电压源、电流源的串联和并联"><a href="#电压源、电流源的串联和并联" class="headerlink" title="电压源、电流源的串联和并联"></a>电压源、电流源的串联和并联</h3><h4 id="理想电压源"><a href="#理想电压源" class="headerlink" title="理想电压源"></a>理想电压源</h4><h5 id="串联情况"><a href="#串联情况" class="headerlink" title="串联情况"></a>串联情况</h5><p><img src="https://img-blog.csdnimg.cn/04988be94eb048bdbe0d4956b6c471bf.png" alt="4-1"></p><p>图4-1为n个电压源的串联（参考方向相同，若有些参考方向相反则前面为负号），可以用一个电压源等效替代，且这个等效电压源激励电压为：<br>$$<br>u_s &#x3D; u_{s1} + u_{s2} + \dots + u_{sn} &#x3D; \sum_{k&#x3D;1}^{n}{u_{sk}}<br>$$<br>理想电压源等效的电压源之值等于所有电压源的代数和。</p><h5 id="并联情况（仅当每个电压源电压相同）"><a href="#并联情况（仅当每个电压源电压相同）" class="headerlink" title="并联情况（仅当每个电压源电压相同）"></a>并联情况（仅当每个电压源电压相同）</h5><p><img src="https://img-blog.csdnimg.cn/7ed30ae4d3c7454fa0b4d9ee1386e8ed.png" alt="img"></p><h4 id="理想电流源"><a href="#理想电流源" class="headerlink" title="理想电流源"></a>理想电流源</h4><h5 id="并联情况"><a href="#并联情况" class="headerlink" title="并联情况"></a>并联情况</h5><p><img src="https://img-blog.csdnimg.cn/064f0552f2724f23888492a5fd04e759.png" alt="4-2"></p><p>图4-2为n个电压源的并联（参考方向相同，若有些参考方向相反则前面为负号），可以用一个电压源等效替代，且这个等效电压源电流为：<br>$$<br>i_s &#x3D; i_{s1} + i_{s2} + \dots + i_{sn} &#x3D; \sum_{k&#x3D;1}^ni_{sk}<br>$$<br>理想电流源等效的电流源之值等于所有电流源的代数和。</p><h5 id="串联情况-1"><a href="#串联情况-1" class="headerlink" title="串联情况"></a>串联情况</h5><p><img src="https://img-blog.csdnimg.cn/8f37b5748cb94722ba286a3859b64a66.png" alt="4-3"></p><p>串联情况下电流处处相等，所以可以等效为电流为i的电流源。</p><h4 id="实际电压源与电流源间的相互转换"><a href="#实际电压源与电流源间的相互转换" class="headerlink" title="实际电压源与电流源间的相互转换"></a>实际电压源与电流源间的相互转换</h4><blockquote><p>仅当电压源和电流源及电阻满足以下条件可进行相互转换：</p><ol><li>两种实际电源的内阻相同，及下图4-4中$$R_S&#x3D;G_S$$</li><li>电压源U与电流源I满足条件：$$U_S&#x3D;I_SR_S$$（电压源电压等于电流源电流及电流源的电阻）。</li><li>两种电源模型流出电流的方向相同。</li></ol></blockquote><h5 id="电压源变换为电流源"><a href="#电压源变换为电流源" class="headerlink" title="电压源变换为电流源"></a>电压源变换为电流源</h5><p><img src="https://img-blog.csdnimg.cn/49fdfbc4864146cf93ec9f2bf951d9fc.png" alt="4-4"></p><p>转换公式为：<br>$$<br>i_S &#x3D; \frac{u_S}{R_S} \quad G_S &#x3D; R_S<br>$$</p><h5 id="电流源变换为电压源"><a href="#电流源变换为电压源" class="headerlink" title="电流源变换为电压源"></a>电流源变换为电压源</h5><p><img src="https://img-blog.csdnimg.cn/dd4727e68a3645fe88c6c7f0590b944d.png" alt="4-5"></p><p>转换公式为：<br>$$<br>u_S &#x3D;i_SG_S \quad R_S &#x3D; G_S<br>$$<br><strong>无论电流源转电压源还是电压源转电流源，转换过后电压或电流方向都与原先的相反，流出的方向相同！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树与二叉树</title>
      <link href="/2023/10/07/shu-ju-jie-gou-shu-yu-er-cha-shu/"/>
      <url>/2023/10/07/shu-ju-jie-gou-shu-yu-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h3><blockquote><p>树的定义：树是一种递归定义的数据结构，它包含一个根结点和若干个子树。当树的结点数为0时，称为空树；当树的结点数大于0时，除了一个特定的根结点外，其余的结点被分成m个互不相交的有限集合T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/35b997fa91da4d86b5d64aba0e90fc5c.png" alt="1-1"></p><p><strong>非空树的特性</strong>：</p><ol><li>有且仅有一个根节点。</li><li>没有后继的结点称为“叶子结点”（或终端结点）。</li><li>有后继的结点称为“分支结点”（或非终端结点）。</li><li>除了根结点外，任何一个结点都<strong>有且仅有一个前驱结点</strong>。</li><li>每个结点可以有0个或多个后继结点。</li></ol><h4 id="树结点之间的关系描述"><a href="#树结点之间的关系描述" class="headerlink" title="树结点之间的关系描述"></a>树结点之间的关系描述</h4><p><img src="https://img-blog.csdnimg.cn/b5203633f41e4444af95925b2fde8639.png" alt="1-2"></p><p>根据1-2图可以得出结点之间的关系描述：</p><ol><li>祖先结点：对于”你”结点到”爷爷”结点都是祖先结点，即结点的所有前驱结点为祖先结点。</li><li>子孙结点：对于”爷爷”结点，所有后继结点都是子孙结点，即对于一个结点所有后继结点都是子孙结点。</li><li>双亲节点（父结点）：对于”你”结点，”父亲”结点即为父结点，即对于一个结点的<strong>直接前驱</strong>结点为父结点。</li><li>孩子结点：对于”父亲”结点来说，”你“结点与”F”结点都是”父亲”结点的孩子结点，即对于一个结点的<strong>直接后继</strong>结点。</li><li>兄弟结点：对于”你”结点来说，”F”结点即是兄弟结点，即对于一个结点同属于一个<strong>直接前驱</strong>结点的结点则为兄弟结点。</li><li>堂兄弟结点：对于”你”结点来说，“F”、“G”、“H”、“I”、“J”都是堂兄弟结点，即对于一个结点属于同一层的结点都为堂兄弟结点。</li><li>两个结点之间的路径（从上往下）与路径长度：对于”爷爷”结点到“你”结点即为一条路径，且路径长度为2，即对于一个结点向下搜寻到一个结点，且经过的边数为路径长度。</li></ol><h4 id="结点、树的属性描述"><a href="#结点、树的属性描述" class="headerlink" title="结点、树的属性描述"></a>结点、树的属性描述</h4><p><img src="https://img-blog.csdnimg.cn/60b311e5f24d400f98585710c10faeb6.png" alt="1-3"></p><p>根据1-3图可以得出结点、树的属性描述：</p><ol><li>结点的层次（默认从1开始）（深度）：从上往下数，可得图1-3的深度为4。</li><li>结点的高度：从下往上数，以E为基点，结点高度为2，若以B为基点，结点高度为3。</li><li>树的高度（深度）：总共的层数，可得图1-3树的高度为4。</li><li><strong>结点的度</strong>：根据有几个分支来定，若以B为基点，因有E，F两个分支，所以结点的度为2。以D为基点，有H，I，J三个分支，所以结点的度为3。</li><li><strong>树的度</strong>：各结点的度的最大值，1-3图中结点的最大的度也就3，所以树的度就是3。</li><li>有序树和无序数：有序树在逻辑上看，树中结点的各子树从左往右是<strong>有次序的</strong>，不能互换。如1-2图，交换位置会导致意思发生变化。无</li><li>无序树在逻辑上看，树中结点的各子树从左往右是<strong>无次序的</strong>，可以互换，如1-3图，交换后意义并不会受到任何影响。</li></ol><h4 id="森林与树的概念"><a href="#森林与树的概念" class="headerlink" title="森林与树的概念"></a>森林与树的概念</h4><p>森林。森林是m(m&gt;&#x3D;0)（m&#x3D;0则为空森林）棵互不相交的树的集合，如1-4所示。</p><p><img src="https://img-blog.csdnimg.cn/7c88ebce927749f2aa26b680f1740207.png" alt="1-4"></p><p>而将所有森林中的所有树上加上一个根结点，则会又变成一个树的整体，如1-5所示。</p><p><img src="https://img-blog.csdnimg.cn/39180ec6fc59407caffb53a996ded4c1.png" alt="1-5"></p><h4 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h4><ul><li><p>结点数 &#x3D; 总度数+1，<code>+1</code>是加上根节点。</p></li><li><h5 id="度为m的树与m叉树的区别："><a href="#度为m的树与m叉树的区别：" class="headerlink" title="度为m的树与m叉树的区别："></a>度为m的树与m叉树的区别：</h5></li></ul><table><thead><tr><th align="center">度为m的树 1-6所示</th><th align="center">m叉树     1-7所示</th></tr></thead><tbody><tr><td align="center">任意结点的度<code>&lt;=m</code>（最多m个结点）</td><td align="center">任意结点的度<code>&lt;=m</code>（最多m个结点）</td></tr><tr><td align="center">至少有一个结点度&#x3D;m（有某个结点有m个直接后继结点）</td><td align="center">允许所有结点的度都<code>&lt;m</code></td></tr><tr><td align="center">一定是非空树，至少有m+1个结点</td><td align="center">可以是空树</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/79069438912f489caf7de1285003de51.png" alt="1-6"></p><p><img src="https://img-blog.csdnimg.cn/99e238a3019745a99d195ef2ce4e44d7.png" alt="1-7"></p><h5 id="度为m的树第i层至多有-m-i-1-个结点-i-geqslant-1-，m叉树也同理"><a href="#度为m的树第i层至多有-m-i-1-个结点-i-geqslant-1-，m叉树也同理" class="headerlink" title="度为m的树第i层至多有$$m^{i-1}$$个结点$$i\geqslant 1$$，m叉树也同理"></a>度为m的树第i层至多有$$m^{i-1}$$个结点$$i\geqslant 1$$，m叉树也同理</h5><p><img src="https://img-blog.csdnimg.cn/cb95633542094aa6993689b3c5dcf923.png" alt="1-8"></p><p>如1-8所示，因为度为m的树的性质为一个基点结点最多有m个结点，所以若为度为1的树，则至多有$$m^0$$个结点，若度为2，则至多有$$m^2$$个结点，以此类推。</p><h5 id="高度为h的m叉树至多结点数"><a href="#高度为h的m叉树至多结点数" class="headerlink" title="高度为h的m叉树至多结点数"></a>高度为h的m叉树至多结点数</h5><p>计算公式（等比数列求和，公比为m）：<br>$$<br>\sum_{i&#x3D;0}^{h-1}{m^i}&#x3D;m^0 + m^1 + {\cdots} + m^{h-1} &#x3D; \frac{m^{h}-1}{m-1}<br>$$<br>研究了一段时间才发现以上所用的等比数列求和不是常用的而是另外一个，上方结果是根据后面的公式得出,等比求和公式(q为公比)：<br>$$<br>S&#x3D;\frac{a_1(1-q^n)}{1-q}&#x3D;\frac{a_nq-a_1}{q-1}<br>$$</p><h5 id="高度为h的m叉树至少结点数"><a href="#高度为h的m叉树至少结点数" class="headerlink" title="高度为h的m叉树至少结点数"></a>高度为h的m叉树至少结点数</h5><p>高度为h的<strong>m叉树</strong>至少有<strong>h</strong>个结点，即每个结点只有一个直接后继结点。</p><p>高度为h、度为m的<strong>树</strong>至少有<strong>h+m-1</strong>个结点，由于度为m的树至少有一个结点的直接后继有m个，所以让其他结点都只有一个直接后继结点，加上有一个为m的结点然后再减去1即可得出。</p><p><img src="https://img-blog.csdnimg.cn/3cae2722e40b430b860dd8ebe30a09a6.png" alt="1-9"></p><h5 id="具有n个结点的m叉树的最小高度"><a href="#具有n个结点的m叉树的最小高度" class="headerlink" title="具有n个结点的m叉树的最小高度"></a>具有n个结点的m叉树的最小高度</h5><p>具有n个结点的m叉树的最小高度$$\log_m(n(m-1)+1)$$。</p><p>高度最小的情况–所有结点都有m个孩子，假设m叉树的高度为h，但没到最大结点树，可得公式：<br>$$<br>\frac{m^{h-1}-1}{m-1}&lt;n\leqslant \frac{m^h-1}{m-1}<br>$$<br>同乘$$m-1$$，并同时$$+1$$得：<br>$$<br>m^{h-1}&lt;n(m-1)+1\leqslant m^h<br>$$<br>对等式同时取对数$$\log_m$$得：<br>$$<br>h-1&lt;\log_m(n(m-1)+1)\leqslant h<br>$$<br>所以对中间取整就可得m叉树的最小高度：<br>$$<br>h_{min} &#x3D; \lceil \log_m(n(m-1)+1) \rceil<br>$$</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h4><blockquote><p>二叉树是n（$$n\geqslant 0$$）个结点的有限集合：</p><ol><li>或者为空二叉树，即n&#x3D;0。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树。</li></ol><p>二叉树特点：每个结点至多有两颗子树，左右子树不能颠倒（二叉树是<strong>有序树</strong>）。</p></blockquote><h4 id="几个特殊的二叉树"><a href="#几个特殊的二叉树" class="headerlink" title="几个特殊的二叉树"></a>几个特殊的二叉树</h4><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><blockquote><p>一颗高度为h，且含有$$2^h-1$$个结点的二叉树，即每个子树都有两个子分支。如图2-1所示</p></blockquote><p><img src="https://img-blog.csdnimg.cn/200ae2c982344c4999fb0637f45cc584.png" alt="2-1"></p><p><strong>特点</strong>：</p><ul><li>只有最后一层有叶子结点</li><li>不存在度为1的结点</li><li>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1，结点i的父节点为[i&#x2F;2]（<code>[]</code>为取整符号），即结点7的左孩子为2i&#x3D;14，右孩子为2i+1&#x3D;15，而父节点为[i&#x2F;2]&#x3D;3。</li></ul><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><blockquote><p>当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点意义对应时，即可删除编号最后几位的结点，但最后一层仍然能从左往右编号且中间不会出现空结点，称为完全二叉树，<strong>若完全二叉树某结点只有一个后继结点那一定是左后继结点</strong>。如图2-2所示</p></blockquote><p><img src="https://img-blog.csdnimg.cn/e00797b9af564adeb0c83dbce022aad1.png" alt="2-2"></p><p><strong>特点</strong>：</p><ul><li>只有最后两层可能有叶子结点</li><li>最多只有一个度为1的结点</li><li>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1，结点i的父节点为[i&#x2F;2]（<code>[]</code>为取整符号），即结点7的左孩子为2i&#x3D;14，右孩子为2i+1&#x3D;15，而父节点为[i&#x2F;2]&#x3D;3。</li><li>$$i\leqslant [n&#x2F;2]$$为分支结点，$$i\geqslant [n&#x2F;2]$$为叶子结点。</li></ul><h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><blockquote><p>具有以下性质的二叉树：</p><p><strong>左子树</strong>上所有结点的关键字均<strong>小于根结点</strong>的关键字；</p><p><strong>右子树</strong>上所有结点的关键字均<strong>大于根结点</strong>的关键字；</p><p>左子树和右子树又各是一颗二叉排序树。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/aa74459afd5944c38c6f9df13c9363e9.png" alt="2-3"></p><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><blockquote><p>树上任一结点的左子树和右子树的深度之差不超过1。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f478c0ab6c464e2ab7e7d0f51b58b15a.png" alt="2-4"></p><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><ul><li>若有一颗非空二叉树中度为0、1和2的结点个数分别为$$n_0 、n_1、n_2$$，则$$n_0 &#x3D; n_2 + 1$$（$$n_0$$叶子结点比$$n_2$$二分支结点多一个）。</li><li>二叉树第i层至多有$$2^{i-1}$$各结点。</li><li>高度为h的二叉树至多有$$2^h-1$$个结点（满二叉树）。</li></ul><h4 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h4><ul><li>具有n个（n &gt; 0）结点的完全二叉树的高度h为$$[log_2(n+1)]$$或$$[log_2n]+1$$</li></ul><p><strong>推导过程：</strong></p><p>设高为h的满二叉树共有$$2^h-1$$个结点，高为h-1的满二叉树共有$$2^{h-1}-1$$个结点，则有：<br>$$<br>2^{h-1}-1&lt;n\leqslant 2^h-1<br>$$<br>加+1得：<br>$$<br>2^{h-1} &lt; n+1 \leqslant 2^h<br>$$<br>再取$$\log_2$$：<br>$$<br>h-1&lt;\log_2(n+1) \leqslant h<br>$$<br>则对$$\log_2(n+1)$$向上取整得$$[log_2(n+1)]$$。</p><p><strong>另一个式子推导过程：</strong></p><p>高为h-1的满二叉树共有$$2^{h-1}-1$$个结点，高为h的完全二叉树至少$$2^{h-1}$$个结点，至多有$$2^h-1$$。</p><p>则有：<br>$$<br>2^{h-1}\leqslant n &lt; 2^h<br>$$<br>取$$log_2$$得：<br>$$<br>h-1\leqslant \log_2n&lt;h<br>$$<br>得$$h&#x3D;[log_2n+1]$$。</p><ul><li>对于完全二叉树，可以由结点数n推出度为0、1和2得结点个数为$$n_0 、n_1、n_2$$。</li></ul><p>完全二叉树最多只有一个度为1的结点，即$$n_1&#x3D;0或1$$。</p><p>$$n_0&#x3D;n_2+1-&gt;n_0+n_2$$<strong>一定是奇数。</strong></p><h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><h5 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h5><p>即用线性表来存储二叉树。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">&#123;</span>    ElemType value<span class="token punctuation">;</span> <span class="token comment">//结点中的数据元素</span>    bool isEmpty<span class="token punctuation">;</span> <span class="token comment">//结点是否为空</span><span class="token punctuation">&#125;</span></code></pre><p><strong>顺序存储比较适合完全二叉树，其他类型会导致存储空间浪费</strong></p><p>顺序存储的几个基本操作：</p><ul><li>查询第i个结点的左后继结点：<strong>2i</strong></li><li>查询第i个结点的右后继结点：<strong>2i+1</strong></li><li>查询第i个结点的父节点：**[i&#x2F;2]**</li><li>查询第i个结点的层次：$$[log_2(n+1)]$$或$$[log_2n]+1$$</li></ul><h5 id="二叉树的的链式存储"><a href="#二叉树的的链式存储" class="headerlink" title="二叉树的的链式存储"></a>二叉树的的链式存储</h5><p>即用链表来存储二叉树。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ElemType</span> <span class="token expression"><span class="token keyword">int</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>  <span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">//左右孩子指针</span><span class="token punctuation">&#125;</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span></code></pre><p><strong>在含有n个结点的二叉链表中，含有n+1个空链表。</strong></p><h5 id="二叉树链式操作基本实现（以二叉排序树为例）"><a href="#二叉树链式操作基本实现（以二叉排序树为例）" class="headerlink" title="二叉树链式操作基本实现（以二叉排序树为例）"></a>二叉树链式操作基本实现（以二叉排序树为例）</h5><p><strong>插入一个结点</strong></p><pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">InsertBiTNode</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>root<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 通过递归来找要插入的结点</span>  <span class="token comment">//  若要插入的数大于根结点，则放在右子树</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">></span> root<span class="token operator">-></span>data<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      BiTNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>      p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>      p<span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      p<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      root<span class="token operator">-></span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>      <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token function">InsertBiTNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>rchild<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">&lt;</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>lchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      BiTNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>      p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>      p<span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      p<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      root<span class="token operator">-></span>lchild <span class="token operator">=</span> p<span class="token punctuation">;</span>      <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>      <span class="token function">InsertBiTNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>lchild<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><h5 id="二叉树的先中后序遍历"><a href="#二叉树的先中后序遍历" class="headerlink" title="二叉树的先中后序遍历"></a>二叉树的先中后序遍历</h5><p><strong>先序遍历</strong>：先访问根节点，再访问左节点，最后访问右结点。</p><p><strong>中序遍历</strong>：先访问左节点，再访问根节点，最后访问右节点。</p><p><strong>后序遍历</strong>：先访问左结点，在访问右节点，最后访问根节点。</p><h5 id="先序遍历代码实现"><a href="#先序遍历代码实现" class="headerlink" title="先序遍历代码实现"></a>先序遍历代码实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 先序遍历 访问顺序为根左右</span><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>B <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">visitNode</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 访问结点并进行操作</span>    <span class="token function">PreOrder</span><span class="token punctuation">(</span>B<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归左节点</span>    <span class="token function">PreOrder</span><span class="token punctuation">(</span>B<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归右结点</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="中序遍历代码实现"><a href="#中序遍历代码实现" class="headerlink" title="中序遍历代码实现"></a>中序遍历代码实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 中序遍历 访问顺序为左根右</span><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>B <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">InOrder</span><span class="token punctuation">(</span>B<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归左节点</span>    <span class="token function">visitNode</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 访问结点并进行操作</span>    <span class="token function">InOrder</span><span class="token punctuation">(</span>B<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归右结点</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="后序遍历代码实现"><a href="#后序遍历代码实现" class="headerlink" title="后序遍历代码实现"></a>后序遍历代码实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 后序遍历 访问顺序为左右根</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>B <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">PostOrder</span><span class="token punctuation">(</span>B<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归左节点</span>    <span class="token function">PostOrder</span><span class="token punctuation">(</span>B<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归右结点</span>    <span class="token function">visitNode</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 访问结点并进行操作</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h5><p>层次遍历是从上到下按照层来对二叉树进行遍历，如图3-1所示。</p><p><img src="https://img-blog.csdnimg.cn/75ef45054a1947838aa6acc49fd69b01.png" alt="3-1"></p><h5 id="层次遍历的代码实现"><a href="#层次遍历的代码实现" class="headerlink" title="层次遍历的代码实现"></a>层次遍历的代码实现</h5><p>要进行层次遍历，需要借助一个队列。首先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。完成入队后出队，访问出队结点，如此反复，直至队列为空。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 层次遍历 按层访问</span><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  SqQueue <span class="token operator">*</span>Q<span class="token punctuation">;</span>  <span class="token comment">//获取出队元素</span>  BiTNode <span class="token operator">*</span>popEl<span class="token punctuation">;</span>  Q <span class="token operator">=</span> <span class="token function">InitSqQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化队列</span>  <span class="token comment">//将根节点入队</span>  <span class="token function">EnSqQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">SqQueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    popEl <span class="token operator">=</span>  <span class="token function">PopSqQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//出队后访问元素</span>    <span class="token function">visitNode</span><span class="token punctuation">(</span>popEl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//若左节点不为空将左结点入队</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>popEl<span class="token operator">-></span>lchild <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>      <span class="token function">EnSqQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>popEl<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//若右节点不为空将右结点入队</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>popEl<span class="token operator">-></span>rchild <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token function">EnSqQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>popEl<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span></code></pre><h4 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h4><p>想通过遍历序列来构造二叉树必须包含<strong>中序遍历</strong>，才能确定构造出唯一的二叉树，总共的构造方法有：</p><ul><li>前序+中序遍历序列构造</li><li>后序+中序遍历序列构造</li><li>层序+中序遍历序列构造</li></ul><h5 id="前序-中序遍历序列构造"><a href="#前序-中序遍历序列构造" class="headerlink" title="前序+中序遍历序列构造"></a>前序+中序遍历序列构造</h5><p>前序遍历是根左右，所以前序的第一个结点一定是根节点，然后就可以根据中序结点来找出根结点的左右子树有哪些，从而构造出二叉树。</p><p>例：</p><p>前序遍历序列为：A D B C E</p><p>中序遍历序列为：B D C A E</p><p>由前序可知A为根节点，再由中序得知左子树由BDC构成，右子树仅有E。</p><p>再看左子树的BDC，由于在前序结点中D在B之前D为左子树的根结点，B为左结点，C为右结点就成功构造出了唯一的二叉树。</p><p><img src="https://img-blog.csdnimg.cn/b6f41c49b7ee4e6c8749d7347c19ce0c.png" alt="4-1"></p><h5 id="后序-中序遍历序列构造"><a href="#后序-中序遍历序列构造" class="headerlink" title="后序+中序遍历序列构造"></a>后序+中序遍历序列构造</h5><p>后序遍历是左右根顺序，所以后序遍历的最后一个结点一定是根结点，然后再根据中序结点来寻找左右子树。</p><p>例：</p><p>后序遍历序列： E F A H C I G B D</p><p>中序遍历序列： E A F D H C B G I</p><p>根据后序可得根结点为D，再根据中序可得左子树元素由EAF，右子树元素有HCBGI。</p><p>对EAF进行拆分，根据后序可得A在最后方说明A为根节点，再根据中序E为左子树，则F为右子树，就可获得完整的左子树。</p><p>对HCBGI进行拆分，由后序可得根结点为B，再根据中序可得左子树为HC，右子树为GI。</p><p>在对HC进行拆分，由后序可得C为根节点，再根据中序得，H为左子树。</p><p>最后对GI进行拆分，由后序可得G为根节点，再根据中序可得，I为右子树。即可构造出唯一二叉树。</p><p><img src="https://img-blog.csdnimg.cn/0accbd04ec01490195d09c064ac83f84.png" alt="4-2"></p><h5 id="层序-中序遍历序列构造"><a href="#层序-中序遍历序列构造" class="headerlink" title="层序+中序遍历序列构造"></a>层序+中序遍历序列构造</h5><p>后序遍历是从上往下根据层顺序，所以层序遍历的第一个结点一定是根结点，然后再根据中序结点来寻找左右子树。</p><p>例：</p><p>层序遍历序列： A B C D E</p><p>中序遍历序列： A C B E D</p><p>根据层序可得A为根节点，再由中序可得左子树为空，右子树有CBED。</p><p>分析CBED，由层序得B为根节点，中序得C为以B为根节点的左子树，ED则为右子树。</p><p>分析ED，由层序得D为根节点，中序得E为D的左子树。最后成功构造唯一二叉树。</p><p><img src="https://img-blog.csdnimg.cn/bc261e5cfb4f463f90678bd68c44b422.png" alt="4-3"></p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h5 id="线索二叉树的基本概念"><a href="#线索二叉树的基本概念" class="headerlink" title="线索二叉树的基本概念"></a>线索二叉树的基本概念</h5><blockquote><p>线索二叉树就是在传统二叉树上添加直接前驱和直接后继指针，来使二叉树能更块的查找到结点的前驱和后继。通过<code>ltag</code>和<code>rtag</code>来表示是否存在左右结点，当<code>ltag==1</code>时表示<code>lchild</code>指向前驱结点，<code>ltag==0</code>时表示<code>lchild</code>指向左孩子，<code>rtag</code>同理。</p></blockquote><p><strong>线索二叉树的存储结构</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span>  <span class="token comment">//数据元素</span>  <span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">//左、右孩子指针</span>  <span class="token keyword">int</span> ltag<span class="token punctuation">,</span>rtag<span class="token punctuation">;</span>  <span class="token comment">//左、右线索标志</span><span class="token punctuation">&#125;</span>ThreadNode<span class="token punctuation">;</span></code></pre><h5 id="中序线索二叉树的构造"><a href="#中序线索二叉树的构造" class="headerlink" title="中序线索二叉树的构造"></a>中序线索二叉树的构造</h5><blockquote><p>二叉树的线索化使将二叉链表中的空指针改为指向前驱或后继的线索。因此线索化就是要在遍历的时候进行。</p></blockquote><p><strong>代码实现</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 通过中序遍历对二叉树进行线索化</span><span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p<span class="token punctuation">,</span> ThreadNode <span class="token operator">*</span><span class="token operator">*</span>pre<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//中序遍历线索化处理部分</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      p<span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span>      p<span class="token operator">-></span>ltag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>pre<span class="token punctuation">)</span><span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token punctuation">(</span><span class="token operator">*</span>pre<span class="token punctuation">)</span><span class="token operator">-></span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token comment">//建立前驱结点的后继线索</span>      <span class="token punctuation">(</span><span class="token operator">*</span>pre<span class="token punctuation">)</span><span class="token operator">-></span>rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>pre <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token comment">//中序遍历线索化结束</span>    <span class="token function">InThread</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//在此调用</span><span class="token keyword">void</span> <span class="token function">CreateInThread</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  ThreadNode <span class="token operator">*</span>pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">InThread</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//中序遍历最后一个结点肯定没有右孩子，所以直接设为null</span>    pre<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pre<span class="token operator">-></span>rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>先序和后序线索化逻辑类似就不再过多赘述。</p><h3 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><blockquote><p>树的存储方式有多种，即可采用顺序存储结构，又可采用链式存储，这里介绍3种常用的存储结构。</p></blockquote><h5 id="双亲表示法（顺序存储）"><a href="#双亲表示法（顺序存储）" class="headerlink" title="双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h5><blockquote><p>这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/617f87efcd614c32b8a2bea45139a314.png" alt="5-1"></p><p>将图5-1以双亲表示法存储到内存中应以图5-2形式来存储。</p><p><img src="https://img-blog.csdnimg.cn/2f1f9ad9a97e479e96ae782aec444ec2.png" alt="5-2"></p><p><strong>除了根结点指向-1外，其余<code>parent</code>都应指向父节点的数组下标</strong>。</p><p><strong>存储结构描述：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//树的结点定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//数据元素</span>  <span class="token keyword">int</span> parent<span class="token punctuation">;</span> <span class="token comment">//双亲位置域</span><span class="token punctuation">&#125;</span>PTNode<span class="token punctuation">;</span><span class="token comment">//树类型定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment">//结点数量</span><span class="token punctuation">&#125;</span>PTree<span class="token punctuation">;</span></code></pre><h5 id="孩子表示法（顺序-链式存储）"><a href="#孩子表示法（顺序-链式存储）" class="headerlink" title="孩子表示法（顺序+链式存储）"></a>孩子表示法（顺序+链式存储）</h5><blockquote><p>孩子表示法是将每个结点的孩子结点都用单链表连接起来形成一个线性结构，此时n个结点就有个孩子链表。</p></blockquote><p>将图5-1的树来用孩子表示法存储就可得图5-3。用一个<code>firstChild</code>链表来存储结点的第一个孩子结点，后可通过第一个孩子来找到后序结点。</p><p><img src="https://img-blog.csdnimg.cn/4b30fb69d5f046f3898b82fe72591f5d.png" alt="5-3"></p><p><strong>存储结构描述：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//孩子表示法</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> child<span class="token punctuation">;</span> <span class="token comment">//孩子结点在数组中的位置</span>  <span class="token keyword">struct</span> <span class="token class-name">CTNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//下一个孩子结点</span><span class="token punctuation">&#125;</span>CTNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span>  CTNode <span class="token operator">*</span>firstChild<span class="token punctuation">;</span> <span class="token comment">//第一个孩子</span><span class="token punctuation">&#125;</span>CTBox<span class="token punctuation">;</span></code></pre><h5 id="孩子兄弟表示法（链式存储）"><a href="#孩子兄弟表示法（链式存储）" class="headerlink" title="孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h5><blockquote><p>又称二叉树表示法，即以二叉链表作为树的存储结构。共包含三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针。</p></blockquote><p><strong>存储结构描述：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//孩子兄弟表示法</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token operator">*</span>firstchild<span class="token punctuation">,</span><span class="token operator">*</span>nextsibling<span class="token punctuation">;</span> <span class="token comment">//左指针指向第一个孩子，右指针指向该结点的兄弟结点</span><span class="token punctuation">&#125;</span>CSNode<span class="token punctuation">;</span></code></pre><h4 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h4><blockquote><p>由于二叉树和树都可以用二叉链表作为存储结构，因此二叉链表作为媒介可以将树和二叉树进行转换。</p></blockquote><p><strong>树转换成二叉树的规则：</strong></p><p>每个结点左指针指向它的第一个孩子，右指针指向它在树中相邻右兄弟（孩子兄弟表示法）。</p><p>森林转二叉树也是同理，不过不像树根节点没有兄弟，根结点的兄弟就是相邻的树。</p><p><strong>二叉树转成树的规则：</strong></p><p>从树的根节点根据树的层序来恢复，若有左孩子代表是树的第一个孩子结点，若有右节点，代表是树的第一个孩子结点的兄弟结点，以此类推。</p><p><strong>由于树的深度遍历和广度遍历与二叉树的先序遍历和中序遍历相似就不再过多赘述</strong></p><h3 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h3><h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><h5 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h5><p>结点的权：有某种现实意义的数值称为结点的权。</p><p>结点的<strong>带权路径长度</strong>：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积。如图6-1到权值为3的带权路径长度为$$3*3&#x3D;9$$的。</p><p><strong>树的带权路径长度</strong>：树中所有<strong>叶结点</strong>的带权路径之和（WPL,Weighted Path Length）。<br>$$<br>WPL &#x3D; \sum^n_{i&#x3D;1}w_il_i<br>$$</p><p><img src="https://img-blog.csdnimg.cn/05e6c51821974bcda761dc3b347a02ca.png" alt="6-1"></p><blockquote><p>在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树。</p></blockquote><h5 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h5><p>给定n个权值的结点，构造哈夫曼树的算法如下：</p><ol><li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</li><li>构造一个新结点，从F中选取两棵根结点权值最小的数作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根节点的权值之和。</li><li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</li><li>重复2、3步骤，直到F中只剩下一棵树为止。</li></ol><p>例：</p><p><img src="https://img-blog.csdnimg.cn/b32d21fbd2c9444dbfb7f5ff6d802a0c.png" alt="6-2"></p><p>将6-2中权值最小的两个结点（a和c或a和e）合成一个树，并将合成结点的权值相加作为根节点的权值，即到图6-3。</p><p><img src="https://img-blog.csdnimg.cn/f45cedceab7148fdb410924085edb32f.png" alt="6-3"></p><p>然后再将合成的树与新的权值最小的结点进行组合，获得一个新树。</p><p><img src="https://img-blog.csdnimg.cn/60539023c61f45ed84873905a4d176ec.png" alt="6-4"></p><p>如此往复即可合成一个哈夫曼树。</p><p><img src="https://img-blog.csdnimg.cn/d505d8552e7642ab9d769ec77ac7749b.png" alt="6-5"></p><p><strong>注：</strong></p><ol><li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li><li>哈夫曼树的结点总数为2n-1。</li><li>哈夫曼树中不存在度为1的结点。</li><li>哈夫曼树并不唯一，但带权路径长度WPL必然相同且最优。</li></ol><h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><blockquote><p>在数据通信中为了更高效的传播数据，可使用<strong>可变长度编码</strong>来对频率高的字符赋以短编码，而对频率低的字符用长编码，起到压缩数据的效果。而在这中就可以使用哈夫曼树来进行编码。</p></blockquote><p>例：</p><p>假设有1组A,B,C,D需要传播，且A出现10次，B出现8次，C出现80次，D出现2次。此时A的权值就是10，B的权值为8，C的权值为80，D的权值为2。就可以根据权值来构造哈夫曼树，来寻求WPL最优，由此可以构造出图6-6的哈夫曼树，并将左子树路径设为0，右子树设为1。</p><p><img src="https://img-blog.csdnimg.cn/409d18ee528e44c2a850f05da03d85e0.png" alt="6-6"></p><p>则若想要传播数据A、B、C、D相应的二进制为：</p><p>A:10B:111C:0D:110。</p><p>即可完成数据传送，且$$WPL&#x3D;80<em>1+10</em>2+3<em>2+8</em>3&#x3D;130$$。</p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>并查集是一种简单的集合表示。它支持以下三种操作：</p><ol><li><code>Initial(S)</code>：将集合S中的每个元素都初始化为只有一个单集合的子集合。</li><li><code>Union(S,Root1,Root2)</code>：把集合S中的<code>Root2</code>并入子集合<code>Root1</code>。</li><li><code>Find(S,x)</code>：查找集合S中单元素x所在的子集合，并返回集合的根结点。</li></ol><p>并查集可以使用树的双亲表示法，用双亲表示法可以很好的找到元素属于哪个集合和合并集合。并查集本身用一个<code>int[]</code>即可实现。</p><p>并查集的结构定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">int</span> UFSets<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> </code></pre><p>在<code>UFSets[SIZE]</code>集合中根节点和结点数通过负数来进行表示。</p><p>例：$$S_1&#x3D;{0,6,7,8}\quad S_2&#x3D;{1,4,9}\quad S_3&#x3D;{2,3,5}\quad$$</p><p>使用<code>UFSets[SIZE]</code>来表示则为<code>[-4,-3,-3,2,1,2,0,0,0,1]</code>。</p><p>集合中的元素为数组的下标，而数组的实际内容为集合的双亲。<code>UFSETS[0]</code>的-4则代表集合1中有4个元素且为根结点，<code>UFSETS[1]</code>的-3代表集合2有3个元素且为根节点，以此可以推出所有结点所在的位置。</p><p>Find操作：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 传入的x为元素，即并查集中的数组下标</span><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> S<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>Union操作：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 将两树合并，并横向合并不增加树的高度 root为数组下标</span><span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> Root1<span class="token punctuation">,</span> <span class="token keyword">int</span> Root2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Root1<span class="token operator">==</span>Root2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span> <span class="token operator">></span> S<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//Root2结点数更少</span>  <span class="token punctuation">&#123;</span>    S<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span><span class="token operator">+=</span>S<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//累加结点数</span>    S<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span> <span class="token operator">=</span> Root1<span class="token punctuation">;</span> <span class="token comment">//小树合并到大树 将S数组中Root1的下标值赋值给S[Root2]</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    S<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span><span class="token operator">+=</span>S<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//累加结点数</span>    S<span class="token punctuation">[</span>Root1<span class="token punctuation">]</span> <span class="token operator">=</span> Root2<span class="token punctuation">;</span> <span class="token comment">//小树合并到大树 将S数组中Root2的下标值赋值给S[Root1]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="对Find操作进行优化"><a href="#对Find操作进行优化" class="headerlink" title="对Find操作进行优化"></a>对Find操作进行优化</h5><p>对于长度过长的树，可以进行压缩路径来使树的高度不超过<code>O(a(n))</code>。a(n)是一个增长很缓慢的函数。</p><p>压缩路径具体实现：先通过循环找到根节点，后将所有搜索经过的结点都指向根节点即可。</p><p><img src="https://img-blog.csdnimg.cn/a1da08d342a64c2a8b72c0299f9aa06a.png" alt="6-7"></p><p>代码实现：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//x为数组下标 </span><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> root <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//循环找到根</span>        root <span class="token operator">=</span> S<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//压缩路径</span>       <span class="token keyword">int</span> t <span class="token operator">=</span> S<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//保存x的父节点</span>       S<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">//将x直接挂到根节点下</span>       x <span class="token operator">=</span> t<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-串</title>
      <link href="/2023/10/05/shu-ju-jie-gou-chuan/"/>
      <url>/2023/10/05/shu-ju-jie-gou-chuan/</url>
      
        <content type="html"><![CDATA[<h3 id="串的实现"><a href="#串的实现" class="headerlink" title="串的实现"></a>串的实现</h3><p>在C语言中所使用的字符串就是串的数据类型的一种。</p><h4 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h4><h5 id="定长顺序存储表示"><a href="#定长顺序存储表示" class="headerlink" title="定长顺序存储表示"></a>定长顺序存储表示</h5><p>类似于线性表的顺序存储结构，用一组连续的存储单元存储串值的字符序列。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLEN</span> <span class="token expression"><span class="token number">255</span> </span><span class="token comment">//预定义最大串长为255</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SString</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> ch<span class="token punctuation">[</span>MAXLEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//每个分量存储一个字符</span>  <span class="token keyword">int</span> length<span class="token punctuation">;</span>   <span class="token comment">//串的实际长度</span><span class="token punctuation">&#125;</span>SString<span class="token punctuation">;</span></code></pre><p>串的实际长度只能小于或等于<code>MAXLEN</code>，超过预定义长度的串值会被社区，称为截断。串长的表示由两种方法：一种是通过<code>length</code>存放串的长度；二是在串值后面加一个不计入串长的结束标记字符<code>&#39;\0&#39;</code>（C语言种字符串就是采用这种方法），此时串就根据<code>&#39;\0&#39;</code>来算长度。</p><h5 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h5><p>堆分配存储表示仍然以一组地址连续的存储单元存放串，但存储空间是动态分配获得。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>   <span class="token comment">//按串长分配存储区，ch指向串的首地址</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//串的长度</span><span class="token punctuation">&#125;</span>HString<span class="token punctuation">;</span></code></pre><p>在C语言中，用<code>malloc()</code>为每个新产生的串分配一块串长所需的存储空间。</p><h5 id="块链存储表示"><a href="#块链存储表示" class="headerlink" title="块链存储表示"></a>块链存储表示</h5><p>类似于链式存储结构，也可采用链式方式存储串值。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//串的结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StringNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> ch<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//每个结点存多个字符 提高存储密度</span>    <span class="token keyword">struct</span> <span class="token class-name">StringNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//指向下一个结点</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h4><h5 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h5><pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">StrAssign</span><span class="token punctuation">(</span>SString <span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token keyword">char</span> chars<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//获取要赋值字符串长度</span>  <span class="token keyword">int</span> charsLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 长度为零表示空字符串，退出循环</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>charsLen<span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> charsLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    T<span class="token operator">-></span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  T<span class="token operator">-></span>length <span class="token operator">=</span> charsLen<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="复制操作"><a href="#复制操作" class="headerlink" title="复制操作"></a>复制操作</h5><pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">StrCopy</span><span class="token punctuation">(</span>SString <span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token keyword">const</span> SString S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> S<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    T<span class="token operator">-></span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 若要赋值的长度大于原先字符串长度就增长</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>length <span class="token operator">></span> T<span class="token operator">-></span>length<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    T<span class="token operator">-></span>length <span class="token operator">=</span> S<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="判空操作"><a href="#判空操作" class="headerlink" title="判空操作"></a>判空操作</h5><pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">StrEmpty</span><span class="token punctuation">(</span><span class="token keyword">const</span> SString <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> S<span class="token operator">-></span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">StrCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> SString S<span class="token punctuation">,</span> <span class="token keyword">const</span> SString T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> S<span class="token punctuation">.</span>length <span class="token operator">||</span> i <span class="token operator">!=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">//若S>T 返回大于0的数 若S&lt;T 返回小于0的数</span>      <span class="token keyword">return</span> S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//若结束循环没有比较出结果说明必有一个长度要更长</span>  <span class="token keyword">return</span> S<span class="token punctuation">.</span>length <span class="token operator">-</span> T<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 求字串 Sub来返回串S的第pos个字符起长度为len的字串</span>bool <span class="token function">SubString</span><span class="token punctuation">(</span>SString <span class="token operator">*</span>Sub<span class="token punctuation">,</span> SString S<span class="token punctuation">,</span> <span class="token keyword">char</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> S<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pos<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">// 记录pos字符在S中的起始位置</span>      index <span class="token operator">=</span> i<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 判断len是否要长于S字符串中pos开始后的长度</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> S<span class="token punctuation">.</span>length <span class="token operator">-</span> index<span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    Sub<span class="token operator">-></span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    index<span class="token operator">++</span><span class="token punctuation">;</span>    Sub<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="串联结"><a href="#串联结" class="headerlink" title="串联结"></a>串联结</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 用T返回由S1和S2拼接而成的新串，S2拼接在S1前</span>bool <span class="token function">Concat</span><span class="token punctuation">(</span>SString <span class="token operator">*</span>T<span class="token punctuation">,</span> SString S1<span class="token punctuation">,</span> SString S2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> S1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    T<span class="token operator">-></span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> S1<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    T<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> S1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> S1<span class="token punctuation">.</span>length <span class="token operator">+</span> S2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    T<span class="token operator">-></span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> S2<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    index<span class="token operator">++</span><span class="token punctuation">;</span>    T<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="定位操作（简单的模式匹配算法）"><a href="#定位操作（简单的模式匹配算法）" class="headerlink" title="定位操作（简单的模式匹配算法）"></a>定位操作（简单的模式匹配算法）</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 定位操作 若主串S中存在与串T值相同的字串，则返回它在S中第一次出现的位置，否则为0</span><span class="token keyword">int</span> <span class="token function">Index</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span> SString T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// i和j分别为S和T的计数指针</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      i<span class="token operator">++</span><span class="token punctuation">;</span>      j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">// S的指针跳到下一个字符位置</span>      i <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//若T的指针j扫描到最后一个元素说明都匹配上就返回第一个匹配上的地址</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="串的模式匹配算法—KMP算法"><a href="#串的模式匹配算法—KMP算法" class="headerlink" title="串的模式匹配算法—KMP算法"></a>串的模式匹配算法—KMP算法</h4><blockquote><p>上方的暴力匹配算法中有许多重复的趟数会导致花不必要的时间来跑已经知道的结果，KMP算法就是用于解决这个问题，在KMP算法中，会采用一个<code>next</code>数组来记录子串是在主串第几个元素匹配失败的，下次可以通过<code>next</code>来直接重匹配失败的位置重新开始匹配。在KMP算法中，最主要的就是<code>next</code>数组的计算。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//S和T数组下标由1开始</span><span class="token comment">// KMP算法 若主串S中存在与串T值相同的字串，则返回它在S中第一次出现的位置，否则为0</span><span class="token keyword">int</span> <span class="token function">Index_KMP</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span> SString T<span class="token punctuation">,</span> <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// i和j分别为S和T的计数指针</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      i<span class="token operator">++</span><span class="token punctuation">;</span>      j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">// KMP算法只需根据计算出的next数组对j的值进行修改</span>      j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 若T的指针j扫描到最后一个元素说明都匹配上就返回第一个匹配上的地址</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token keyword">return</span> i <span class="token operator">-</span> T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 求next数组</span><span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span>SString T<span class="token punctuation">,</span> <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token operator">++</span>i<span class="token punctuation">;</span>      <span class="token operator">++</span>j<span class="token punctuation">;</span>      next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>      j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数电-数字逻辑概论</title>
      <link href="/2023/10/05/shu-dian-shu-zi-luo-ji-gai-lun/"/>
      <url>/2023/10/05/shu-dian-shu-zi-luo-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h3><blockquote><p>数制的概念就不过多赘述，这里主要描述十进制，二进制，八进制以及十六机制间的相互转换。</p></blockquote><h4 id="十-二-八-十六进制之间的转换"><a href="#十-二-八-十六进制之间的转换" class="headerlink" title="十-二-八-十六进制之间的转换"></a>十-二-八-十六进制之间的转换</h4><h5 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h5><p>按位权进行展开再求和。</p><p>例：<br>$$<br>(101110.011)<em>2 &#x3D; 1 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 + 0\times 2^{-1} + 1 \times 2^{-2} + 1 \times 2^{-3} &#x3D; (46.375)</em>{10}<br>$$</p><h5 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h5><p>十进制通过除2即可将再将每次除过后的余数保存下来并倒序即可获得相应的二进制数。<strong>整数部分采用“除基取余，小鼠部分采用“乘基取整法”</strong></p><p>例：$$(26.375)_{10}$$</p><p>整数部分（%代表取余）：26%2 &#x3D; 0 ，后再将 13 % 2 &#x3D; 1 （13是通过26&#x2F;2算出），后 6 % 2 &#x3D; 0，再 3 % 2 &#x3D; 1，最后 1%2 &#x3D; 1，一直除到商为0为止。将取到的余倒序，则得整数二进制$$(11010)_2$$。</p><p>小数部分：$$0.375\times 2 &#x3D; 0.750$$整数部分为0，后$$0.750 \times 2 &#x3D; 1.500$$整数部分为1，取出，后$$0.500 \times 2 &#x3D; 1.000$$整数部分为1取出。最后小数部分顺序得小数二进制$$(.011)_2$$。</p><p>合在一起得：$$(26.375)_{10} &#x3D; (11010.011)_2$$</p><p><strong>十进制转八进制或十六进制</strong>就是将除部分改为<strong>8</strong>或<strong>16</strong>。</p><h5 id="二进制与八、十六进制相互转换"><a href="#二进制与八、十六进制相互转换" class="headerlink" title="二进制与八、十六进制相互转换"></a>二进制与八、十六进制相互转换</h5><p>二进制转八进制与十六进制：</p><blockquote><p>从小数点开始，整数部分向左、小数部分向右三位一组（十六进制以四位一组），不足三位（四位）的加0补足，再按顺序写出各组对应的八进制数（十六进制数）。</p></blockquote><p>以八进制为例：</p><p>$$(11\quad 100\quad 101.\quad111\quad 010\quad 11)_2$$，整数部分以三位一组，得$$011\quad 100\quad 101$$（补了一位0）后将每三位换成八进制得$$(345)_8$$，小数部分则右补零得$$.111\quad 010\quad 110$$（补了一位0），后转为八进制$$(.726)_8$$，最后结果就位$$(345.726)_8$$，十六进制也是同理。</p><p>八进制与十六进制转二进制：</p><blockquote><p>每位八进制数（十六进制数）用三位二进制（四位二进制）数来代替，再按原顺序排列。</p></blockquote><p>以八进制为例：</p><p>$$(745.361)_8$$，将整数小数部分分为三位一组二进制即可得$$(111\quad 100\quad 101.\quad011\quad 110\quad 001)$$</p><h3 id="码制"><a href="#码制" class="headerlink" title="码制"></a>码制</h3><blockquote><p>码制就是一系列编码的格式，而将若干个二进制数码0和1按一定规则排列来表示某种特定含义的代码就是二进制代码。用数码的特定组合来表示特定信息的过程就称编码。常见的二进制代码有：自然（态序）二进制码，二-十进制码（BCD码）、格雷码、奇偶校验码、ASCII码</p></blockquote><h4 id="二-十进制码"><a href="#二-十进制码" class="headerlink" title="二-十进制码"></a>二-十进制码</h4><blockquote><p>又称BCD码，就是用四位二进制数来表示十进制数中的0-9十个数码。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/ef1806a307834cb69037ce14096d301f.png" alt="1-1"></p><p>图1-1就是各种常见的BCD码。</p><p>例：用BCD码表示十进制数举例（用BCD码，每位十进制数用四位二进制来表示）：</p><p>$$(36)<em>{10}&#x3D;(0011\quad 0110)</em>{8421BCD}$$</p><p>$$(4.79)<em>{10}&#x3D;(0100\quad.0111\quad 1001)</em>{8421BCD}$$</p><p>$$(0101.0001)<em>{8421BCD}&#x3D;(5.1)</em>{10}$$</p><p><strong>BCD码与数制的区别：</strong></p><p>$$(150)<em>{10}&#x3D;(0001\quad 0101 \quad 0000)</em>{8421BCD} &#x3D; (10010110)_2&#x3D;(226)<em>8&#x3D;(96)</em>{16}$$</p><h3 id="基本逻辑运算和复合逻辑运算"><a href="#基本逻辑运算和复合逻辑运算" class="headerlink" title="基本逻辑运算和复合逻辑运算"></a>基本逻辑运算和复合逻辑运算</h3><h4 id="与或非运算"><a href="#与或非运算" class="headerlink" title="与或非运算"></a>与或非运算</h4><p>与或运算与计算机语言中<code>&amp;&amp;</code>、<code>||</code>意思相同。</p><p>与运算中，表达式A和B都为真（即都为1）时候才为真，或运算中，表达式A和B其中有一个为真（即其中一个为1）时候为真。例<code>A=1 &amp;&amp; B=1</code>则为<code>true</code>，<code>A=1 || B = 0</code>为<code>true</code>，而<code>A=1 &amp;&amp; B = 0</code>为<code>false</code></p><p><strong>与运算逻辑表达式：</strong> $$Y&#x3D;A· B$$或$$Y&#x3D;AB$$</p><p>逻辑符号：</p><p><img src="https://img-blog.csdnimg.cn/2ca0e108095b4fcfb85836119437f46f.png" alt="AND gate"></p><p><strong>或运算逻辑表达式：</strong> $$Y&#x3D;A+B$$</p><p><img src="https://img-blog.csdnimg.cn/3d52d8220d754b1688b2c080c56dc3fb.png" alt="OR gate"></p><p><strong>非运算表达式：</strong>$$Y&#x3D;\bar{A}$$，即$$\bar{0}&#x3D;1 \quad \bar{1}&#x3D;0$$</p><p><img src="https://img-blog.csdnimg.cn/e52e504cf2d340e394c7b1d352b9d634.png" alt="NOT gate"></p><h4 id="复合逻辑运算"><a href="#复合逻辑运算" class="headerlink" title="复合逻辑运算"></a>复合逻辑运算</h4><h5 id="与非运算（NAND）"><a href="#与非运算（NAND）" class="headerlink" title="与非运算（NAND）"></a>与非运算（NAND）</h5><p>与非运算表达式：$$Y&#x3D;\overline{AB}$$，即有0出1，全1出0；</p><p><img src="https://img-blog.csdnimg.cn/dc32e1afbb5c438a8b97fb475cb2f5f4.png" alt="与非门"></p><h5 id="或非运算（NOR）"><a href="#或非运算（NOR）" class="headerlink" title="或非运算（NOR）"></a>或非运算（NOR）</h5><p>或非运算表达式：$$Y&#x3D;\overline{A+B}$$，即有1出0，全0出1；</p><p><img src="https://img-blog.csdnimg.cn/2861c4f3075a4dea977f0e6af45c20eb.png" alt="或非门"></p><h5 id="异或运算（Exclusive-OR）"><a href="#异或运算（Exclusive-OR）" class="headerlink" title="异或运算（Exclusive-OR）"></a>异或运算（Exclusive-OR）</h5><p>异或运算表达式：$$Y&#x3D;A⊕B&#x3D;\bar{A}B+A\bar{B}$$，即相同为0，不同为1；</p><p><img src="https://img-blog.csdnimg.cn/7e3c107979574548bb108a598f98f776.png" alt="异或门"></p><p><strong>若有奇数个1，则异或结果为1；若有偶数个1，则异或结果为0</strong>.</p><p>例：<br>$$<br>1⊕0⊕0⊕1⊕1⊕0⊕1&#x3D;0\<br>1⊕0⊕1⊕0⊕1⊕1⊕1&#x3D;1<br>$$</p><h5 id="同或运算（Exclusive-NOR，即异或的非）"><a href="#同或运算（Exclusive-NOR，即异或的非）" class="headerlink" title="同或运算（Exclusive-NOR，即异或的非）"></a>同或运算（Exclusive-NOR，即异或的非）</h5><p>同或运算表达式：$$Y&#x3D;A⊙B$$，即相同为1，不同为0；</p><p><img src="https://img-blog.csdnimg.cn/24e849767dd34be5b4781a1e9b8fda8f.png" alt="同或门"></p><p><strong>若有奇数个1，则同或结果为0；若有偶数个1，则同或结果为1</strong>.</p><h5 id="与或非运算（AND-OR-INVERT）"><a href="#与或非运算（AND-OR-INVERT）" class="headerlink" title="与或非运算（AND-OR-INVERT）"></a>与或非运算（AND-OR-INVERT）</h5><p>与或非运算表达式：$$Y&#x3D;\overline{AB+CD}$$，先与后或再非；</p><p><img src="https://img-blog.csdnimg.cn/b05c1ec0687143eebe1a34ebb0edf9cd.png" alt="与或非门"></p><h3 id="逻辑代数的基本定律"><a href="#逻辑代数的基本定律" class="headerlink" title="逻辑代数的基本定律"></a>逻辑代数的基本定律</h3><h4 id="常量间的计算"><a href="#常量间的计算" class="headerlink" title="常量间的计算"></a>常量间的计算</h4><p><img src="https://img-blog.csdnimg.cn/7c1351b892134689ace41fdb108f7333.png" alt="img"></p><h4 id="逻辑变量与常量的计算"><a href="#逻辑变量与常量的计算" class="headerlink" title="逻辑变量与常量的计算"></a>逻辑变量与常量的计算</h4><h5 id="0-1律"><a href="#0-1律" class="headerlink" title="0-1律"></a>0-1律</h5><p>$$<br>0+A&#x3D;A\<br>1+A&#x3D;1\<br>0 \cdot A&#x3D;0\<br>1 \cdot A &#x3D; A<br>$$</p><h5 id="同一律"><a href="#同一律" class="headerlink" title="同一律"></a>同一律</h5><p>$$<br>A+A&#x3D;A\<br>A\cdot A &#x3D; A<br>$$</p><h5 id="互补律"><a href="#互补律" class="headerlink" title="互补律"></a>互补律</h5><p>$$<br>A+\bar{A} &#x3D; 1\<br>A \cdot \bar{A} &#x3D; 0<br>$$</p><h5 id="还原律"><a href="#还原律" class="headerlink" title="还原律"></a>还原律</h5><p>$$<br>\bar{\bar{A}} &#x3D; A<br>$$</p><h4 id="逻辑代数的基本定律-1"><a href="#逻辑代数的基本定律-1" class="headerlink" title="逻辑代数的基本定律"></a>逻辑代数的基本定律</h4><h5 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h5><p>$$<br>A+B&#x3D;B+A\quad A\cdot B&#x3D; B \cdot A<br>$$</p><h5 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h5><p>$$<br>(A+C)+C &#x3D; A+(B+C)\quad (A\cdot B)\cdot C&#x3D; A \cdot (B\cdot C)<br>$$</p><h5 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h5><p>$$<br>A(B+C) &#x3D; AB+AC \quad A+BC&#x3D;(A+B)(A+C)<br>$$</p><h5 id="摩根定律（反演律）"><a href="#摩根定律（反演律）" class="headerlink" title="摩根定律（反演律）"></a>摩根定律（反演律）</h5><p>$$<br>\overline{A\cdot B} &#x3D; \bar{A} + \bar{B} \quad \overline{A+ B} &#x3D; \bar{A} \cdot \bar{B}<br>$$</p><p>证明等式$$A+BC&#x3D;(A+B)(A+C)$$：<br>$$<br>(A+B)(A+C)&#x3D;AA+AC+AB+BC&#x3D;A(1+C)+AB+BC\quad 注：1+C&#x3D;1\<br>&#x3D;A+AB+BC\<br>&#x3D;A(1+B)+BC&#x3D;A+BC<br>$$<br>证毕。</p><h4 id="逻辑代数的常用公式"><a href="#逻辑代数的常用公式" class="headerlink" title="逻辑代数的常用公式"></a>逻辑代数的常用公式</h4><p>$$<br>AB+A\bar{B} &#x3D; A \qquad A+AB&#x3D;A\<br>A+\bar{A}B &#x3D; A + B<br>$$</p><h5 id="冗余律"><a href="#冗余律" class="headerlink" title="冗余律"></a>冗余律</h5><p>$$<br>AB+\bar{A}C+BC &#x3D; AB+\bar{A}C\<br>\overline{AB+\bar{A}C} &#x3D; A\bar{B}+\bar{A}\bar{C}<br>$$</p><h5 id="关于异或运算的一些公式"><a href="#关于异或运算的一些公式" class="headerlink" title="关于异或运算的一些公式"></a>关于异或运算的一些公式</h5><p>$$A⊕B&#x3D;\bar{A}B+A\bar{B}$$<br>$$<br>A⊕B&#x3D;B⊕A\<br>(A⊕B)⊕C&#x3D;A⊕(B⊕C)\<br>A\cdot (B⊕C)&#x3D;AB⊕AC\<br>A⊕1&#x3D;\bar{A}\<br>A⊕0&#x3D;A\<br>A⊕A&#x3D;0\<br>A⊕\bar{A}&#x3D;1\<br>$$<br>如果$$A⊕B&#x3D;C$$则有$$\begin{cases} A⊕C&#x3D;B\ B⊕C&#x3D;A \end{cases} $$</p><h3 id="逻辑代数的基本规则"><a href="#逻辑代数的基本规则" class="headerlink" title="逻辑代数的基本规则"></a>逻辑代数的基本规则</h3><h4 id="代入规则"><a href="#代入规则" class="headerlink" title="代入规则"></a>代入规则</h4><blockquote><p>将逻辑等式两边的某一变量均用同一个逻辑函数替代，等式仍然成立。</p></blockquote><p>例：$$A+\bar{A}B&#x3D;A+B$$</p><p>$$A$$均用$$\bar{A}$$代替得：$$\bar{A}+AB&#x3D;\bar{A}+B$$等式仍然成立。</p><h4 id="反演规则"><a href="#反演规则" class="headerlink" title="反演规则"></a>反演规则</h4><blockquote><p>对任一逻辑函数式Y，将式子中的所有的”$$\cdot$$“换成“+”，“+”换成”$$\cdot$$“，“0”换成“1”，“1”换成“0”，原变量换成反变量，则得到原逻辑函数的反函数$$\bar{Y}$$，并不改变运算顺序。</p></blockquote><p>例：$$Y_1&#x3D;A(B+C)+CD$$，取反得：$$\bar{Y_1}&#x3D;(\bar{A}+\bar{B}\bar{C})(\bar{C}+\bar{D})$$</p><h4 id="对偶规则"><a href="#对偶规则" class="headerlink" title="对偶规则"></a>对偶规则</h4><blockquote><p>对任一逻辑函数式Y，将式子中的所有的”$$\cdot$$“换成“+”，“+”换成”$$\cdot$$“，“0”换成“1”，“1”换成“0”，，则得到原逻辑函数的对偶式$$Y’$$。</p></blockquote><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><blockquote><p>表示输出函数和输入变量逻辑关系的表达式称逻辑表达式，逻辑表达式一般根据真值表、卡诺图或逻辑图写出。</p></blockquote><h4 id="常见表达式"><a href="#常见表达式" class="headerlink" title="常见表达式"></a>常见表达式</h4><p>$$Y&#x3D;A\bar{B}+BC$$（与—或表达式）。</p><p>$$Y&#x3D;(A+B)(\bar{B}+C)$$（或—与表达式）。</p><p>$$Y&#x3D;\overline{\overline{A\bar{B}}\overline{BC}}$$（与非—与非表达式）。</p><p>$$Y&#x3D;\overline{\overline{A+B}+\overline{\overline{B}+C}}$$（或非—或非表达式）。</p><h4 id="最小项"><a href="#最小项" class="headerlink" title="最小项"></a>最小项</h4><blockquote><p>在逻辑函数中，如果一个与项包含该逻辑函数的全部变量，且每个变量只出现一次，则称与项的最小项。对于n个变量的逻辑函数共有$$2^n$$个最小项。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/e388c1f33f034c3a8f2553fea3366447.png" alt="img"></p><h5 id="最小项的基本性质"><a href="#最小项的基本性质" class="headerlink" title="最小项的基本性质"></a>最小项的基本性质</h5><ol><li>对于变量的任一组取值，只有一个最小项的值为1。</li><li>不同的最小项，使其值为1的那组变量取值也不同。</li><li>对于变量的同一组取值，任意两个最小项<strong>与</strong>的结果为0.</li><li>对于变量的同一组取值，全部最小项逻辑<strong>或</strong>的结果为1.</li></ol><h5 id="最小项编号"><a href="#最小项编号" class="headerlink" title="最小项编号"></a>最小项编号</h5><p>最小项用$$m_i$$表示，通常用十进制数作最小项的下标。</p><p>编号方法是：将最小项中的<strong>原变量当作1，反变量当作0</strong>，从而得二进制，再将二进制转为对应的十进制数即为最小项的编号。</p><p>例：</p><p>$$\overline{A}BC$$的二进制$${011}_2$$，转为十进制为3，则下标就为3，最小项就是$$m_3$$</p><h5 id="最小项表达式（标准与或表达式）"><a href="#最小项表达式（标准与或表达式）" class="headerlink" title="最小项表达式（标准与或表达式）"></a>最小项表达式（标准与或表达式）</h5><blockquote><p>任何逻辑函数都是由其变量的若干个最小项构成，都可以表示成为最小项之和的形式。</p><p>在与或表达式中，有时与项并不是最小项，可利用$$\overline{A}+A&#x3D;1$$的形式补充缺少的变量，将逻辑函数变成最小项之和的形式。</p></blockquote><p>例：</p><p>$$Y&#x3D;F(A,B,C)&#x3D;AB+\overline{A}C$$，进行增项</p><p>使$$AB+\overline{A}C&#x3D;AB(\overline{C}+C)+\overline{A}C(\overline{B}+B)$$，最后展开即可得最小项：</p><p>$$AB\overline{C}+ABC+\overline{A}C\overline{B}+\overline{A}CB$$</p><h3 id="逻辑函数的化简"><a href="#逻辑函数的化简" class="headerlink" title="逻辑函数的化简"></a>逻辑函数的化简</h3><p>不同形式逻辑式由不同的最简式，一般先求取最简与或式，然后通过变换得到所需最简式。</p><h4 id="最简与或式"><a href="#最简与或式" class="headerlink" title="最简与或式"></a>最简与或式</h4><ol><li>乘积项（即与项）的个数最少，使与门个数最少。</li><li>每个乘积项中的变量数最少，使与门输入端数最少，</li></ol><h4 id="最简与非-与非式"><a href="#最简与非-与非式" class="headerlink" title="最简与非-与非式"></a>最简与非-与非式</h4><ol><li>非号个数最少，使与非门个数最少。</li><li>每个非号中的变量数最少，使与非门的输入端数最少。</li></ol><h4 id="公式化简法"><a href="#公式化简法" class="headerlink" title="公式化简法"></a>公式化简法</h4><h5 id="并项法"><a href="#并项法" class="headerlink" title="并项法"></a>并项法</h5><p>运用$$AB+A\overline{B}&#x3D;A(B+\overline{B})&#x3D;A$$，将两项合并为一项，并消去一个变量。</p><h5 id="吸收法"><a href="#吸收法" class="headerlink" title="吸收法"></a>吸收法</h5><p>运用$$A+AB&#x3D;A(1+B)&#x3D;A$$和$$AB+\overline{AC}+BC&#x3D;AB+\overline{AC}$$，消去多余的与项。</p><h5 id="消去法"><a href="#消去法" class="headerlink" title="消去法"></a>消去法</h5><p>运用$$A+\overline{A}B&#x3D;A+C$$or $$\overline{A}+AB &#x3D; \overline{A}+B$$，消去多余因子。</p><h5 id="配项法"><a href="#配项法" class="headerlink" title="配项法"></a>配项法</h5><p>在函数某一项乘$$A+\overline{A}&#x3D;1$$，将一项展开两项，或用$$AB+\overline{A}C&#x3D;AB+\overline{A}C+BC$$，增加冗余项。</p>]]></content>
      
      
      <categories>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中缀表达式转后缀表达式并计算</title>
      <link href="/2023/09/29/zhong-zhui-biao-da-shi-zhuan-hou-zhui-biao-da-shi-bing-ji-suan/"/>
      <url>/2023/09/29/zhong-zhui-biao-da-shi-zhuan-hou-zhui-biao-da-shi-bing-ji-suan/</url>
      
        <content type="html"><![CDATA[<h4 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h4><blockquote><p>表达式求值是程序设计语言中最基本的问题，在中缀表达式中不仅依赖运算符的优先级，而且还要处理括号。后缀表达式的运算符在操作数后面，在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符，更符合CPU的运算与处理。</p></blockquote><h5 id="中缀表达式转后缀表达式（手算）"><a href="#中缀表达式转后缀表达式（手算）" class="headerlink" title="中缀表达式转后缀表达式（手算）"></a>中缀表达式转后缀表达式（手算）</h5><p>中缀表达式<code>A + B * (C - D) - E / F</code>化为后缀表达式采用左优先的原则（没有运算符更高级的一律从左往右进行匹配，保证算法的唯一性）。</p><p>在这表达式中先进行<code>( )</code>中进行运算，并将运算符放在操作数后面，得<code>CD-</code>。</p><p>此时<code>CD-</code>为一个整体并根据运算符优先级与<code>B*</code>进行运算得<code>BCD-*</code>。</p><p>再与<code>A+</code>进行运算，得<code>ABCD-*+</code>，剩下就是<code>- E / F</code>部分，先进行除运算得<code>EF/</code>，再<code>ABCD-*+</code>与<code>EF/</code>进行减运算，得最终结果<code>ABCD-*+EF/-</code>。</p><h5 id="中缀表达式转后缀表达式（机算）"><a href="#中缀表达式转后缀表达式（机算）" class="headerlink" title="中缀表达式转后缀表达式（机算）"></a>中缀表达式转后缀表达式（机算）</h5><p>初始化一个栈，用于保存展示还不能确定运算顺序的运算符。</p><p>从左到右处理各个元素，直到末尾。可能遇到三种情况。</p><ul><li>遇到<strong>操作数</strong>。直接加入后缀表达式。</li><li>遇到<strong>界限符</strong>。遇到<code>&quot;(&quot;</code>直接入栈：遇到<code>&quot;)&quot;</code>则依次弹出栈内运算符并加入后缀表达式，直到弹出<code>&quot;(&quot;</code>为止。但<code>&quot;(&quot;</code>不加入到后缀表达式中。</li><li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到<code>&quot;(&quot;</code>或栈空则停止。之后再把当前运算符入栈。</li></ul><h5 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 判断是否是操作数</span><span class="token keyword">int</span> <span class="token function">isNumber</span><span class="token punctuation">(</span><span class="token keyword">char</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token char">'-'</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token char">'*'</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token char">'/'</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token char">'('</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 中缀表达式转后缀表达式</span>Elemtype <span class="token operator">*</span><span class="token function">InfixToSuffix</span><span class="token punctuation">(</span>Elemtype expression<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  SqStack S<span class="token punctuation">;</span>  <span class="token comment">// 初始化栈</span>  <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 存储后缀表达式 在堆中开辟空间用于返回 用calloc初始全为0，以防去除'()'后多余数据会造成结果错误</span>  <span class="token keyword">char</span> <span class="token operator">*</span>SuffixExpression <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> length<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 记录储存后缀表达式的指针</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 存储栈顶元素</span>  <span class="token keyword">char</span> topEl<span class="token punctuation">;</span>  <span class="token comment">// 存储出栈元素</span>  <span class="token keyword">char</span> popEl<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNumber</span><span class="token punctuation">(</span>expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">// 是数字就直接加入到后缀表达式中</span>      SuffixExpression<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 不是数字则为操作符</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果栈为空或为'('，则直接加入到栈中</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span> <span class="token operator">||</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 此时栈非空，并且扫描到的为 + 或 - 则栈中的优先级必定是高于或等于当前运算符</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取栈顶元素</span>        <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topEl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>topEl <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          <span class="token comment">// 将栈弹空或者遇到'('则停止</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> topEl <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>            <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>popEl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 弹出的元素不为'('，则加入到后缀表达式中</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>popEl <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>              SuffixExpression<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> popEl<span class="token punctuation">;</span>              j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>          <span class="token comment">// 弹出所有元素后将自身入栈</span>          <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 此时栈顶为'('则直接入栈</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>          <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 此时为 * 或 / ，可能栈中优先级较低，所以要进行判断</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span> <span class="token operator">||</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取栈顶元素</span>        <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topEl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 若栈顶为 + 或 - 说明优先级低于扫描到的，不能进行出栈操作，而是将扫描到的表达式入栈</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>topEl <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> topEl <span class="token operator">==</span> <span class="token char">'-'</span> <span class="token operator">||</span> topEl <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 直接出栈</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>          <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>popEl<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> popEl <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>            SuffixExpression<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> popEl<span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 当扫描到')'则将'('后的包括'('在内的所有操作符都弹出</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token comment">// 弹出元素</span>        <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>popEl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>popEl <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          <span class="token comment">// 将非'('的操作符加入到后缀表达式中</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>popEl <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>            SuffixExpression<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> popEl<span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>popEl<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 将栈中剩下的操作符弹出</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>popEl<span class="token punctuation">)</span><span class="token punctuation">;</span>    SuffixExpression<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> popEl<span class="token punctuation">;</span>    j<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> SuffixExpression<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="后缀表达式计算（手算）"><a href="#后缀表达式计算（手算）" class="headerlink" title="后缀表达式计算（手算）"></a>后缀表达式计算（手算）</h5><blockquote><p>方法：</p><p>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数。</p></blockquote><p>例：<code>A + B * (C - D) - E / F</code>转为后缀为<code>ABCD-*+EF/-</code>，计算先扫描到第一个操作符，然后将操作符左边两个操作数进行运算，则<code>CD-</code>进行运算得<code>C-D</code>，后将<code>C-D</code>视为一个整体，然后继续扫描下一个操作数<code>*</code>，然后将<code>C-D</code>与左边的<code>B</code>进行运算得<code>B*(C-D)</code>再视为一个整体，再扫描下一个操作数<code>+</code>，同样的将<code>A</code>与<code>B*(C-D)</code>进行运算得<code>A + B*(C-D)</code>，以此类推就可以将后缀表达式还原成中缀表达式并计算出值。</p><h5 id="后缀表达式计算（机算）"><a href="#后缀表达式计算（机算）" class="headerlink" title="后缀表达式计算（机算）"></a>后缀表达式计算（机算）</h5><blockquote><p>用栈实现后缀表达式的计算：</p><ol><li>用左往右扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则直接压入栈，并回到(1)；否则执行(3)</li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到(1)的步骤。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈、队列和数组</title>
      <link href="/2023/09/21/shu-ju-jie-gou-zhan-dui-lie-he-shu-zu/"/>
      <url>/2023/09/21/shu-ju-jie-gou-zhan-dui-lie-he-shu-zu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h4><blockquote><p>栈是只允许在一端进行插入或删除操作的线性表。首先栈式一种线性表，但限定这种线性表只能在某一端进行插入和删除操作，如图所示。</p><p>栈包括：</p><ul><li>栈顶（Top）。允许进入插入删除的那一端。</li><li>栈底（Buttom）。不许与进行插入和删除的一端。</li><li>空栈。不含任何元素的空表。</li></ul><p>从图中可以很明显的看到栈的操作特性为后进先出（Last In First Out， LIFO）。当我们运行高级语言程序时编译器执行语句采用的就是栈的形式。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b294fc152c7d47a3a16f2de2f63a331f.png" alt="img"></p><p><strong>栈的数学性质</strong></p><p><code>n</code>个不同元素进栈，出栈元素不同排列的个数为：<br>$$<br>\frac{1}{n+1}C^{n}_{2n}<br>$$<br>这公式称为卡特兰（Catalan）数。</p><h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><blockquote><p>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。</p></blockquote><p>栈的顺序存储类型：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span> </span><span class="token comment">//定义栈中元素的最大个数</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SqStack</span><span class="token punctuation">&#123;</span>  Elemtype data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存放栈中元素</span>  <span class="token keyword">int</span> top<span class="token punctuation">;</span>  <span class="token comment">//栈顶指针</span><span class="token punctuation">&#125;</span>SqStack<span class="token punctuation">;</span></code></pre><h4 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h4><blockquote><p>在此代码中，以<code>top == -1</code>来当作栈空条件。</p></blockquote><h5 id="顺序栈的初始化"><a href="#顺序栈的初始化" class="headerlink" title="顺序栈的初始化"></a>顺序栈的初始化</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//初始化一个空栈</span><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  S<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="顺序栈的判空"><a href="#顺序栈的判空" class="headerlink" title="顺序栈的判空"></a>顺序栈的判空</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 判断栈是否为空</span>bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqStack <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> S<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> true <span class="token operator">:</span> false<span class="token punctuation">;</span> <span class="token comment">//若 top == -1 则判断为空</span><span class="token punctuation">&#125;</span></code></pre><h5 id="顺序栈的进栈"><a href="#顺序栈的进栈" class="headerlink" title="顺序栈的进栈"></a>顺序栈的进栈</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//进栈操作</span>bool <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S<span class="token punctuation">,</span> Elemtype x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//栈满结束操作</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>top <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> MaxSize<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>  S<span class="token operator">-></span>top <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//栈顶指针指向进栈的元素位置</span>  S<span class="token operator">-></span>data<span class="token punctuation">[</span>S<span class="token operator">-></span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="顺序栈的出栈"><a href="#顺序栈的出栈" class="headerlink" title="顺序栈的出栈"></a>顺序栈的出栈</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//出栈操作                x用于接受出栈的元素</span>bool <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S<span class="token punctuation">,</span>Elemtype <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//栈为空结束操作</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token operator">*</span>x <span class="token operator">=</span> S<span class="token operator">-></span>data<span class="token punctuation">[</span>S<span class="token operator">-></span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="获取顺序栈的栈顶元素"><a href="#获取顺序栈的栈顶元素" class="headerlink" title="获取顺序栈的栈顶元素"></a>获取顺序栈的栈顶元素</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 获取栈顶元素</span>bool <span class="token function">GetTop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S<span class="token punctuation">,</span> Elemtype <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 栈为空结束操作</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token operator">*</span>x <span class="token operator">=</span> S<span class="token operator">-></span>data<span class="token punctuation">[</span>S<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="销毁顺序栈"><a href="#销毁顺序栈" class="headerlink" title="销毁顺序栈"></a>销毁顺序栈</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//销毁栈</span>bool <span class="token function">DestroyStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//只需将top = -1即可，因为是静态存储剩余空间会自动释放</span>  S<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><blockquote><p>为了更有效的利用存储空间，可以使用共享栈的形式，通过栈底位置相对不变的特性，可让两个顺序栈共享一个一位数组空间，将栈底分别设置在共享空间的两端，即<code>0</code>与<code>MaxSize -1</code>处，而当两个栈顶指针相邻时，则判断栈满。</p></blockquote><h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><blockquote><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率。</p></blockquote><h5 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//定义链栈类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StackLinkNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//数据域 </span>  <span class="token keyword">struct</span> <span class="token class-name">StackLinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="栈的链式存储结构实现"><a href="#栈的链式存储结构实现" class="headerlink" title="栈的链式存储结构实现"></a>栈的链式存储结构实现</h4><h5 id="栈的初始化"><a href="#栈的初始化" class="headerlink" title="栈的初始化"></a>栈的初始化</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//不带头节点初始化   用二级指针是因为传入的是以StackLinkNode*形式，原先结构体就是以指针的形式，所以要用二级指针并通过解引用的方式来进行值的修改，单传StackLinkNode形式以及用一级指针无法通过传值来对结构体类型进行修改。</span><span class="token keyword">void</span> <span class="token function">InitStackLink</span><span class="token punctuation">(</span>StackLink <span class="token operator">*</span><span class="token operator">*</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token operator">*</span>S <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 入栈操作 均插入到头节点后面的位置</span><span class="token keyword">int</span> <span class="token function">StackLinkPush</span><span class="token punctuation">(</span>StackLink <span class="token operator">*</span><span class="token operator">*</span>S<span class="token punctuation">,</span> Elemtype x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  StackLink <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token punctuation">(</span>StackLink <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackLink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 系统没有足够空间，插入失败</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  newNode<span class="token operator">-></span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>  newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">*</span>S <span class="token operator">=</span> newNode<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 出栈操作 删除头节点后一个的节点  x为出栈的元素</span><span class="token keyword">int</span> <span class="token function">StackLinkPop</span><span class="token punctuation">(</span>StackLink <span class="token operator">*</span><span class="token operator">*</span>S<span class="token punctuation">,</span> Elemtype <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 判断栈是否为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">StackLinkEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">;</span>  StackLink <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">// 释放删除节点的空间</span>  <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h4><h5 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h5><blockquote><p>队列（Queue）也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队。删除元素称为出队或离队。其操作的特性是<strong>先进先出(First In First Out, FIFO)</strong></p></blockquote><h5 id="队列常见的基本操作"><a href="#队列常见的基本操作" class="headerlink" title="队列常见的基本操作"></a>队列常见的基本操作</h5><ul><li><code>InitQueue(&amp;Q)</code>：初始化队列，构造一个空队列。</li><li><code>QueueEmpty(&amp;Q)</code>：判队列空，若队列Q为空返回<code>true</code>，否则返回<code>false</code>。</li><li><code>EnQueue(&amp;Q,x)</code>：入队，若队列Q未满，将x加入，使之成为新的队尾。</li><li><code>DeQueue(&amp;Q,&amp;x)</code>：出队，若队列Q非空，删除队头元素，并用x返回。</li><li><code>GetHead(Q,&amp;x)</code>：读队头元素，若队列Q非空，则将队头元素赋值给x。</li></ul><h4 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h4><h5 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h5><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素（相当于操作受限的顺序表），并附设两个指针：队头指针<code>front</code>指向队头元素，队尾指针<code>rear</code>指向队尾元素的下一个位置（也可以指向最后一个元素，根据实际情况而定）。</p><p><strong>存储类型可描述为：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SqQueue</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存放队列元素</span>  <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>        <span class="token comment">// 队头指针和队尾指针</span><span class="token punctuation">&#125;</span> SqQueue<span class="token punctuation">;</span></code></pre><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><blockquote><p>为了解决顺序队列一些缺点，引出了循环队列的概念。将顺序队列臆造称一个环状的空间，将队列的表在逻辑上视为一个环，即称循环队列。所以当首指针<code>Q.front = MaxSize - 1</code>后，再前进一个位置就重新回到0，可以通过**模运算(%)**实现。</p><ul><li>初始时：<code>Q.front = Q.rear = 0</code>，代表队列为空。</li><li>队首指针进1：<code>Q.front = (Q.front + 1) % MaxSize</code>，每当队头指针到最后一个存储空间位置就重新指回0处。</li><li>队尾指针进1：<code>Q.rear = (Q.rear + 1) % MaxSize</code>，逻辑与队首指针相同。</li><li>队列长度：<code>(Q.rear + MaxSize - Q.front) % MaxSize</code>。因为循环队列有可能会出现<code>Q.rear &gt; Q.front</code>的情况，所以需要通过模运算控制最大值并保证在<code>Q.front &gt; Q.rear</code>情况也可以使用。</li><li>判空条件：<code>Q.front == Q.rear</code>。</li></ul></blockquote><hr><p><strong>判断队满的三种处理方式：</strong></p><ul><li>牺牲一个单元来区分对空还是队满，入队时少用一个单元，即可通过<code>(Q.front + 1) % MaxSize == Q.rear</code>来判断是否为队满，如下图所示。</li></ul><p><img src="https://img-blog.csdnimg.cn/3bd5a20d4cd340aa9d8f2e8107fa8cbc.png" alt="img"></p><ul><li>类型中增设表示元素个数的数据成员，如<code>size</code>。这样，队空的条件为<code>Q.size == 0</code>，队满的条件为<code>Q.size == MaxSize</code>。</li><li>类型中增加<code>tag</code>数据成员，以区分队满还是队空。<code>tag = 0</code>来代表上一个操作为删除元素，若此时<code>Q.front == Q.rear</code>，因为上次为删除操作，所以只有队空的情况。反之<code>tag = 1</code>代表插入操作，只有队满才会导致<code>Q.front == Q.rear</code>。</li></ul><h4 id="顺序存储结构队列的具体实现"><a href="#顺序存储结构队列的具体实现" class="headerlink" title="顺序存储结构队列的具体实现"></a>顺序存储结构队列的具体实现</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 初始化</span>SqQueue <span class="token operator">*</span><span class="token function">InitSqQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  SqQueue <span class="token operator">*</span>Q <span class="token operator">=</span> <span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Q<span class="token operator">-></span>front <span class="token operator">=</span> Q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化队头队尾指针与存放个数</span><span class="token punctuation">&#125;</span></code></pre><h5 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//判空</span>bool <span class="token function">SqQueueEmpty</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqQueue <span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> Q<span class="token operator">-></span>front <span class="token operator">==</span> Q<span class="token operator">-></span>rear<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 入队操作</span>bool <span class="token function">EnSqQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>Q<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 判断是否元素已满  相当于浪费了最后一个存储空间，等于只能存储MaxSize -1 个值</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MaxSize <span class="token operator">==</span> Q<span class="token operator">-></span>front<span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  Q<span class="token operator">-></span>data<span class="token punctuation">[</span>Q<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>  Q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token operator">-></span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MaxSize<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 出队</span>bool <span class="token function">PopSqQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>Q<span class="token punctuation">,</span> ElemType <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 判断队列是否为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SqQueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token operator">*</span>x <span class="token operator">=</span> Q<span class="token operator">-></span>data<span class="token punctuation">[</span>Q<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>  Q<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token operator">-></span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MaxSize<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h4><h5 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h5><blockquote><p>通过链表的形式来表示队列就称为队列的链式存储，它实际就是一个同时带有队头指针和队尾指针的单链表。头指针指向队头节点，尾指针指向队尾节点，即单链表的最后一个节点。</p></blockquote><p><strong>队列的链式存储类型描述为：</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//链式队列节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LinkNode<span class="token punctuation">;</span><span class="token comment">//链式队列</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkQueue</span><span class="token punctuation">&#123;</span>  LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span><span class="token operator">*</span>rear<span class="token punctuation">;</span> <span class="token comment">//队头和队尾指针</span><span class="token punctuation">&#125;</span><span class="token operator">*</span>LinkQueue<span class="token punctuation">;</span></code></pre><h4 id="队列的链式存储结构基本操作"><a href="#队列的链式存储结构基本操作" class="headerlink" title="队列的链式存储结构基本操作"></a>队列的链式存储结构基本操作</h4><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 初始化</span>LinkQueue <span class="token function">InitLinkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  LinkQueue Q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkQueue<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 建立头节点和尾节点并指向同一块空间</span>  Q<span class="token operator">-></span>front <span class="token operator">=</span> Q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设头节点的下一个节点为空即此时尾节点的下一个节点也为空</span>  Q<span class="token operator">-></span>front<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> Q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="判断空"><a href="#判断空" class="headerlink" title="判断空"></a>判断空</h5><pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">LinkQueueEmpty</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkQueue Q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> Q<span class="token operator">-></span>front <span class="token operator">==</span> Q<span class="token operator">-></span>rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 入队</span>bool <span class="token function">EnLinkQueue</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  LinkNode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  s<span class="token operator">-></span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>  s<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  Q<span class="token operator">-></span>rear<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment">//移动尾节点</span>  Q<span class="token operator">-></span>rear <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//出队</span>bool <span class="token function">PopLinkQueue</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">,</span> ElemType <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">LinkQueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>  LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> Q<span class="token operator">-></span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token operator">*</span>x <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>  Q<span class="token operator">-></span>front<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">//若只有一个节点则变为空</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Q<span class="token operator">-></span>rear <span class="token operator">==</span> Q<span class="token operator">-></span>front<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><blockquote><p>双端队列是指允许两端都可以进行入队和出队操作的队列，如图所示。其元素的逻辑结构仍是线性结构。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/581157f3cb35461999419b8dd6de71fd.png" alt="img"></p><h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><h4 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h4><blockquote><p>假设表达式中包含<code>()[]</code>这三种括号，其嵌套的顺序任意即<code>([]())</code>或<code>[([][])]</code>等均为正确格式，即左括号和右括号必定可以成一对且匹配到时为同种类型，<code>[(])</code>或<code>([())</code>或<code>(()]</code>均为不正确的格式。</p></blockquote><h5 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h5><p>当输入括号序列：<code>[([][])] </code>。</p><ul><li>计算机入栈第1个括号<code>[</code>后，仅当第8个括号<code>]</code>出现后才会出栈。</li><li>获得第2个括号<code>(</code>，由于<code>)</code>在第7个位置<code>)</code>才会出栈，所以也将<code>(</code>入栈。</li><li>第3个<code>[</code>由于第4个<code>]</code>即为相应匹配，根据就近原则，第3个和第4个有限匹配出栈，而非第1个括号。所以第3个和第4个括号匹配后就会进行出栈。</li><li>第5个和第6个和第3个第4个括号同理，也根据就近原则直接匹配成功。</li><li>此时扫描到第7个位置的<code>)</code>，由于前面没有其他的<code>(</code>，只会和第2个入栈的<code>(</code>进行匹配，最后匹配成功出栈。</li><li>第8个也同理，与第1个<code>[</code>匹配成功后出栈。</li><li>当扫描完成后判断栈是否为空，为空则匹配成功，不为空则代表匹配失败。</li></ul><h4 id="括号匹配代码实现"><a href="#括号匹配代码实现" class="headerlink" title="括号匹配代码实现"></a>括号匹配代码实现</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 括号匹配 传入括号字符串以及对应的长度</span>bool <span class="token function">bracketCheck</span><span class="token punctuation">(</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  SqStack S<span class="token punctuation">;</span>    <span class="token comment">// 初始化栈</span>  <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">// 为左括号就入栈</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'('</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'['</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">//扫描到右括号但栈已为空</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>      Elemtype popEl<span class="token punctuation">;</span>      <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token operator">&amp;</span>popEl<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//仅当弹出的括号为一对时算匹配成功</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">')'</span> <span class="token operator">&amp;&amp;</span> popEl <span class="token operator">!=</span> <span class="token char">'('</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">']'</span> <span class="token operator">&amp;&amp;</span> popEl <span class="token operator">!=</span> <span class="token char">'['</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 为空代表匹配成功，不为空代表匹配失败</span>  <span class="token keyword">return</span> <span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="数组和特殊矩阵"><a href="#数组和特殊矩阵" class="headerlink" title="数组和特殊矩阵"></a>数组和特殊矩阵</h3><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><blockquote><p>​数组是由n(n&gt;&#x3D;1)个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。</p><p>​数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表。</p></blockquote><h4 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h4><p>以一维数组<code>A[0...n-1]</code>为例，其存储结构关系式为<br>$$<br>LOC(a_{i})&#x3D;LOC(a_{0})+i{\times}L(0{\leqslant}i&lt;n)<br>$$<br>其中，L是每个数组元素所占的存储单元，就是数据类型的大小（<code>sizeof(ElemType)</code>）。</p><p><strong>多维数组</strong></p><p>对于多维数组由两种映射方法：<strong>按行优先</strong>及<strong>按列优先</strong>。</p><p><strong>按行优先</strong>存储的基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组的行下标与列下标的范围分别为<code>[0,h_1]</code>与<code>[0,h_2]</code>，则存储结构关系式为<br>$$<br>LOC(a_{i,j})&#x3D;LOC(a_{0,0})+[i{\times}(h_{2}+1)+j]{\times}L<br>$$<br><code>LOC(a_0,0)</code>为数组的起始地址，<code>i*(h_2 +1) + j</code>就是<strong>行号</strong>乘矩阵的<strong>列数</strong>得到<strong>一行</strong>的个数后再加上要搜寻的元素的<strong>列号</strong>就可以搜索到元素。</p><p>例：对于数组<code>A_[2][3]</code>，</p><p>按行优先的存储形式为：<br>$$<br>A_{[2][3]}&#x3D;\begin{pmatrix} a_{[0][0]} &amp; a_{[0][1]} &amp; a_{[0][2]} \ a_{[1][0]} &amp; a_{[1][1]} &amp; a_{[1][2]} \ \end{pmatrix} \qquad \underbrace{a_{[0][0]}  a_{[0][1]}  a_{[0][2]}} \quad \underbrace{a_{[1][0]}  a_{[1][1]}  a_{[1][2]}}<br>$$<br>右边式子即先存储第一行后再存储第二行。</p><p><strong>按列优先</strong>则存储结构关系式为<br>$$<br>LOC(a_{i,j})&#x3D;LOC(a_{0,0})+[j{\times}(h_{1}+1)+i]{\times}L<br>$$<br><code>LOC(a_0,0)</code>为数组的起始地址，<code>j*(h_1 +1) + i</code>就是<strong>列号</strong>乘矩阵的<strong>行数</strong>得到<strong>一列</strong>的个数后再加上要搜寻的元素的<strong>行号</strong>就可以搜索到元素。</p><p>例：对于数组<code>A_[2][3]</code>，</p><p>按行优先的存储形式为：<br>$$<br>A_{[2][3]}&#x3D;\begin{pmatrix} a_{[0][0]} &amp; a_{[0][1]} &amp; a_{[0][2]} \ a_{[1][0]} &amp; a_{[1][1]} &amp; a_{[1][2]} \ \end{pmatrix} \qquad \underbrace{a_{[0][0]}  a_{[1][0]}} \quad \underbrace{a_{[0][1]}  a_{[1][1]}} \quad \underbrace{a_{[0][2]}  a_{[1][2]}}<br>$$<br>右边式子即先存储第一列后再存储第二列，最后存储第三列。</p><h4 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h4><blockquote><p>压缩存储：指为多个相同的元素分配一个空间，零元素不分配存储空间。</p><p>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素分布有一定规律。</p></blockquote><h5 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h5><p><img src="https://img-blog.csdnimg.cn/e9622e6fa5ba4b77aa2f8c13185b55ce.png" alt="1-1"></p><p>如图所示，以<code>i=j</code>为主对角线，对于矩阵A任意元素都满足：<br>$$<br>a_{i,j}&#x3D;a_{j,i}<br>$$<br>则称为对称矩阵。对于n阶对称矩阵，可以将n阶对称矩阵A存放再一维数组<code>B[n(n+1)/2]</code>中，比如只放下三角部分（i&gt;j）及主对角的元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路-电路模型和电路定律</title>
      <link href="/2023/09/20/dian-lu-dian-lu-mo-xing-he-dian-lu-ding-lu/"/>
      <url>/2023/09/20/dian-lu-dian-lu-mo-xing-he-dian-lu-ding-lu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="电路和电路模型"><a href="#电路和电路模型" class="headerlink" title="电路和电路模型"></a>电路和电路模型</h3><blockquote><p>电路是由电路零件、器件经导线连接而成的电通路装置。</p><ul><li>电路零件常称为电路部件（例如电阻器、开关、蓄电池等）；</li><li>电路器件则是由电路部件组成且具有某种功能的产品（如晶体管、集成电路等）；</li></ul><p>在电路中所产生的电压、电流是在电源的作用下产生的，因此电源又称为激励源或激励；由激励在电路中产生的电压、电流等称为响应。</p></blockquote><h4 id="电路模型"><a href="#电路模型" class="headerlink" title="电路模型"></a>电路模型</h4><p><img src="https://img-blog.csdnimg.cn/cf84230a2f504e218f6a76a8600fe632.png" alt="电路模型图"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">电路模型</p><p>图片中左侧为简单的实际电路，由若干个干电池和小灯泡组成，右侧为电路模型，反映了将嗲能转换为热能和光能的物理现象；用理想电路元件或它们的组合模拟实际器件就是建立其模型，简称<strong>建模</strong>。</p><h4 id="电流和电压的参考方向"><a href="#电流和电压的参考方向" class="headerlink" title="电流和电压的参考方向"></a>电流和电压的参考方向</h4><blockquote><p>电路理论中将电流（I）、电压（U）、电荷（Q）和磁通（Φ）来进行表示。磁通链用ψ进行表示。电功率和电能量分别用P和W。</p><p>在电路分析中，需指定电流或电压的参考方向后才能开始进行分析和计算。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/01572499b0fc4a6bbf12b749795e8fc5.png" alt="电流方向"></p><p>在上图中规定了A到B电流i的方向为A-&gt;B，若实际电流方向和参考方向一致，则电流为正值，即<code>i&gt;0</code>；若参考方向和实际方向不一致，即<code>i&lt;0</code>。这样在指定的电流参考方向下，电流值的正负就可以反映除电流的实际方向，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/2c2f78d2693d422f826a5b839760c3c9.png" alt="img"></p><p>同理，对电路两点之间的电压也要指定参考方向或参考极性。在表达两点之间的电压时，用正极性（+）表示高电位，负极性（-）表示低点位，而正极指向负极的方向就是电压的参考方向，如下图，若电压实际方向和参考方向相同，则<code>U&gt;0</code>，若电压实际方向和参考方向相反，则<code>U&lt;0</code>。</p><p><img src="https://img-blog.csdnimg.cn/5076a2ce2f97451490b6bda9fcd94aa1.png" alt="img"></p><h4 id="关联参考方向"><a href="#关联参考方向" class="headerlink" title="关联参考方向"></a>关联参考方向</h4><blockquote><p>一个元件的电流和电压的参考方向可以独立地任意指定。如果指定流过元件的电流参考方向和电压的参考方向一致，则成为<strong>关联参考方向</strong>，当两者不一致时，称为<strong>非关联参考方向</strong>，如下图所示。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/76a8077b06504aa68f89f7029e32b41f.png" alt="img"></p><h4 id="电路单位制"><a href="#电路单位制" class="headerlink" title="电路单位制"></a>电路单位制</h4><p>在国际单位制（SI）中，电流的单位为A（安培，简称安），电荷的单位为C（库伦，简称库），电压的单位为V（伏特，简称伏），磁通链的单位为Wb（韦伯，简称韦）。</p><h3 id="电功率和能量"><a href="#电功率和能量" class="headerlink" title="电功率和能量"></a>电功率和能量</h3><blockquote><p>电功率与电压和电流密切相关。当正电荷从元件上电压的<code>+</code>极经元件运动到电压的<code>-</code>极时，与此电压相应的电场力要对电荷做功，这时，元件<strong>吸收能量</strong>；反之为<strong>释放电能</strong>。</p></blockquote><p>在dt时间内，有dq电荷自元件上电压的<code>+</code>极经历电压u到电压的<code>-</code>极。根据电压的定义（A、B两点的电压u等于电场力将单位正电荷自A电移动至B点时所做的功），电场力所做功，也即元件吸收的能量为：<br>$$<br>dW &#x3D;udq<br>$$<br>假设电流<code>i</code>在元件上与<code>u</code>成关联方向，由<code>i</code>的定义<code>i=dq/dt</code>（即<code>q</code>对<code>t</code>求导），由<code>dW = uidt</code>，功率是能量对时间的导数，故元件的吸收功率为<br>$$<br>p&#x3D;\frac{dW}{dt}&#x3D;ui<br>$$<br>在<code>t_0</code>到<code>t</code>的时间内，元件吸收能量为<br>$$<br>W(t)&#x3D;\int dW &#x3D; \int_{q(t_0)}^{q(t)}udq&#x3D;\int_{t_0}^t u(\xi)i(\xi)d\xi<br>$$<br>由于<code>u</code>、<code>i</code>都是代数量，因此，功率p和吸收的能量W也都是代数量。当最后结果<code>p&gt;0</code>，<code>W&gt;0</code>，元件确实吸收功率与能量；当<code>p&lt;0</code>，<code>w&lt;0</code>时，元件实际释放电能或发出功率。</p><p>在电路中，通常将电流单位为<code>A</code>，电压的单位为<code>V</code>时，能量的单位为<code>J</code>，当时间的单位为<code>s</code>，功率的单位为<code>W</code>，来进行运算。</p><h4 id="电路吸收或发出功率判断"><a href="#电路吸收或发出功率判断" class="headerlink" title="电路吸收或发出功率判断"></a>电路吸收或发出功率判断</h4><p><img src="https://img-blog.csdnimg.cn/73aa45a1fadd4714b5c04992fe3bd55d.png" alt="img"></p><p>当由元件所吸收功率，则记为<code>+</code>，且<code>ui</code>关联（即电流和电压方向相同），也记为<code>+</code>，则最后元件所吸收功率为<code>P= ++ui</code>。如上图所示。若<code>P&gt;0</code>，则参考吸收则实际吸收，<code>P&lt;0</code>则参考吸收，实际发出（即大于零就取参考的，小于零取相反的）。（对于完整的电路而言，吸收的功率一定等于发出的功率）</p><h3 id="电路元件"><a href="#电路元件" class="headerlink" title="电路元件"></a>电路元件</h3><blockquote><p>电路元件是电路中最基本的组成单元。电路元件通过其端子与外部连接。</p><p><strong>电阻元件</strong>的元件特性是电压<code>u</code>与电流<code>i</code>的代数关系<code>f(u,i)=0</code>;<strong>电容元件</strong>的元件特性是电荷<code>q</code>与电压<code>u</code>的代数关系<code>f(q,u)=0</code>;电感元件的元件特性是磁通链<code>ψ</code> 与电流<code>i</code>的代数关系<code>f(ψ,i)=0</code>。这三种特性称之为元件的伏安特性、库伏特性和韦安特性。</p><p>电路元件按与外部连接的端子数目可分为二端、三端、四端元件等。</p><p><strong>电源是由正极流出，负极流入，电阻则是正极流入，负极流出。</strong></p></blockquote><p><strong>注意：</strong></p><p>如果表征元件端子特性的数学关系式是线性关系，该元件称为线性元件，否则成为非线性元件。</p><h3 id="电阻元件"><a href="#电阻元件" class="headerlink" title="电阻元件"></a>电阻元件</h3><blockquote><p>线性电阻元件在理想情况下：在电压和电流取关联参考方向时，在任何时刻它两端的电压和电流服从欧姆定律</p></blockquote><p>$$<br>欧姆定律：u&#x3D;Ri<br>$$</p><p>R:电阻元件的参数，称为元件的电阻。R是一个正实常数。</p><p>当电压单位为<code>V</code>，电流单位为<code>A</code>时，电阻的单位为<code>Ω</code>（欧姆，简称欧）。</p><p>$$<br>令：G&#x3D;\frac{1}{R} \得：i&#x3D;Gu<br>$$<br>在上式中称<code>G</code>为电阻元件的电导，单位<code>S</code>(西门子，简称西)。<code>R</code>和<code>G</code>都是电阻元件的参数。</p><p>若电压、电流参考方向取非关联参考方向，则<br>$$<br>u&#x3D;-Ri 或i&#x3D;-Gu<br>$$<br><strong>欧姆定律注意点：</strong></p><ul><li>只适用于线性电阻（R为常数）；</li><li>如电阻上的电压与电流参考方向非关联，公式中应冠以负号；</li><li>说明线性电阻是无记忆、双向性的元件。</li></ul><h4 id="开路和短路"><a href="#开路和短路" class="headerlink" title="开路和短路"></a>开路和短路</h4><img src="/2023/09/20/dian-lu-dian-lu-mo-xing-he-dian-lu-ding-lu/da3021b277e34206bcec699580043671.png" class="" title="da3021b277e34206bcec699580043671"><p>当电流<code>i=0</code>，电压<code>u</code>任意时，称为“开路”。此时伏安特性在<code>u-i</code>平面上与电压轴重合，相当于电阻<code>R=∞</code>或电导<code>G=0</code>。短路则相反。</p><h3 id="电压源和电流源"><a href="#电压源和电流源" class="headerlink" title="电压源和电流源"></a>电压源和电流源</h3><h4 id="理想电压源"><a href="#理想电压源" class="headerlink" title="理想电压源"></a>理想电压源</h4><p>定义：电压源两端电压总能保持定值或一定的时间函数，其值与流过他的电流i无关的元件叫理想电压源。电压源符号如图所示。</p><img src="/2023/09/20/dian-lu-dian-lu-mo-xing-he-dian-lu-ding-lu/image-20231004103601552.png" class="" title="image-20231004103601552"><p>电压源的端电压为：<br>$$<br>u(t) &#x3D;u_{s}(t)<br>$$<br>电压源的电压与通过元件的电流无关，总保持为给定的时间函数，而电流的大小则由外电路决定。</p><p><img src="https://img-blog.csdnimg.cn/e6394f5145144f61bff5a9d4608aeaa0.png" alt="img"></p><p>由上图得电流公式：<br>$$<br>i&#x3D;\frac{u_{s}}{R}<br>$$</p><h4 id="理想电流源"><a href="#理想电流源" class="headerlink" title="理想电流源"></a>理想电流源</h4><p>定义：其输出电流总能保持定值或一定的时间函数，其值与它的两端电压u 无关的元件叫理想电流源。符号如图所示。</p><p>电流源的输出电流由电源本身决定，与外电路无关；与它两端电压方向、大小无关。与电压源正好相反。</p><p><img src="https://img-blog.csdnimg.cn/b45a426327424560a38792ea604ba203.png" alt="img"></p><p>由于电流源无法确定两端的电压，需要通过外电路的情况来确定电压。可以由下图的电路来简单计算并了解下电流源。</p><p><img src="https://img-blog.csdnimg.cn/2f1cd8ea7c8d4a899c864d278e418f47.png" alt="img"></p><p>根据欧姆定律此时电压的公式应为：<br>$$<br>u&#x3D; Ri_{S}<br>$$</p><h3 id="受控电源"><a href="#受控电源" class="headerlink" title="受控电源"></a>受控电源</h3><blockquote><p>定义：电压或电流的大小和方向不是给定的时间函数，而是受电路中某个地方的电压(或电流)控制的电源，称受控源。</p><p>受控电压源或受控电流源视控制量是电压还或电流可分为电压控制电压源（VCVS，voltage control voltage source），电压控制电流源（VCCS，voltage control current source），电流控制电压源（CCVS）及电流控制电流源（CCCS）四种。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0734c027f24047f598aff8282fda4d4c.png" alt="CCCS"></p><p><img src="https://img-blog.csdnimg.cn/edfe510d0ae041b5955c4c5d184c7e05.png" alt="VCCS AND VCVS"></p><p><img src="https://img-blog.csdnimg.cn/17b64023032849f7a0d31d337e89848c.png" alt="CCVS"></p><p>算受控源一般需要通过控制的参数来进行计算。</p><h3 id="霍尔霍夫定律"><a href="#霍尔霍夫定律" class="headerlink" title="霍尔霍夫定律"></a>霍尔霍夫定律</h3><blockquote><p>基尔霍夫定律包括基尔霍夫电流定律（KCL）和基尔霍夫电压定律( KVL )。它反映了电路中所有支路电压和电流所遵循的基本规律，是分析集总参数电路的基本定律。基尔霍夫定律与元件特性构成了电路分析的基础。</p></blockquote><p>在了解霍尔霍夫定律前先要了解<strong>支路、节点和回路的概念</strong>，图中以常用为准。</p><p><img src="https://img-blog.csdnimg.cn/c9aae17ad93844679da160c379a339a3.png" alt="img"></p><p>支路（branch）：支路有两个概念，一个是电路中每一个两端元件就叫一条分支，和电路通过同一电流的分支（常用）。</p><p>节点（node）：节点有两个概念，一个是元件的连接点称为节点，和三条以上支路的连接点称为节点（常用）。</p><p><img src="https://img-blog.csdnimg.cn/f8d49c729f7b450a957976f7120813cf.png" alt="img"></p><p>路径：两结点间的一条通路。</p><p>回路（loop）：由支路组成的闭合路径。</p><p>网孔（mesh）：内部不含任何支路的回路。</p><h4 id="基尔霍夫电流定律（KCL）"><a href="#基尔霍夫电流定律（KCL）" class="headerlink" title="基尔霍夫电流定律（KCL）"></a>基尔霍夫电流定律（KCL）</h4><blockquote><p>在集总电路中，任意时刻，对任意结点流出（或流入）该结点电流的代数和等于零。</p></blockquote><p>$$<br>\sum i_{入}&#x3D;\sum i_{出}<br>$$</p><p><img src="https://img-blog.csdnimg.cn/6a939e51643b49799813cc8bb9b1f9e3.png" alt="img"></p><p>图上运用KCL可得：<br>$$<br>i_1 + i_2 &#x3D; i_3 + i_4 + i_5<br>$$</p><h4 id="基尔霍夫电压定律（KVL）"><a href="#基尔霍夫电压定律（KVL）" class="headerlink" title="基尔霍夫电压定律（KVL）"></a>基尔霍夫电压定律（KVL）</h4><blockquote><p>在集总参数电路中，任一时刻，沿任一回路，所有支路电压的代数和恒等于零。</p></blockquote><p>$$<br>\sum u_{降}&#x3D;\sum u_{升}<br>$$</p><p>主要公式运用就是标定各元件电压参考方向，并选定回路绕行方向是顺时针还逆时针。</p><p><img src="https://img-blog.csdnimg.cn/1f187fbc33bc4fabb90c7af7ab9a3114.png" alt="img"></p><p>如图所示，可得公式：<br>$$<br>-U_1 + -U_{S1} + U_2 + U_3 + U_4 + U_{S4} &#x3D; 0<br>$$<br><strong>注：KVL也适用于电路中任一假想的回路。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-顺序表的相关算法实现</title>
      <link href="/2023/09/14/shu-ju-jie-gou-shun-xu-biao-de-xiang-guan-suan-fa-shi-xian/"/>
      <url>/2023/09/14/shu-ju-jie-gou-shun-xu-biao-de-xiang-guan-suan-fa-shi-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="题目1：删除最小值"><a href="#题目1：删除最小值" class="headerlink" title="题目1：删除最小值"></a>题目1：删除最小值</h4><blockquote><p>题目：</p><p>从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。</p></blockquote><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 删除顺序表中最小值的元素</span>bool <span class="token function">SqListDeleteMinimun</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//判断顺序表是否为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 用于存放最小值</span>  ElemType minValue <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 用于存放最小值的索引</span>  <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        minValue <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//将删除的元素由最后一个元素填补</span>  <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> index<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//返回删除的值</span>  <span class="token operator">*</span>e <span class="token operator">=</span> minValue<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上方是通过<code>for</code>循环实现，时间复杂度为O(n)。</p><h4 id="题目2：逆置顺序表"><a href="#题目2：逆置顺序表" class="headerlink" title="题目2：逆置顺序表"></a>题目2：逆置顺序表</h4><blockquote><p>题目：</p><p>设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 逆置顺序表</span><span class="token keyword">void</span> <span class="token function">SqListReverse</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> right <span class="token operator">=</span> L<span class="token operator">-></span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//将元素进行交换</span>    ElemType tmp <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    left<span class="token operator">++</span><span class="token punctuation">;</span>    right<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>中间元素交换部分也可以采用异或的方式来实现，当然循环部分也可以使用<code>for(int i = 0; i&lt; L-&gt;length / 2; i++)</code>来通过进行前一半元素和后一半元素的交换来实现。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//当两个值不相同时交换位置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">!=</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      L<span class="token operator">-></span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    left<span class="token operator">++</span><span class="token punctuation">;</span>    right<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span></code></pre><h5 id="异或实现原理："><a href="#异或实现原理：" class="headerlink" title="异或实现原理："></a>异或实现原理：</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//注释表示二进制形式 异或是同位相同则为0 不相同则为1</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">//4的二进制形式为    00000000 00000000 00000000 00000100</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">//5的二进制形式为    00000000 00000000 00000000 00000101</span>a <span class="token operator">=</span> a<span class="token operator">^</span>b<span class="token punctuation">;</span> <span class="token comment">//通过异或运算后此时a为 00000000 00000000 00000000 00000001 </span>b <span class="token operator">=</span> a<span class="token operator">^</span>b<span class="token punctuation">;</span> <span class="token comment">//通过异或运算后此时b为 00000000 00000000 00000000 00000100  这里的b是和已经异或过的a重新再一次进行异或运算</span>a <span class="token operator">=</span> a<span class="token operator">^</span>b<span class="token punctuation">;</span> <span class="token comment">//通过异或运算后此时a为 00000000 00000000 00000000 00000101</span></code></pre><p>经过异或运算就将二进制位进行了交换从而实现元素交换。</p><h4 id="题目3：删除顺序表中值为x的数据元素"><a href="#题目3：删除顺序表中值为x的数据元素" class="headerlink" title="题目3：删除顺序表中值为x的数据元素"></a>题目3：删除顺序表中值为x的数据元素</h4><blockquote><p>题目：</p><p>对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//这题用的王道书的解法</span><span class="token keyword">void</span> <span class="token function">SqListDeleteX</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span>ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//计算不为x的元素</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//查询表中所有不为x的元素，并将这些元素重新排放</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            L<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>length <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token comment">//将长度改为不包含的x元素的k，之后的元素就无法通过顺序表查询到，就达到了删除的效果</span><span class="token punctuation">&#125;</span></code></pre><h4 id="题目4：删除指定区间内的元素"><a href="#题目4：删除指定区间内的元素" class="headerlink" title="题目4：删除指定区间内的元素"></a>题目4：删除指定区间内的元素</h4><blockquote><p>题目：</p><p>从顺序表中删除其值在给定值s与t之间（包含s和t，要求s&lt;t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 删除指定区间的元素</span>bool <span class="token function">SqListDeleteDomain</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType s<span class="token punctuation">,</span> ElemType t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 用来存储s的索引值</span>  <span class="token keyword">int</span> sIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 用来存储t的索引值</span>  <span class="token keyword">int</span> tIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 判断行为是否合法</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> t <span class="token operator">||</span> L<span class="token operator">-></span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">// 若值为s则将索引值赋值给sIndex</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      sIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若值为t则将索引值赋值给tIndex</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      tIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若s和t的索引值都已找到就提前结束循环</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tIndex <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 走这条说明s或t没有在顺序表中找到</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sIndex <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tIndex<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// t若为最后一个元素则直接减少长度</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>tIndex<span class="token punctuation">]</span> <span class="token operator">==</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>L<span class="token operator">-></span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L<span class="token operator">-></span>length <span class="token operator">-=</span> tIndex <span class="token operator">-</span> sIndex<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 临时存储s的索引值</span>  <span class="token keyword">int</span> tmp <span class="token operator">=</span> sIndex<span class="token punctuation">;</span>  <span class="token comment">// 将t往后的数据前移</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> tIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    tmp<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  L<span class="token operator">-></span>length <span class="token operator">=</span> L<span class="token operator">-></span>length <span class="token operator">-</span> <span class="token punctuation">(</span>tIndex <span class="token operator">-</span> sIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表的概念与C语言实现</title>
      <link href="/2023/09/13/shu-ju-jie-gou-xian-xing-biao-de-gai-nian-yu-c-yu-yan-shi-xian/"/>
      <url>/2023/09/13/shu-ju-jie-gou-xian-xing-biao-de-gai-nian-yu-c-yu-yan-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><blockquote><p><strong>注：线性表是一个逻辑结构！并不是真正物理意义上的地址相邻，而是在抽象层面的相邻，不要和顺序表搞混！</strong></p><p>线性表是具有相同数据类型的n个数据元素的有限序列。除了第一个元素意外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。</p></blockquote><p><strong>例：</strong><br>$$<br>设有一个线性表 L&#x3D;(a_1,a_2,…,a_i,a_{i+1},…,a_n)(a_1到a_n皆为int类型)\此时a_2的直接前驱为a_1,直接后继为a_3,以此类推。<br>$$</p><blockquote><p>由此，可以得出以下特点：</p><ul><li>表中元素的个数有限</li><li>表中元素具有逻辑上的顺序性</li><li>表中元素的数据类型相同，所占存储空间大小相同</li><li>元素都是数据元素，每个元素都是单个元素</li></ul></blockquote><p><strong>线性表是逻辑结构，顺序表和链表指的是存储结构，两者概念不相同。</strong></p><h3 id="顺序表的定义与实现"><a href="#顺序表的定义与实现" class="headerlink" title="顺序表的定义与实现"></a>顺序表的定义与实现</h3><h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><blockquote><p>顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使每个元素即在逻辑上相邻也在物理位置上相邻。</p><p>顺序表的第一个元素表示顺序表的起始位置，接下来的元素地理位置都是在第一个元素之后，所以可得顺序表的特点是元素的逻辑顺序（即线性表）和物理顺序相同。</p></blockquote><p>例：</p><pre class="language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;创建了一个元素都为int类型且最大长度为10的顺序表#define MaxSize 10typedef struct&#123;    int data[MaxSize]; &#x2F;&#x2F;顺序表的元素    int length;   &#x2F;&#x2F;顺序表的当前长度&#125;SqList;</code></pre><p>也可以采用动态分配的形式来创建顺序表（配合<code>malloc</code>函数）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">;</span>         <span class="token comment">//顺序表的元素，采用指针的形式</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>   <span class="token comment">//顺序表的当前长度</span>    <span class="token keyword">int</span> MaxSize<span class="token punctuation">;</span>   <span class="token comment">//顺序表的最大容量</span><span class="token punctuation">&#125;</span>SqList<span class="token punctuation">;</span></code></pre><p>当然，数组也是顺序表表的一种。例：<code>int arr[10]</code>就相当于定义了一个最大长度为10且类型都为<code>int</code>的顺序表。</p><blockquote><p>顺序表最主要的特点就是<strong>随机访问</strong>，即通过首地址和元素序号可以在时间O(1)内找到置顶的元素，但同样也有缺点，由于顺序表物理位置相邻，插入和删除操作时都必须移动大量元素。</p></blockquote><h4 id="静态顺序表的实现"><a href="#静态顺序表的实现" class="headerlink" title="静态顺序表的实现"></a>静态顺序表的实现</h4><h5 id="顺序表的创建"><a href="#顺序表的创建" class="headerlink" title="顺序表的创建"></a>顺序表的创建</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 定义布尔值</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">bool</span> <span class="token expression"><span class="token keyword">char</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">true</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">false</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token comment">// 定义元素类型</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ElemType</span> <span class="token expression"><span class="token keyword">int</span></span></span><span class="token comment">// 定义顺序表最大长度</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token comment">// 静态分配结构体</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 元素</span>  <span class="token keyword">int</span> length<span class="token punctuation">;</span>             <span class="token comment">// 长度</span><span class="token punctuation">&#125;</span> SqList<span class="token punctuation">;</span></code></pre><h5 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 静态顺序表初始化</span><span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MaxSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  L<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//默认长度为0</span><span class="token punctuation">&#125;</span></code></pre><h5 id="顺序表的插入操作"><a href="#顺序表的插入操作" class="headerlink" title="顺序表的插入操作"></a>顺序表的插入操作</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 顺序表插入操作      i为位置 e为元素</span>bool <span class="token function">SqListInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 插入位置不合法</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is an invalid action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//当前存储空间已满</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>length <span class="token operator">>=</span> MaxSize<span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token comment">//将所有元素后移</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  L<span class="token operator">-></span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>  L<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//长度增加</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="顺序表的删除操作"><a href="#顺序表的删除操作" class="headerlink" title="顺序表的删除操作"></a>顺序表的删除操作</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 顺序表删除操作            i为位置  e用于接受删除的元素</span>bool <span class="token function">SqListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> j<span class="token punctuation">;</span>  <span class="token comment">//判断输入的位置是否合法</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is an invalid action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 将删除元素告诉主函数</span>  <span class="token operator">*</span>e <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//将删除元素后的每一位都向前移</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  L<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="顺序表按指查找"><a href="#顺序表按指查找" class="headerlink" title="顺序表按指查找"></a>顺序表按指查找</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 顺序表按值查找                  e为要查找的类型</span><span class="token keyword">int</span> <span class="token function">SqListLocateElem</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 返回-1代表顺序表为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SqListIsEmpty</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//SqListIsEmpty是用于查询顺序表是否为空</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> e<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//返回0代表顺序表中无要查找的元素 </span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h3><blockquote><p>使用链式存储形式可以以”链”来建立起元素之间的逻辑关系，因此可以通过修改指针来进行插入和删除操作，但也会失去顺序表可随机存取的优点。</p></blockquote><h4 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h4><blockquote><p>线性表的链式存储又称单链表，它是通过一组任意的存储单元来存储线性表中的数据单元。</p></blockquote><p>单链表的节点类型如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">&#123;</span>    <span class="token comment">//定义单链表的结点类型</span>    ElemType data<span class="token punctuation">;</span>       <span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span>LNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span><span class="token comment">//重命名为LNode表示单个节点 *LinkList表示链表</span></code></pre><p>由于链表非随机存取的存储结构，每次要寻找一个特定的节点时，需要从表头开始遍历，依次查找。</p><p>在单链表中也分为带头节点与不带头节点。引入头节点，可以带来两个优点：</p><blockquote><ul><li>由于第一个数据结点的位置被存放在头节点的指针域中，因此在链表的第一个位置上的操作与其他表的操作一致，无需像不带头节点一样特殊处理。</li><li>无论链表是否为空，其头指针都是指向头节点的非空指针，因此空表和非空表的处理也就得到了统一。</li></ul></blockquote><h5 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h5><blockquote><p>循环单链表和单链表的区别就在于最后一个节点的<code>next</code>指向的是头节点，从而整个链表形成一个环。使单链表无论从哪开始扫描都能获得全部元素。</p></blockquote><p>由于没有节点会指向<code>NULL</code>，当判空就变成了<code>L-&gt;next == L</code>，判断链表的下一个节点是否指向本身，由于循环单链表的插入、删除算法与单链表几乎一样，除了在最后一个节点需特殊处理将后一节点指向于头节点，以让单链表保持循环的性质。</p><h4 id="单链表的基本操作实现"><a href="#单链表的基本操作实现" class="headerlink" title="单链表的基本操作实现"></a>单链表的基本操作实现</h4><h5 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a>初始化链表</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 初始化带头节点的链表</span>LNode<span class="token operator">*</span> <span class="token function">InitLNode</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//动态开辟内存空间</span>  L <span class="token operator">=</span> <span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将链表指向下一个元素为空</span>  L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//返回链表</span>  <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 判断链表是否为空</span>bool <span class="token function">LinkIsEmpty</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="按位序插入元素"><a href="#按位序插入元素" class="headerlink" title="按位序插入元素"></a>按位序插入元素</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 插入元素到单链表  在i的位置插入元素e</span>bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>LNode<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LinkIsEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  LNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                     <span class="token comment">// 当前链表所指向的位置</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 找到第i-1位置的节点</span>  <span class="token punctuation">&#123;</span>    p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 每次循环让p指向下一个节点</span>    j<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">// 如果P==NULL说明没有找到</span>  LNode <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  newNode<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>  newNode<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  p<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 在节点后插入元素</span>bool <span class="token function">InsertNextNode</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 判断是否为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LinkIsEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  LNode <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 空间不足，插入失败</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  newNode<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>  newNode<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>  L<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 在节点前插入元素  LNode为要插入的节点</span>bool <span class="token function">InsertPriorNode</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span>p<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 判断是否为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LinkIsEmpty</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  LNode <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  newNode<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>  p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>  newNode<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  p<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>   <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 删除节点</span>bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LinkIsEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  LNode <span class="token operator">*</span>tmp<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      tmp <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    i<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">*</span>e <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">;</span>  tmp<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token function">free</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="删除指定节点-无法实现要删除的元素为最后一个"><a href="#删除指定节点-无法实现要删除的元素为最后一个" class="headerlink" title="删除指定节点(无法实现要删除的元素为最后一个)"></a>删除指定节点(无法实现要删除的元素为最后一个)</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//删除指定节点</span>bool <span class="token function">DeleteNode</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>  LNode <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  p<span class="token operator">-></span>data <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">;</span>  p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="按位查找节点"><a href="#按位查找节点" class="headerlink" title="按位查找节点"></a>按位查找节点</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//按位查找</span>LNode <span class="token function">GetElem</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LinkIsEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    i<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="按值查找节点"><a href="#按值查找节点" class="headerlink" title="按值查找节点"></a>按值查找节点</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//按值查找</span>LNode <span class="token function">LocateElem</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LinkIsEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">!=</span> e <span class="token operator">&amp;&amp;</span> L <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//求表长</span><span class="token keyword">int</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    L <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> length  <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//减去表头</span><span class="token punctuation">&#125;</span></code></pre><h4 id="双链表的定义"><a href="#双链表的定义" class="headerlink" title="双链表的定义"></a>双链表的定义</h4><blockquote><p>单链表中只有一个指向后继的指针，使得链表只能从头节点依次顺序地向后遍历。为了克服单链表中的求点，引入了双链表，双链表节点中有两个指针<code>prior</code>和<code>next</code>，分别用来指向前驱节点和后继节点。</p></blockquote><p>类型定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>  <span class="token keyword">struct</span> <span class="token class-name">DNode</span> <span class="token operator">*</span>prior<span class="token punctuation">,</span><span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">//前继和后继指针</span><span class="token punctuation">&#125;</span>DNode<span class="token punctuation">,</span> <span class="token operator">*</span>DLinkList<span class="token punctuation">;</span></code></pre><blockquote><p>双链表在单链表的节点中增加了指向前驱指针<code>prior</code>，由此可以通过<code>prior</code>找到前驱节点，因此，插入、删除操作的时间复杂度仅为O(1).</p></blockquote><h5 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h5><blockquote><p>循环双链表的定义和循环单链表基本相同，就是将最后一个节点的<code>next</code>指向头节点，并将头节点的<code>prior</code>指向最后一个节点，即形成闭环。判空操作也于循环单链表如出一辙，判断<code>L-&gt;next == L &amp;&amp; L-&gt;prior == L</code>即可，而其他删除插入等操作都与双链表几乎相同。</p></blockquote><h4 id="双链表的基本操作实现"><a href="#双链表的基本操作实现" class="headerlink" title="双链表的基本操作实现"></a>双链表的基本操作实现</h4><h5 id="双链表的初始化"><a href="#双链表的初始化" class="headerlink" title="双链表的初始化"></a>双链表的初始化</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//初始化带头节点的双链表</span>DNode <span class="token operator">*</span><span class="token function">InitDLinkList</span><span class="token punctuation">(</span>DLinkList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  L <span class="token operator">=</span> <span class="token punctuation">(</span>DNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分配内存空间</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>DNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  L<span class="token operator">-></span>prior <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//前驱节点永远指向NULL</span>  L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="双链表的插入操作"><a href="#双链表的插入操作" class="headerlink" title="双链表的插入操作"></a>双链表的插入操作</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 双链表的插入操作,p节点后插入s节点</span>bool <span class="token function">InsertNextDNode</span><span class="token punctuation">(</span>DNode <span class="token operator">*</span>p<span class="token punctuation">,</span> DNode <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">// 判断p是否是最后一个节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  s<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>  p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="双链表的删除操作"><a href="#双链表的删除操作" class="headerlink" title="双链表的删除操作"></a>双链表的删除操作</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//双链表的删除操作 将p节点删除</span>bool <span class="token function">DeleteDNode</span><span class="token punctuation">(</span>DNode <span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span> p<span class="token operator">-></span>prior<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//判断是否为最后一个元素</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token operator">-></span>prior<span class="token punctuation">;</span> <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 删除p节点的后继节点</span>bool <span class="token function">DeleteNextDNode</span><span class="token punctuation">(</span>DNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token comment">// 存储p的下一个节点</span>  DNode <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">// 判断p的后继节点是否为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>    q<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//摧毁链表</span><span class="token keyword">void</span> <span class="token function">DestoryDLinkList</span><span class="token punctuation">(</span>DLinkList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>next <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//这函数即是上方用于删除后继节点</span>    <span class="token function">DeleteNextDNode</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">free</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  L <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p>查询操作和单链表基本相同，就不再过多赘述。</p></blockquote><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><blockquote><p>静态链表借用数组的特性来描述链式存储结构，即使链表在物理上也实现临近，节点也有数据域<code>data</code>和指针域<code>next</code>，只不过<code>next</code>是存放节点的相对地址（数组下标），又称游标。与顺序表一样，静态链表也要预先分配一块连续的内存空间。静态链表以<code>next == -1</code>作为其结束的标志。</p></blockquote><p><strong>静态链表结构类型</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ElemType</span> <span class="token expression"><span class="token keyword">int</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//存储数据元素</span>  <span class="token keyword">int</span> next<span class="token punctuation">;</span> <span class="token comment">//下个元素的数组下标</span><span class="token punctuation">&#125;</span> SNode<span class="token punctuation">;</span></code></pre><h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><ul><li><p><strong>存储（读写）方式</strong></p><p>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。例如在第<code>i</code>个位置上执行存或取的操作，顺序表仅需依次访问，而链表则需从表头开始依次访问<code>i</code>次。</p></li><li><p><strong>逻辑结构与物理结构</strong></p></li></ul><p>​采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。采用链式存储时，逻辑上相邻物理上并不一定相邻，得通过指针来进行查找下一个元素。</p><ul><li><strong>查找、插入和删除操作</strong></li></ul><p>​对于按值查找，顺序表无序时，两者的时间复杂度都为<code>O(n)</code>;顺序表有序可使用二分查找，复杂度为<code>O(log_2 n)</code>。</p><p>​对于序号查找，顺序表支持随机访问，时间复杂度为<code>O(1)</code>，而链表复杂度为<code>O(n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言动态内存管理</title>
      <link href="/2023/09/08/c-yu-yan-dong-tai-nei-cun-guan-li/"/>
      <url>/2023/09/08/c-yu-yan-dong-tai-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h4 id="动态内存函数"><a href="#动态内存函数" class="headerlink" title="动态内存函数"></a>动态内存函数</h4><p>为解决动态的开辟内存空间的需求，C语言提供了一个动态内存开辟的函数：</p><p><code>void *malloc( size_t size);</code></p><blockquote><p>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</p><ul><li>开辟成功后会返回指向这片空间的指针。</li><li>若失败则会返回NULL指针。</li></ul></blockquote><p>并且提供了<code>void free(void *ptr)</code>来释放不再使用的动态内存空间。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//向内存申请10个整形的空间</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向内存申请失败打印错误原因</span><span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//当动态申请空间不再使用则释放</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></code></pre><h5 id="开辟动态数组"><a href="#开辟动态数组" class="headerlink" title="开辟动态数组"></a>开辟动态数组</h5><p><code>void *calloc(size_t num,size_t size)</code>会在内存中开辟一个初始全为0的数组。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 向内存申请10个整形的空间</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 当动态申请空间不再使用则释放</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></code></pre><h5 id="调整动态开辟空间的大小"><a href="#调整动态开辟空间的大小" class="headerlink" title="调整动态开辟空间的大小"></a>调整动态开辟空间的大小</h5><p><code>void *realloc(void *memblock,size_t size)</code>当使用<code>calloc</code>或<code>malloc</code>开辟的内存空间不够用可以用<code>realloc</code>增加空间或进行调整。</p><blockquote><p>若原先开辟的空间再增加新的空间之后有足够的内存空间，则直接追加，返回原先所开辟空间的地址。</p><p>若没有足够的内存空间，则<code>realloc</code>会新开辟一个内存空间，并且将原先数据拷贝，并释放旧的内存空间，最后返回新开辟的内存地址。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 向内存申请10个整形的空间</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 为p调整到4个整形的空间</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 追加成功后再赋值地址</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  p <span class="token operator">=</span> ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 当动态申请空间不再使用则释放</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言自定义数据类型</title>
      <link href="/2023/09/06/c-yu-yan-zi-ding-yi-shu-ju-lei-xing/"/>
      <url>/2023/09/06/c-yu-yan-zi-ding-yi-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="结构体的声明"><a href="#结构体的声明" class="headerlink" title="结构体的声明"></a>结构体的声明</h4><p>结构体是用于自定义一个复杂类型（可以包括整形、字符串、浮点数等）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tag</span><span class="token punctuation">&#123;</span>    member<span class="token operator">-</span>list<span class="token operator">:</span><span class="token punctuation">&#125;</span>variable<span class="token operator">-</span>list<span class="token punctuation">;</span><span class="token comment">//例如描述一个学生：</span><span class="token keyword">struct</span> <span class="token class-name">stu</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> id<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h5 id="结构体的使用"><a href="#结构体的使用" class="headerlink" title="结构体的使用"></a>结构体的使用</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Stu</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> tele<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> sex<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> s4<span class="token punctuation">,</span>s5<span class="token punctuation">,</span>s6<span class="token punctuation">;</span> <span class="token comment">//s4  s5  s6也是全局变量</span><span class="token comment">//创建全局变量</span><span class="token keyword">struct</span> <span class="token class-name">Stu</span> s3<span class="token punctuation">;</span><span class="token comment">//匿名结构体</span><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>s<span class="token punctuation">;</span> <span class="token comment">//使用时通过 s 来进行取值</span><span class="token comment">//结构体的自引用</span><span class="token comment">//这里用链表的节点举例</span><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//保存下一个节点的地址</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">Stu</span> s1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">"zhang"</span><span class="token punctuation">,</span> <span class="token string">"1234567891"</span><span class="token punctuation">,</span> <span class="token string">"male"</span><span class="token punctuation">,</span> <span class="token number">18</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//赋值</span>  <span class="token keyword">struct</span> <span class="token class-name">Stu</span> s2<span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %s %s %d"</span><span class="token punctuation">,</span>s1<span class="token punctuation">.</span>name<span class="token punctuation">,</span>s1<span class="token punctuation">.</span>tele<span class="token punctuation">,</span>s1<span class="token punctuation">.</span>sex<span class="token punctuation">,</span>s1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取值</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h4><blockquote><p>结构体对齐规则：</p><ol><li><p>第一个成员在与结构体变量偏移量为0的地址处。</p></li><li><p>其他成员变量对齐到某个数字（对齐数）的整数倍的地址处。</p><p><strong>对齐数</strong>&#x3D;&#x3D;编译器默认的一个对齐数与该成员大小的较小值。（<code>VScode</code>中默认为8）</p></li><li><p>结构体总大小为对齐数（结构体中最大的）的整数倍。</p></li><li><p>如果是嵌套结构体，则内部嵌套的结构体的对齐数大小就是嵌套结构体数据中最大的对齐数的整数倍。</p></li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">s1</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> c1<span class="token punctuation">;</span> <span class="token comment">//vscode的默认对齐数为8 , char为1字节，取较小值，则c1占首地址偏移量为0的地址。</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token comment">//int占4字节，与默认对齐数8小，所以取4，而成员要放在对齐数的整数倍，即4的整数倍，所以放的位置为首地址偏移4，随后占4字节</span>  <span class="token keyword">char</span> c2<span class="token punctuation">;</span> <span class="token comment">//char占1字节 和 默认8 相比，取1，以1的整数倍，所以放的位置为首地址偏移9（a总共大小占了4字节）</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//经过以上偏移后再对s1进行大小计算，由于结构体大小为最大的对齐数的整数倍（这里为4），此时上方所计算出来的大小默认为9字节，要成为4的整数倍，所以最终计算结果为12字节，即下方所打印。</span><span class="token comment">//s2和s1同理</span><span class="token keyword">struct</span> <span class="token class-name">s2</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> c1<span class="token punctuation">;</span>  <span class="token keyword">char</span> c2<span class="token punctuation">;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">s1</span> s1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">s2</span> s2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="修改默认对齐数"><a href="#修改默认对齐数" class="headerlink" title="修改默认对齐数"></a>修改默认对齐数</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> </span><span class="token comment">//可将默认对齐数修改成k</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">//什么都不填，取消设置的对齐数</span></span></code></pre><p>例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token keyword">struct</span> <span class="token class-name">s1</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> c1<span class="token punctuation">;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">s1</span> s1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结果为6</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">s1</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> c1<span class="token punctuation">;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//传地址要是不想修改结构体值可以前加const ，变成const struct s1 *ps</span><span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token operator">*</span>ps<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//将1赋值给a</span>  ps<span class="token operator">-></span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">s1</span> s1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//传入s1的地址</span>  <span class="token function">Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>s1<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印 1</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h4><blockquote><p>什么是位段：</p><ol><li>位段的成员必须是<code>int</code>、<code>unsigned int</code>或<code>signed int</code>。</li><li>位段的成员名后边有一个冒号和一个数字。</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//例：</span><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//意味着a只占2bit</span>  <span class="token keyword">int</span> b <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">//意味着b只占5bit</span>  <span class="token keyword">int</span> c <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//意味着c只占10bit</span>  <span class="token keyword">int</span> d <span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">//意味着d只占30bit</span><span class="token punctuation">&#125;</span></code></pre><h5 id="位段的内存分配"><a href="#位段的内存分配" class="headerlink" title="位段的内存分配"></a>位段的内存分配</h5><blockquote><ol><li>位段的空间是按照以4个字节(<code>int</code>)或1个字节(<code>char</code>)来开辟的。</li><li>位段涉及很多不确定因素，可移植的程序慎用。</li></ol></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//意味着a只占2bit</span>  <span class="token keyword">int</span> b <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">//意味着b只占5bit</span>  <span class="token keyword">int</span> c <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//意味着c只占10bit</span>  <span class="token keyword">int</span> d <span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">//意味着d只占30bit</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">S</span> s <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 8  内存首先分配4个字节供 a b c占用，剩下d再占4字节</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>就是将把可能的取值一一列举。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//赋值只能赋值里面有的常量 值默认从0开始</span><span class="token keyword">enum</span> <span class="token class-name">Gender</span><span class="token punctuation">&#123;</span>  MALE<span class="token punctuation">,</span><span class="token comment">// 0</span>  FEMALE<span class="token punctuation">,</span><span class="token comment">// 1</span>  SECRET<span class="token comment">// 2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="联合（共用体）"><a href="#联合（共用体）" class="headerlink" title="联合（共用体）"></a>联合（共用体）</h4><p>联合是一种特殊的自定义类型，这种类型定义的变量包含一系列的成员，并公用同一块空间。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">union</span> Un<span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> c<span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">union</span> Un u<span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 4 共用同一块空间，大小为最大成员的大小</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="联合体大小的计算"><a href="#联合体大小的计算" class="headerlink" title="联合体大小的计算"></a>联合体大小的计算</h5><ul><li>联合的大小至少是最大成员的大小。</li><li>当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言字符串函数</title>
      <link href="/2023/09/03/c-yu-yan-zi-fu-chuan-han-shu/"/>
      <url>/2023/09/03/c-yu-yan-zi-fu-chuan-han-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用以下所有函数需要引入头文件<code>#include &lt;string.h&gt;</code></p></blockquote><h4 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen()函数"></a><code>strlen()</code>函数</h4><p><code>size_t strlen(const char *string)</code>传入字符串返回字符串长度，这里<code>size_t == unsigned int</code>所以这里要是直接进行比较将会以无符号数进行比较。</p><p>例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// strlen("abc") == 3  strlen("abcef") == 5 (strlen("abc") - strlen("abcef")) == 2 无符号数加减符号位默认为正</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"abcef"</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unsigned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这条语句将会打印</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"signed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="递归实现strlen-函数"><a href="#递归实现strlen-函数" class="headerlink" title="递归实现strlen()函数"></a>递归实现<code>strlen()函数</code></h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Strlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//当查询到为\0时结束递归</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>str <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//每次递归指针往后走一位，并值+1</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">my_strlen</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="strcpy-函数"><a href="#strcpy-函数" class="headerlink" title="strcpy()函数"></a><code>strcpy()</code>函数</h4><p><code>char* strcpy( char* dest, const char* src )</code>用于字符串拷贝，拷贝的时候会将<code>src</code>的<code>&#39;\0&#39;</code>一同拷贝，长度不受限制。</p><blockquote><p>想用拷贝固定个数的用<code>char* strncpy( char* dest, const char* src, size_t count )</code>用于字符串拷贝，长度受限制。</p><p><strong>使用函数时需要注意：</strong></p><ul><li>源字符串<code>src</code>必须以<code>&#39;\0&#39;</code>结束。</li><li>会将源字符串中的<code>&#39;\0&#39;</code>拷贝到目标空间<code>dest</code>。</li><li>目标空间必须足够大，以确保能放下源字符串。</li><li>目标空间必须可变。</li></ul></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span><span class="token keyword">char</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//地址查看arr1结果为 &#123;'a','b','c','\0','e','f','\0'&#125;</span><span class="token keyword">char</span> arr3<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span><span class="token keyword">char</span> arr4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token function">strncpy</span><span class="token punctuation">(</span>arr3<span class="token punctuation">,</span>arr4<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//地址查看arr1结果为 &#123;'a','b','c','\0','\0','\0','\0','\0','\0'&#125; 当要拷贝字符串长度不够会补'\0'</span></code></pre><h5 id="实现strcpy-和strnpy-函数"><a href="#实现strcpy-和strnpy-函数" class="headerlink" title="实现strcpy()和strnpy()函数"></a>实现<code>strcpy()</code>和<code>strnpy()</code>函数</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//src在这函数内并没有需要进行值变化，所以用const声明保证不可变</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">Strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//断言保证传入的不是空指针</span>  <span class="token function">assert</span><span class="token punctuation">(</span>dest <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>src <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> ret <span class="token operator">=</span> dest<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">*</span>src <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//将src的值赋值给dest的值后指针往后查找</span>    <span class="token operator">*</span>dest<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">//返回dest的起始地址</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">Strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//循环count次</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//当src没到'\0'说明不是最后一个字符</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>src <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token punctuation">;</span>      dest<span class="token operator">++</span><span class="token punctuation">;</span>      src<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">//当到最后一个字符但次数还没用完就剩下字符全为'\0'</span>      <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>      dest<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat()函数"></a><code>strcat()</code>函数</h4><p><code>char *strcat( char *strDestination, const char *strSource)</code> 将<code>strSource</code>追加到<code>strDestination</code>字符串中（此函数不可目标字符串和资源字符串相同，会因找不到<code>\0</code>而陷入死循环）。</p><blockquote><p>想用追加固定个数的用<code>char* strncat( char* strDest, const char* strSource, size_t count )</code>用于字符串追加，追加完后会补’\0’，**要是<code>count</code>个数大于<code>strSource</code>长度不会补’\0’**。</p><p><strong>使用函数时需要注意：</strong></p><ul><li>源字符串<code>strSource</code>必须以<code>&#39;\0&#39;</code>结束。</li><li>目标空间必须足够大，以确保能放下源字符串。</li><li>目标空间必须可变。</li></ul></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> arr1<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello "</span><span class="token punctuation">;</span><span class="token keyword">char</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span><span class="token function">strcat</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出 hello world </span><span class="token keyword">char</span> arr3<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdef\0xxxxxxxx"</span><span class="token punctuation">;</span><span class="token keyword">char</span> arr4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span><span class="token function">strncat</span><span class="token punctuation">(</span>arr3<span class="token punctuation">,</span>arr4<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>arr3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出 abcdefwor 后面的xxx由于前面遇到'\0’就无法显示了</span></code></pre><h5 id="实现strcat-和strncat-函数"><a href="#实现strcat-和strncat-函数" class="headerlink" title="实现strcat()和strncat()函数"></a>实现<code>strcat()</code>和<code>strncat()</code>函数</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">my_strcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strDestination<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strSource<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>strDestination<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>strSource<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>ret <span class="token operator">=</span> strDestination<span class="token punctuation">;</span>  <span class="token comment">//当strDestination值不为'\0'就继续循环查找。</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>strDestination<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    strDestination<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//这部分实现和strcpy()实现基本相同，这种写法更加简便，边自增边赋值并没有搜寻到'\0'就继续循环。</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>strDestination<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>strSource<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//根据个数追加字符串</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">Strncat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strDest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strSource<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>ret <span class="token operator">=</span> strDest<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>strDest<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    strDest<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>strSource<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>strDest <span class="token operator">=</span> <span class="token operator">*</span>strSource<span class="token punctuation">;</span>    strDest<span class="token operator">++</span><span class="token punctuation">;</span>    strSource<span class="token operator">++</span><span class="token punctuation">;</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//不管strDest的'\0'后是否还有值，直接添加完strSource的字符后添加'\0'</span>  <span class="token operator">*</span>strDest <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="strcmp-函数"><a href="#strcmp-函数" class="headerlink" title="strcmp()函数"></a><code>strcmp()</code>函数</h4><p><code>int strcmp( const char *str1, const char *str2 )</code></p><blockquote><p><code>int strncmp( const char *str1, const char *str2 ,size_t count )</code> 用于比较固定数量的字符串大小</p><p>按从左往右的顺序比较两字符串在ASCLL表中的大小。</p><ul><li><code>str1</code>大返回大于0的数字</li><li><code>str2</code>大返回小于0的数字</li><li>相等返回0。</li></ul></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//用char *声明保证是常量</span><span class="token keyword">char</span> <span class="token operator">*</span>arr1 <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>arr2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>arr3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret3 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span>arr3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-1</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arr4 <span class="token operator">=</span> <span class="token string">"abcdjf"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arr5 <span class="token operator">=</span> <span class="token string">"abcfgh"</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret4 <span class="token operator">=</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>arr4<span class="token punctuation">,</span> arr5<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret5 <span class="token operator">=</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>arr4<span class="token punctuation">,</span> arr5<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret5<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d小于f 输出 -2</span></code></pre><h5 id="strcmp-函数实现"><a href="#strcmp-函数实现" class="headerlink" title="strcmp()函数实现"></a><code>strcmp()</code>函数实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_strcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>str1 <span class="token operator">&amp;&amp;</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//当前值相等就指针往后继续查询</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str1 <span class="token operator">==</span> <span class="token operator">*</span>str2<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>str1 <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    str1<span class="token operator">++</span><span class="token punctuation">;</span>    str2<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span> <span class="token operator">*</span>str1 <span class="token operator">-</span> <span class="token operator">*</span>str2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//前者大返回大于0的数字，后者大返回小于0的数字</span><span class="token punctuation">&#125;</span></code></pre><h4 id="strstr-函数"><a href="#strstr-函数" class="headerlink" title="strstr()函数"></a><code>strstr()</code>函数</h4><p><code>char *strstr( const char *string, const char *strCharSet)</code>用于查找一个子字符串<code>strCharSet</code>。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token string">"abcdjf"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token string">"bc"</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token function">strstr</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Not Find\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 bcdjf</span><span class="token punctuation">&#125;</span></code></pre><h5 id="strstr-函数实现"><a href="#strstr-函数实现" class="headerlink" title="strstr()函数实现"></a><code>strstr()</code>函数实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">Strstr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">char</span> <span class="token operator">*</span>s1 <span class="token punctuation">,</span><span class="token operator">*</span>s2<span class="token punctuation">;</span>   <span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>str1<span class="token punctuation">;</span>  <span class="token comment">// str2为空字符串</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>str2<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>str1<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>cur<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>s1 <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>s2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>str2<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>s1 <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>s2 <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>s1 <span class="token operator">==</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      s1<span class="token operator">++</span><span class="token punctuation">;</span>      s2<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s2 <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cur<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//找不到字符串</span><span class="token punctuation">&#125;</span></code></pre><h4 id="strtok-函数"><a href="#strtok-函数" class="headerlink" title="strtok()函数"></a><code>strtok()</code>函数</h4><p><code>char * strtok( char * str, const char * sep)</code>用于分切字符串。</p><blockquote><p>第一个参数指定要切割的字符串。</p><p><code>strtok</code>函数会通过<code>sep</code>集合来找到标记，并将其用<code>\0</code>结尾，返回一个指向这个标记的指针。（此函数会改变被操作的字符串，所以要使用建议先临时拷贝）。</p><p><code>strtok</code>函数的第一个参数不为<code>NULL</code>，函数将找到<code>str</code>中的第一个标记，并保存它在字符串中的位置。以此循环，直到<code>sep</code>中的标记全部被查找完成，返回<code>NULL</code>指针。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"192.168.0.123a@b.1"</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">".@"</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1027</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>ret <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>ret <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> ret <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> ret <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//192 168 0 123a b 1</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><h4 id="memcpy-函数"><a href="#memcpy-函数" class="headerlink" title="memcpy()函数"></a><code>memcpy()</code>函数</h4><p><code>void *memcpy( void * destination, const void * source, size_t num)</code>用于拷贝数组。</p><blockquote><ul><li>从<code>source</code>的位置开始向后复制<code>num</code>个字节的数据到<code>destination</code>的内存位置。</li><li>这个函数在遇到<code>&#39;\0&#39;</code>时候并不会停止。</li><li>如果<code>source</code>和<code>destination</code>有任何的重叠，复制的结果都是未定义的。</li></ul></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span>arr1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr1 <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 1 2 3 4 5</span><span class="token punctuation">&#125;</span></code></pre><h5 id="memcpy-实现"><a href="#memcpy-实现" class="headerlink" title="memcpy()实现"></a><code>memcpy()</code>实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">Mmemcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token operator">*</span> ret <span class="token operator">=</span> dest<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>dest <span class="token operator">&amp;&amp;</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//转化为char *来通过一个一个字节来进行交换</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>dest <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>src<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>dest<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>src<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="memmove-函数"><a href="#memmove-函数" class="headerlink" title="memmove()函数"></a><code>memmove()</code>函数</h4><p><code>void *memmove( void * destination, const void * source, size_t num)</code>用于移动一个字符流到另一个中。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//把 1 2 3 4 5 拷贝到arr1[2]开始的数字后去，20==4*5代表移动5位</span><span class="token function">memmove</span><span class="token punctuation">(</span>arr1 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> arr1<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr1 <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1 2 1 2 3 4 5 8</span><span class="token punctuation">&#125;</span></code></pre><h5 id="memmove-实现"><a href="#memmove-实现" class="headerlink" title="memmove()实现"></a><code>memmove()</code>实现</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">Memmove</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>dest <span class="token operator">&amp;&amp;</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token operator">*</span>ret <span class="token operator">=</span> dest<span class="token punctuation">;</span>  <span class="token comment">//从左往右进行替换 从第一个字节往后进行替换</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>dest <span class="token operator">&lt;</span> src <span class="token operator">||</span> dest <span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>src <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>dest <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>src<span class="token punctuation">;</span>      <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>dest<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>src<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//从右往左进行替换</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dest <span class="token operator">></span> src <span class="token operator">&amp;&amp;</span> dest <span class="token operator">&lt;</span> <span class="token punctuation">(</span>src <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//for和while循环均可以实现 保证从最后一个字节往前进行替换即可</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> num   <span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>     <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>dest <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>src <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// while (num--)</span>    <span class="token comment">// &#123;</span>    <span class="token comment">//   *((char *)(dest + num)) = *((char *)(src + num));</span>    <span class="token comment">// &#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="memocmp-函数"><a href="#memocmp-函数" class="headerlink" title="memocmp()函数"></a><code>memocmp()</code>函数</h4><p><code>int memcmp( const void *ptr1, const void *ptr2, size_t num)</code>用于比较两个内存的大小。</p><blockquote><ul><li><code>ptr1 &gt; ptr2</code>返回大于0的数。</li><li><code>ptr1 &lt; ptr2</code>返回小于0的数。</li><li><code>ptr1 == ptr2</code>返回0。</li></ul></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">memcmp</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token function">memcmp</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印0 表示前8个字节结果一样</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印-1 说明arr1小于arr2</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现任何类型的冒泡排序</title>
      <link href="/2023/08/30/c-yu-yan-shi-xian-ren-he-lei-xing-de-mou-pao-pai-xu/"/>
      <url>/2023/08/30/c-yu-yan-shi-xian-ren-he-lei-xing-de-mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>根据qsort函数来实现冒泡排序版本，实现后时间复杂度为O(n^3)，仅供练习使用，实际运用效率过于低下。</p></blockquote><h4 id="qsort-函数"><a href="#qsort-函数" class="headerlink" title="qsort 函数"></a><code>qsort</code> 函数</h4><p>定义于<code>&lt;stdlib.h&gt;</code>头文件中，主要接收参数：</p><p><code>void qsort( void *ptr, [size_t] count, [size_t] size,int (*comp)(const void *, const void *) );</code></p><ul><li><code>ptr</code>为传入的数组</li><li><code>count</code>为数组的长度</li><li><code>size</code>为类型所占字节大小</li><li><code>comp</code>为一个比较函数，若前一个元素大于后面的元素则返回大于0的数，反之返回小于0的数，相等则返回0。</li></ul><p>了解<code>qsort</code>基本参数后就可将要实现的排序通过这些参数为标准来进行设计。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//主要排序函数实现</span><span class="token comment">// base:要排序的数组 sz:数组长度 width:类型所占字节大小 cmp:排序所要传的函数(通过正负来判断大小)</span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>cmp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>e1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token comment">//将强制转化为char *表示无论什么元素都只查找一个字节，但加上width后则表示当前数组单个元素所占字节大小，因此进行比较。</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>base <span class="token operator">+</span> width <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>base <span class="token operator">+</span> width <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>base <span class="token operator">+</span> width <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>base <span class="token operator">+</span> width <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//交换函数实现</span><span class="token comment">//char*表示每次只查找一个字节，通过++的方式能实现一个一个字节进行交换。</span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf2<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>buf1<span class="token punctuation">;</span>    <span class="token operator">*</span>buf1 <span class="token operator">=</span> <span class="token operator">*</span>buf2<span class="token punctuation">;</span>    <span class="token operator">*</span>buf2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    buf1<span class="token operator">++</span><span class="token punctuation">;</span>    buf2<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//要传入的排序类型实现</span><span class="token comment">// 排序整数类型</span><span class="token keyword">int</span> <span class="token function">cmp_int</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>e1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>e2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>e1 <span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>e1 <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 排序浮点数类型</span><span class="token keyword">int</span> <span class="token function">cmp_float</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>e1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>e2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>e1 <span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>e1 <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 结构体类型</span><span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">cmp_struct</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>e1<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span>e2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token operator">*</span><span class="token punctuation">)</span>e1<span class="token punctuation">)</span><span class="token operator">-></span>age <span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span><span class="token operator">-></span>age<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token operator">*</span><span class="token punctuation">)</span>e1<span class="token punctuation">)</span><span class="token operator">-></span>age <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token operator">*</span><span class="token punctuation">)</span>e2<span class="token punctuation">)</span><span class="token operator">-></span>age<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//测试</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> arrInt<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> szInt <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arrInt<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>arrInt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arrInt<span class="token punctuation">,</span> szInt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arrInt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp_int<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排序后数组： 0 1 2 3 4 5 6 7 8 9</span>    <span class="token keyword">float</span> arrFloat<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">3.1</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> szFloat <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arrFloat<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>arrFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arrFloat<span class="token punctuation">,</span> szFloat<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arrFloat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp_float<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排序后数组： 1.0 2.0 3.0 3.1 4.5</span>  <span class="token keyword">struct</span> <span class="token class-name">Student</span> s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>name <span class="token operator">:</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span> age <span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>name <span class="token operator">:</span> <span class="token string">"lisi"</span><span class="token punctuation">,</span> age <span class="token operator">:</span> <span class="token number">14</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>name <span class="token operator">:</span> <span class="token string">"wangwu"</span><span class="token punctuation">,</span> age <span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> szStu <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">bubble_sort</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> szStu<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp_struct<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//排序后数组 &#123;name : "lisi", age : 14&#125; &#123;name : "zhangsan", age : 18&#125; &#123;name : "wangwu", age : 20&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针</title>
      <link href="/2023/08/20/c-yu-yan-zhi-zhen/"/>
      <url>/2023/08/20/c-yu-yan-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h4 id="指针类型的意义："><a href="#指针类型的意义：" class="headerlink" title="指针类型的意义："></a>指针类型的意义：</h4><blockquote><p>1.指针类型决定了指针解引用操作符能访问几个字节： char* p能访问1个字节， int* p 能访问4个字节</p><p>2.指针类型决定了指针+1，-1，加的或者减的时几个字节：char* p；p+1，跳过一个字节。int* p; p+1，跳过四个字节。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x11223344</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> cp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> ip <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//00 00 00 44</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11 22 33 44</span></code></pre><h4 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h4><p>在指针类型中将<code>char*</code>称为字符指针。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//abcdef</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//abcdef</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token operator">==</span>p2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"相同"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//会进行打印，说明p1和p2指向同一块内存空间</span><span class="token punctuation">&#125;</span></code></pre><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>指针数组是用来存放指针的数组。即<code>Elemtype* p[count]</code>，例：<code>int* p[4]</code>（存放整形指针的数组）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//10 20</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>parr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">,</span> arr3<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span>parr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1  5  9</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span>parr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2  6  10  parr[j] + 1代表向后偏移一位</span><span class="token punctuation">&#125;</span></code></pre><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>数组指针就是用来存放数组的指针。</p><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// arr -首元素地址</span><span class="token comment">//&amp;arr[0] -首元素地址，和上面意思相同</span><span class="token comment">//&amp;arr -数组的地址</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span><span class="token comment">//存数组的地址 p就是数组指针</span><span class="token comment">//取址打印 最简便的方法还是另 int *p = arr; 然后(*p + i) 来取各个元素</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//方法一</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//方法二 *p == arr</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> arr2<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//字符指针</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token operator">&amp;</span>arr2<span class="token punctuation">;</span> <span class="token comment">//存放字符数组指针</span></code></pre><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token comment">//arr代表首元素的地址，</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//*(p+i) == arr[i] == p[i] 表示第i行的数据 *(*(p+i) + j) == (*(p + i))[j] == p[i][j] 表示第i行j列的数据</span>  <span class="token punctuation">&#125;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p>总结举例：</p><p><code>int arr[5]</code>是一个5个元素的整形数组</p><p><code>int *parr1[10]</code>是一个10个元素的类型为<code>int*</code>的指针数组</p><p><code>int (*parr2)[10]</code>是一个数组指针，指向了一个有10个元素的数组，每个元素的类型是<code>int</code></p><p><code>int (*parr3[10])[5]</code>是一个数组，有10个元素，每个元素是一个指向5个元素的数组指针（即第一层是放着10个指针元素的数组，每个指针所指向的是一个包含5个<code>int</code>类型元素的数组）。</p></blockquote><h4 id="数组参数、指针参数"><a href="#数组参数、指针参数" class="headerlink" title="数组参数、指针参数"></a>数组参数、指针参数</h4><h5 id="一维数组传参"><a href="#一维数组传参" class="headerlink" title="一维数组传参"></a>一维数组传参</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//以下方法均可以接受到参数</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>arr2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test2</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="二维数组传参"><a href="#二维数组传参" class="headerlink" title="二维数组传参"></a>二维数组传参</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//二维数组传参时不能省略列</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//正常运行</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//正常运行</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//报错</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//报错</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>传二维数组以指针形式接收</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//(*arr)表示首元素的指针即arr[0]</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="一级指针传参"><a href="#一级指针传参" class="headerlink" title="一级指针传参"></a>一级指针传参</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">test</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//两个结果相同</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="二级指针传参"><a href="#二级指针传参" class="headerlink" title="二级指针传参"></a>二级指针传参</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>  <span class="token function">test</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//两个结果相同</span>  <span class="token comment">//也可以传指针数组</span>  <span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>函数指针就是指向函数的指针。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>content<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> test<span class="token punctuation">;</span> <span class="token comment">//这就将函数test的地址赋值给了p</span>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> test2<span class="token punctuation">;</span> <span class="token comment">//存储无返回值的函数</span>  <span class="token comment">//通过指针调用函数</span>  <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可以打印出 Hello World</span>  <span class="token comment">//结果相同，均为函数test的地址值</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="分析函数指针代码"><a href="#分析函数指针代码" class="headerlink" title="分析函数指针代码"></a>分析函数指针代码</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从内层往外层看，显然内部的signal为一个函数声明，第一个参数为int类型，第二个参数为函数指针类型（返回值为void 接收参数为int），而外层的void(* )(int)则也是函数指针，说明signal的返回值也为函数指针类型</span><span class="token comment">//进行简化</span><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">pfun_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将函数指针重定名为pfun_t</span><span class="token class-name">pfun_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token class-name">pfun_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="创建函数指针的数组"><a href="#创建函数指针的数组" class="headerlink" title="创建函数指针的数组"></a>创建函数指针的数组</h5><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Div</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>parr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>Add<span class="token punctuation">,</span> Sub<span class="token punctuation">,</span> Mul<span class="token punctuation">,</span> Div<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//调用函数</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>parr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//5  -1  6  0</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数即用函数来调用其他函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test1调用成功\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test2调用成功,结果为:%d\n"</span><span class="token punctuation">,</span><span class="token function">pf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> test1<span class="token punctuation">;</span>   <span class="token function">test2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//两个结果都会打印.</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p><code>void* p</code> 类型的指针可以接受任意类型的地址。(<strong>但无法进行解引用，和加减等与和地址有关的操作！！！</strong>)</p><p>例：</p><p><code>int a = 1; void* p = &amp;a;</code>成立。</p><p><code>char b = &#39;a&#39;; void* p = &amp;b;</code>成立。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据存储相关</title>
      <link href="/2023/08/20/shu-ju-cun-chu-xiang-guan/"/>
      <url>/2023/08/20/shu-ju-cun-chu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h3 id="整型内存存储的数据形式"><a href="#整型内存存储的数据形式" class="headerlink" title="整型内存存储的数据形式"></a>整型内存存储的数据形式</h3><p>计算机中的有符号数（整形，**即首位为符号位，0表示”正”，1表示”负”**）有三种表示方式，即原码，反码和补码。（无符号数的原码反码补码和符号位为正时规则相同。）</p><h4 id="当符号位为正时（首位为0）"><a href="#当符号位为正时（首位为0）" class="headerlink" title="当符号位为正时（首位为0）"></a>当符号位为正时（首位为0）</h4><p>则原码反码补码相同。</p><h4 id="当符号位为负时（首位为1）"><a href="#当符号位为负时（首位为1）" class="headerlink" title="当符号位为负时（首位为1）"></a>当符号位为负时（首位为1）</h4><h5 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h5><p>将值翻译成二进制形式。</p><h5 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h5><p>原码的符号位不变，其他位依次取反。</p><h5 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h5><p>在反码的基础上+1就可以得到补码。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">//4个字节-32bit</span><span class="token comment">//转换成二进制</span><span class="token comment">//原码：00000000 00000000 00000000 00000100</span><span class="token comment">//反码：00000000 00000000 00000000 00000100</span><span class="token comment">//补码：00000000 00000000 00000000 00000100</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//转换成二进制</span><span class="token comment">//原码：10000000 00000000 00000000 00000101</span><span class="token comment">//反码：11111111 11111111 11111111 11111010</span><span class="token comment">//补码：11111111 11111111 11111111 11111100</span></code></pre><p><strong>对于整形来说：内存中存放的时补码（补码可以让加减法统一处理，无需额外的硬件电路）。</strong></p><h4 id="大小端的概念"><a href="#大小端的概念" class="headerlink" title="大小端的概念"></a>大小端的概念</h4><blockquote><p>大端（存储）模式，指数据的低位保存在内存的<strong>高</strong>地址中，而数据的高位，保存在内存的<strong>低</strong>地址中；</p><p>小端（存储）模式，指数据的低位保存在内存的<strong>低</strong>地址中，而数据的高位，保存在内存的<strong>高</strong>地址中；</p></blockquote><p>大端： 假设有十六进制数 <code>0x11223344</code>， 内存从低位到高位存储<code>0x11223344</code>。</p><p>小端： 假设有十六进制数 <code>0x11223344</code>， 内存从低位到高位存储<code>0x44332211</code>。</p><h4 id="整形提升"><a href="#整形提升" class="headerlink" title="整形提升"></a>整形提升</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//当将char类型打印整形时会进行整形提升，根据符号位来补充剩下的位以保证有32位</span><span class="token comment">//符号位为1则全补1</span><span class="token comment">//符号位为0则全补0</span><span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d,b=%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a=-1 b=255</span><span class="token comment">//a的补码：11111111</span><span class="token comment">//整形提升后补码：11111111 11111111 11111111 11111111，则原码化为十进制为-1</span><span class="token comment">//b的补码：11111111</span><span class="token comment">//因为没有符号位所以默认补充0，则整形提升后补码：0000000 00000000 00000000 11111111，则原码化为十进制为255</span></code></pre><h4 id="有符号数和无符号数区别"><a href="#有符号数和无符号数区别" class="headerlink" title="有符号数和无符号数区别"></a>有符号数和无符号数区别</h4><h5 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h5><p>当声明<code>int</code>或<code>char</code>等类型默认为有符号数，即bit的第一位为符号位（0正1负）。</p><h5 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h5><p>声明变量前使用关键字<code>unsigned</code>即为无符号数，即bit的第一位为有效位，不做符号位。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">0</span>b10000001<span class="token punctuation">;</span><span class="token comment">//有符号数 char为8bit</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token number">0</span>b10000001<span class="token punctuation">;</span><span class="token comment">//无符号数</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-127</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//129</span></code></pre><h3 id="浮点型在内存的存储形式"><a href="#浮点型在内存的存储形式" class="headerlink" title="浮点型在内存的存储形式"></a>浮点型在内存的存储形式</h3><p>任何二进制浮点数V可以根据IEEE754表示成以下形式：</p><p>$$<br>(-1)^S<em>M</em>2^E<br>$$</p><blockquote><p>(-1)^S表示符号位，当S&#x3D;0，V为正数，当S&#x3D;1,V为负数。</p><p>M表示有效数字（即化成的进制数），大于等于1，小于2.</p><p>2^E表示指数位。</p></blockquote><p><code>9.0</code>化二进制为<code>1001.0</code>用以上准则表示为<code>(-1)^0 * 1.001 * 2^3</code>，得出：<br>$$<br>S&#x3D;0 \quad M&#x3D;1.001 \quad E&#x3D;3<br>$$</p><h4 id="浮点型存入内存方式"><a href="#浮点型存入内存方式" class="headerlink" title="浮点型存入内存方式"></a>浮点型存入内存方式</h4><p><strong>IEEE 754规定：</strong>对于<strong>32位</strong>的浮点数，最高的1位是符号位s，接着8位是指数E（<strong>E为无符号数</strong>），剩下的23位位有效数字M。（为防止E出现负数，<strong>32位</strong>默认**+127<strong>后再进行存储，为了增加精度，</strong>存M时默认去掉小数点前的1**。）</p><p>即上方存储到内存中为<code>0 10000010 00100000000000000000000 </code>。</p><p>对于<strong>64位</strong>浮点数则最高的1位是符号位s，接着11位是指数E，剩下的52位位有效数字M。（规则与32位相同，<strong>64位</strong>默认**+1023**后再进行存储）</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何对后端传来的数据进行JSON序列化</title>
      <link href="/2022/11/09/ru-he-dui-hou-duan-chuan-lai-de-shu-ju-jin-xing-json-xu-lie-hua/"/>
      <url>/2022/11/09/ru-he-dui-hou-duan-chuan-lai-de-shu-ju-jin-xing-json-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在传统Web开发领域我们通过ajax请求接收到后端发来的数据时，浏览器都已经帮我们完成了<code>json</code>的序列化，而在<code>Flutter</code>显然是不支持直接显示后端接收到的请求的，如此我们就需要对请求接收到的数据进行序列化，转变成为我们能看懂的东西。这里我主要介绍<a href="https://flutter.cn/docs/development/data-and-backend/json">JSON 和序列化数据 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a>中的三种序列化方式。</p><ul><li>直接使用内联序列化JSON数据（这种方式很方便，但是在代码运行前你都无法知道你取的类型是否正确，导致代码很容易出错）</li><li></li></ul><h3 id="内联序列化JSON数据"><a href="#内联序列化JSON数据" class="headerlink" title="内联序列化JSON数据"></a>内联序列化JSON数据</h3><p>实现方法很简单，主要依靠<code>Flutter</code>内置的<code>json.decode()</code>函数来对接收到后端的数据进行解码。</p><p>先说结论，主要用的就是<code>json.decode(value.toString());</code>，就是将获取到的数据转为字符串后进行<code>json</code>解码。</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//发送请求类 这里使用的是dio来进行发请求 就简易的实现发送get请求</span><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'package:dio/dio.dart'</span></span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Request</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 配置实例</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">BaseOptions</span> _options <span class="token operator">=</span> <span class="token class-name">BaseOptions</span><span class="token punctuation">(</span>    <span class="token comment">// baseUrl配置要发请求的地址</span>    baseUrl<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">'http://127.0.0.1:3000/'</span></span><span class="token punctuation">,</span>    <span class="token comment">//连接超时时间</span>    connectTimeout<span class="token punctuation">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>    <span class="token comment">//接收超时时间</span>    receiveTimeout<span class="token punctuation">:</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建Dio实例</span>    <span class="token keyword">static</span> <span class="token class-name">Dio</span> _dio <span class="token operator">=</span> <span class="token class-name">Dio</span><span class="token punctuation">(</span>_options<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Future</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span><span class="token operator">?</span> params<span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> _dio<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> queryParameters<span class="token punctuation">:</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> _dio<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>有了发送请求类，接下来就是调用像后端发送请求。</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//这里是发送请求获取具体数据的类</span><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'package:imapp/http/request.dart'</span></span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ContactsModel</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//创建请求实例</span>  <span class="token class-name">Request</span> http <span class="token operator">=</span> <span class="token class-name">Request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//根据传入的userId来向后端发送请求</span>  <span class="token class-name">Future</span> <span class="token function">getContactsInfo</span><span class="token punctuation">(</span>int userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'/userContacts'</span></span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string-literal"><span class="token string">"userId"</span></span><span class="token punctuation">:</span> userId<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>经过上面一系列的操作后，就是具体视图层的操作。<strong>这里是主要进行序列化的地方</strong></p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//获取联系人模型，就是将上方的类进行实例化</span><span class="token class-name">ContactsModel</span> contactsModel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContactsModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用来存放获取的用户数据</span>late <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span> contactsResult<span class="token punctuation">;</span><span class="token comment">// 获取联系人</span><span class="token keyword">await</span> contactsModel    <span class="token punctuation">.</span><span class="token function">getContactsInfo</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'------------联系人数据----------'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//主要序列化的方式</span>        contactsResult <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>contactsResult<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'code'</span></span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//这就获取到了后端的数据了</span>            <span class="token function">print</span><span class="token punctuation">(</span>contactsResult<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'data'</span></span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用上方这种方法，想获取内部数据就只能用<code>map[&#39;name&#39;]</code>这种形式来读取，就很难判断类型，因此需要更好的方法。</p><h3 id="在模型类中序列化-JSON-数据"><a href="#在模型类中序列化-JSON-数据" class="headerlink" title="在模型类中序列化 JSON 数据"></a>在模型类中序列化 JSON 数据</h3><p>在上方代码中新建一个模型类来解决难以判断类型的方法。代码如下：</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//模型类 这里直接拷贝文档的代码了，想了解更多可以去阅读官方文档（文档很清晰！！！）</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>  <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span> json<span class="token punctuation">)</span>      <span class="token punctuation">:</span> name <span class="token operator">=</span> json<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'name'</span></span><span class="token punctuation">]</span><span class="token punctuation">,</span>        email <span class="token operator">=</span> json<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'email'</span></span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span> <span class="token function">toJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token string-literal"><span class="token string">'name'</span></span><span class="token punctuation">:</span> name<span class="token punctuation">,</span>        <span class="token string-literal"><span class="token string">'email'</span></span><span class="token punctuation">:</span> email<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>接下来在上方获取联系人的时候使用这个模型类</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token class-name">ContactsModel</span> contactsModel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContactsModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用来存放获取的用户数据</span>late <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span> contactsResult<span class="token punctuation">;</span><span class="token comment">// 获取联系人</span><span class="token keyword">await</span> contactsModel    <span class="token punctuation">.</span><span class="token function">getContactsInfo</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'------------联系人数据----------'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//主要序列化的方式</span>        contactsResult <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>contactsResult<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'code'</span></span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//这就获取到了后端的数据了</span>            <span class="token function">print</span><span class="token punctuation">(</span>contactsResult<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'data'</span></span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//主要操作在这！！！！！</span>            <span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>contactsResult<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'data'</span></span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment">//就可以直接使用user.email来获取到数据了</span>            <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印email</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>虽然这种方法解决了无法判断类型的问题，但仍然不是最优的方法，有没有一种方法可以直接根据我们提供的参数自动生成<code>json</code>序列化格式呢？当然是有的，官方就推荐了使用<code>json_serializable</code>。</p><p>具体如下。</p><h2 id="使用代码生成库序列化-JSON-数据"><a href="#使用代码生成库序列化-JSON-数据" class="headerlink" title="使用代码生成库序列化 JSON 数据"></a>使用代码生成库序列化 JSON 数据</h2><p>在此之前，需要安装依赖：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#这些都需要安装</span><span class="token key atrule">dependencies</span><span class="token punctuation">:</span>  <span class="token comment"># 生成依赖</span>  <span class="token key atrule">json_annotation</span><span class="token punctuation">:</span> &lt;latest_version<span class="token punctuation">></span><span class="token key atrule">dev_dependencies</span><span class="token punctuation">:</span>  <span class="token comment"># 开发依赖</span>  <span class="token key atrule">build_runner</span><span class="token punctuation">:</span> &lt;latest_version<span class="token punctuation">></span>  <span class="token key atrule">json_serializable</span><span class="token punctuation">:</span> &lt;latest_version<span class="token punctuation">></span></code></pre><p>在项目根目录下运行<code>flutter pub get 包名</code>或者直接在<code>pubspec.yaml</code>进行安装。</p><p>安装完成后，以上方当时的<code>User</code>模型类来作为例子。</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'package:json_annotation/json_annotation.dart'</span></span><span class="token punctuation">;</span><span class="token keyword">part</span> <span class="token string-literal"><span class="token string">'user.g.dart'</span></span><span class="token punctuation">;</span><span class="token comment">//这部分在使用flutter pub run build_runner watch来进行监听后会自动根据类型来生成，所以要保证前后端的参数名要一致</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>  <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>email<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">factory</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span> json<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> _$<span class="token class-name">UserFromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span> <span class="token function">toJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> _$<span class="token class-name">UserToJson</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这样就会和原先达到相同的效果，但是以更加灵活的方式来实现，调用的方法还是与第二种方法是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeorm使用distinct并有传入值时才进行where搜索</title>
      <link href="/2022/11/05/typeorm-shi-yong-distinct-bing-you-chuan-ru-zhi-shi-cai-jin-xing-where-sou-suo/"/>
      <url>/2022/11/05/typeorm-shi-yong-distinct-bing-you-chuan-ru-zhi-shi-cai-jin-xing-where-sou-suo/</url>
      
        <content type="html"><![CDATA[<h3 id="TypeOrm介绍"><a href="#TypeOrm介绍" class="headerlink" title="TypeOrm介绍"></a>TypeOrm介绍</h3><p><code>typeorm</code>是一个对象关系映射模式，主要就是为了解决面向对象与关系数据库存在的互不匹配的技术。当然使用<code>typeorm</code>可能有时候不如直接<code>sql</code>语法查询，但是使用<code>orm</code>框架可以更容易写出高内聚低耦合的代码来，主要就是为了减少重复代码的书写。</p><h3 id="使用distinct与where配合搜索"><a href="#使用distinct与where配合搜索" class="headerlink" title="使用distinct与where配合搜索"></a>使用distinct与where配合搜索</h3><p>在一些场景中，<code>typeorm</code>所提供的<code>Repository API</code>并不能满足我们查询的需求，这时候就只有两种方案，一种是直接使用<code>typeorm</code>提供的<code>query()</code>方法直接使用<code>sql</code>语句来进行复杂查询，还有就是使用查询构造器<code>Query Builder</code>来进行查询。</p><p>当然，既然我们都用<code>orm</code>框架了，当然是要减少使用<code>sql</code>语句的场景的。</p><p>此时这就有个需求，当我们需要查询数据有多条，但我们只需要其中一条，并且他的<code>where</code>的值可能是不存在的，这种场景单纯使用<code>find()</code>是解决不了的，就需要使用<code>Query Builder</code>。</p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>就如这有个<code>User</code>表，结构为：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>phone<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这时为这张表添加三个用户，让名字和手机号各有两个为相同。</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token string">'12345678910'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">,</span> <span class="token string">'12345678910'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token string">'09876543210'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此时我们要是只是想单纯查出名字叫张三的人用<code>find()</code>就能实现。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span>Repository<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    where<span class="token operator">:</span><span class="token punctuation">&#123;</span>name<span class="token operator">:</span><span class="token string">'张三'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//转换成的sql语句：SELECT * FROM user WHERE name = '张三'</span></code></pre><p>此时再加一个需求，要是查询的时候没有name这个<code>name</code>字段并且还需要对手机号进行去重后要求返回所有数据。（这里业务可能不太清晰，主要为了实现功能…）此时可能就需要使用<code>distinct</code>并且来判断<code>name</code>字段是否为空。</p><p>很显然<code>find()</code>方法中没有这个<code>distinct</code>方法，此时就得使用<code>Query Builder</code>来协助我们完成这个需求。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//因为要是直接使用where(&#123;phone:xxx&#125;)来进行查询，当传入值为null的时候就会生成WHERE phone = null这样的sql语句，显然是不符合我们的需求的，就需要动态来添加</span><span class="token comment">// 条件对象</span><span class="token keyword">const</span> whereInfo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>phone <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//如果传入的手机不为空，我们就动态为对象添加一个key 只有当phone有值的时候才会添加，否则默认全查询</span>    whereInfo<span class="token punctuation">[</span><span class="token string">'phone'</span><span class="token punctuation">]</span> <span class="token operator">=</span> phone<span class="token punctuation">&#125;</span><span class="token keyword">this</span><span class="token punctuation">.</span>Repository      <span class="token punctuation">.</span><span class="token function">createQueryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token string">'user.phone as phone'</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>User<span class="token punctuation">,</span> <span class="token string">'user'</span><span class="token punctuation">)</span> <span class="token comment">//这里的User是实体Entity的User，别名为user</span>      <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment">//开启distinct</span>      <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span>whereInfo<span class="token punctuation">)</span><span class="token comment">//使用where，里面传入数组</span>      <span class="token punctuation">.</span><span class="token function">getRawMany</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取数据</span></code></pre><p>使用上方语句，要是没传参应该是默认会获取到：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span>    <span class="token property">"phone"</span><span class="token operator">:</span><span class="token number">12345678910</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>    <span class="token property">"phone"</span><span class="token operator">:</span><span class="token number">09876543210</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>如上两条数据，当我们传入<code>phone</code>参数为：12345678910时，获取到：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span>    <span class="token property">"phone"</span><span class="token operator">:</span><span class="token number">12345678910</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>这样就完美符合我们的业务需求了，使用<code>distinct</code>来去除相同数据并使用<code>where</code>动态进行搜索。</p>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nestjs </tag>
            
            <tag> node.js </tag>
            
            <tag> typeorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nestjs的模块，控制器，提供者介绍</title>
      <link href="/2022/10/15/nestjs-de-shi-yong/"/>
      <url>/2022/10/15/nestjs-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>本文参考了<a href="https://docs.nestjs.com/">nestjs官方文档</a></p></blockquote><p>在使用了用<code>nodejs</code>搭建的<code>koa</code>和<code>express</code>框架后发现使用前端的语法也可以搭建一个不错的后端，而现在又逐渐趋势于用<code>typescript</code>来开发，就发现了<code>nestjs</code>可以很好的支持<code>typescript</code>并进行一个工程化的开发。</p><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>在开始之前，可以使用nest的脚手架来快速搭建一个nest项目。（确保Node.js（&gt;&#x3D;10.13.0,v13除外））</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i -g @nestjs/clinest new project-name <span class="token comment">#project-name为项目名，会在当前目录下新建一个nestjs项目</span></code></pre><p>创建时会让你选择用什么作为包管理工具，这里默认使用npm。</p><p><img src="https://img-blog.csdnimg.cn/b5f16a74f7e84eb5ab019f1c48fd4909.png" alt="start"></p><p>等待完成后就可以进入到项目中使用<code>npm run start</code>来运行项目了。（也可以使用<code>npm run start:dev</code>来运行启动热更新。）</p><h3 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h3><p>项目创建后，自动在<code>src</code>生成了一下文件：</p><p>app.controller.ts</p><p>app.controller.spec.ts</p><p>app.module.ts</p><p>app.service.ts</p><p>main.ts</p><p><code>main.ts</code>作为项目入口文件，默认监听了<code>3000</code>端口，并将<code>AppModule</code>进行了挂载。根据<code>nestjs</code>自动生成的这些文件就可以大概了解一个<code>nestjs</code>项目应该如何书写。</p><p><img src="https://img-blog.csdnimg.cn/4b38cf21d8334bffbd63a97067b49438.png" alt="main.ts"></p><h4 id="module"><a href="#module" class="headerlink" title="module"></a><code>module</code></h4><p>因为在<code>main.ts</code>的入口文件中引入了<code>AppModule</code>，所以首先我们先看<code>module</code>文件。</p><p><img src="https://img-blog.csdnimg.cn/d2abea4b6830477fbb30cd36c68c1da5.png" alt="module"></p><p>根据上图可以看到先前的<code>AppController</code>和<code>AppService</code>文件都是经过<code>AppModule</code>模块，这里就涉及nestjs很重要的概念，**<code>Controllers</code>和<code>Providers</code>**，这就像后端很经典的<code>MVC</code>架构，将控制层和服务层分层进行，将所有对数据库的操作都放在<code>Providers</code>(但不是所有的<code>Providers</code>都是用于操作数据库)中，将要返回前端的数据逻辑都在<code>Controllers</code>中进行，而<code>Module</code>主要为了管理控制层和服务层，有可能一个接口中需要调用多个数据库的操作，这时候就需要在<code>Module</code>中注册。</p><p><img src="https://img-blog.csdnimg.cn/e1d57f967ad6405db6f83e7970197951.png" alt="module"></p><p>在目前的Module的<code>imports</code>的部分就会用到上图的模块管理，也可以在其中结合<code>TypeOrm</code>来实现用<code>ORM</code>框架来对数据库进行操作。</p><p>总之，在每次新建了控制器或提供者就需要在<code>module</code>中进行引入，这样nest才能识别的到。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a><code>Controller</code></h4><p>在控制器中，主要处理要返回给客户端的相应相关的数据。</p><p><img src="https://nestjs.bootcss.com/assets/Controllers_1.png" alt="controller"></p><p>可以使用路由来实现一个基本的接口。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//@Controller创建一个以/text为路径的控制器</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/text'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Ctroll</span><span class="token punctuation">&#123;</span>    <span class="token comment">//当发送以/text为路径的请求并以Get的方式时会走这</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">find</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>query<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//以query的形式发送，即localhost:3000/text?a=1  query的值就是&#123;a:1&#125;</span>        <span class="token keyword">return</span> query<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>使用控制器可以接收三种类型的参数，除了上方用到的<code>query</code>，还有<code>param</code>和<code>body</code>。</p><ul><li><code>query</code>就是以<code>localhost:3000/text?a=1</code>的形式进行发送</li><li><code>param</code>就是以<code>localhost:3000/text/:id</code>的形式进行发送</li></ul><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span> <span class="token comment">//以路径的形式发送</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>param<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> param<span class="token punctuation">&#125;</span></code></pre><ul><li><code>body</code>则是以对象的形式进行发送(常用于POST请求)</li></ul><p>例：</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//发送数据</span>axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    firstName<span class="token operator">:</span> <span class="token string">'Fred'</span><span class="token punctuation">,</span>    lastName<span class="token operator">:</span> <span class="token string">'Flintstone'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//接收数据</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>body<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> body<span class="token punctuation">&#125;</span></code></pre><p>此时要是不需要操作数据库的话，就已经实现了一个简单的后端接口了，当然，还有许多如设置相应头，相应码等功能，就得通过官方文档来了解了。</p><h4 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a><code>Providers</code></h4><p><code>Providers</code>是基于nestjs的一个概念，<code>Providers</code>可以是操作数据库的服务层，也可以是<code>helpers</code>，或者其他，主要就是为了提供一些注入的依赖。</p><p><img src="https://docs.nestjs.com/assets/Components_1.png" alt="providers"></p><p>在使用<code>Service</code>之前，我们可以先连接数据库，这里以<code>mysql</code>为例，需要先下载<code>mysql</code>和<code>typeorm</code>的依赖，当然<code>typeorm</code>不是必要的,即<code>npm i mysql2</code>和<code>npm install typeorm --save</code>。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//app.module.ts</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> TypeOrmModule <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/typeorm'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> UserTable <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./entity/userTable.entity'</span><span class="token punctuation">;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    imports<span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token comment">//连接数据库</span>        <span class="token comment">// 连接数据库</span>    TypeOrmModule<span class="token punctuation">.</span><span class="token function">forRoot</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        type<span class="token operator">:</span> <span class="token string">'mysql'</span><span class="token punctuation">,</span>        host<span class="token operator">:</span> <span class="token string">'ip地址'</span><span class="token punctuation">,</span>        port<span class="token operator">:</span> 端口<span class="token punctuation">,</span>        username<span class="token operator">:</span> <span class="token string">'用户'</span><span class="token punctuation">,</span>        password<span class="token operator">:</span> <span class="token string">'密码'</span><span class="token punctuation">,</span>        database<span class="token operator">:</span> <span class="token string">'表'</span><span class="token punctuation">,</span>        entities<span class="token operator">:</span> <span class="token punctuation">[</span>UserTable<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//添加的实体 UserTable在代码在下方</span>      <span class="token comment">// 数据库同步更新</span>      synchronize<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>不过目前最多还是用来对于数据库的增删改查。<code>Providers</code>一般以<code>@Injectable()</code>开头，使用类来包裹，用构造函数来注入要修改的数据，构造函数中声明了以后，在调用函数就可以通过<code>this</code>来调用其中的函数。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//service</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TextService</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>      <span class="token decorator"><span class="token at operator">@</span><span class="token function">InjectRepository</span></span><span class="token punctuation">(</span>UserTable<span class="token punctuation">)</span> <span class="token comment">//userTable是一个用typeorm的实体，代码在下方，要是不了解typeorm可以去查看下他的官方文档</span>      <span class="token keyword">private</span> <span class="token keyword">readonly</span> userTableRepository<span class="token operator">:</span> Repository<span class="token operator">&lt;</span>UserTable<span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment">//添加私人与只读属性防止修改</span>    <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">async</span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userTableRepository<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//find是typeorm的一个方法，类似于sql语句的SELECT * FROM userTable;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Entity</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">UserTable</span><span class="token punctuation">&#123;</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">PrimaryGeneratedColumn</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Column</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    userName<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">&#125;</span></code></pre><p>当然，上方是连接了mysql后所可以进行的操作，要是没有连接mysql，则nest就会直接报错。</p><h5 id="controller中运用service"><a href="#controller中运用service" class="headerlink" title="controller中运用service"></a>controller中运用service</h5><p>在nest中基本都是通过构造函数的方式来传递相互的数据，当然这些都需要在Module模块中进行注册。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> TextService <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./financial_table.service'</span><span class="token punctuation">;</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'/text'</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Ctroll</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里就获取了Textservice了</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> textService<span class="token operator">:</span> TextService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>、    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">async</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>textService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这样就完成了基本的数据库操作了，也可以实现最基础的后端接口了，当然还有其他使用<code>Pipe</code>进行管道验证等功能可以通过官方文档来了解更多。</p>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nestjs </tag>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter中运用Provider</title>
      <link href="/2022/09/29/flutter-zhong-yun-yong-provider/"/>
      <url>/2022/09/29/flutter-zhong-yun-yong-provider/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要明白为什么用<code>Provider</code>，在原先修改数据都是通过<code>setState</code>来进行修改，这样导致视图和逻辑无法分层，使后续代码难以维护，所以可以通过<code>Provider</code>来进行更好的维护。想在<code>Flutter</code>中实现MVVC架构的话通过<code>Provider</code>是一个不错的选择，而且在<code>Provider</code>官方文档也有比较清晰的说明，这里主要就是总结我做时候的方案。（本文参考了<a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/simple#consumer">Flutter的官方文档</a>）</p><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>可以通过直接在<code>pubspec.yaml</code>在<code>dependencies</code>中添加<code>provider: 版本号</code>来直接安装<code>provider</code>。</p><p><img src="https://img-blog.csdnimg.cn/b63b2cd543e74f18b9c0ceea51d0a409.png" alt="addPackage"></p><h3 id="创建逻辑类"><a href="#创建逻辑类" class="headerlink" title="创建逻辑类"></a>创建逻辑类</h3><p>创建一个类来继承<code>Provider</code>的<code>ChangeNotifier</code>，这里用来当作改变状态的通知者。每次当状态要修改时候需要条用<code>notifyListeners()</code>才能使<code>Provider</code>知道你修改了里面的值。</p><p><img src="https://img-blog.csdnimg.cn/57f746a8fa8441d8bc6fc9a895cfccd6.png" alt="notifier"></p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">ContactsViewModel</span> <span class="token keyword">extends</span> <span class="token class-name">ChangeNotifier</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 好友列表</span>  <span class="token class-name">List</span> _friendsList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 添加好友</span>  <span class="token keyword">void</span> <span class="token function">addFriend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    _friendsList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token string-literal"><span class="token string">"img"</span></span><span class="token punctuation">:</span><span class="token string-literal"><span class="token string">"图片"</span></span><span class="token punctuation">,</span>      <span class="token string-literal"><span class="token string">"name"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"李四"</span></span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新后通知</span>    <span class="token function">notifyListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token class-name">List</span> <span class="token keyword">get</span> friendsList <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> _friendsList<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="在main-dart中接收状态"><a href="#在main-dart中接收状态" class="headerlink" title="在main.dart中接收状态"></a>在<code>main.dart</code>中接收状态</h3><p>在这不一定是非要在<code>main.dart</code>文件中使用，也可以在你需要数据文件的子组件的父组件使用，使用<code>MultiProvider</code>是因为可以有多个状态类需要监听，也可以使用单个，这里就不做演示了。（这里因为main就是父组件了，所以就直接在main这里使用）</p><p><img src="https://img-blog.csdnimg.cn/1199db5596a84bd9afabd467cfe188c9.png" alt="main"></p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">runApp</span><span class="token punctuation">(</span><span class="token class-name">MultiProvider</span><span class="token punctuation">(</span>providers<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token class-name">ChangeNotifierProvider</span><span class="token punctuation">(</span>create<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token class-name">ContactsViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">:</span> <span class="token keyword">const</span> <span class="token class-name">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>也可以在build里面中使用</strong></p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">MyApp</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token class-name">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">.</span>key<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token metadata function">@override</span>  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">MultiProvider</span><span class="token punctuation">(</span>        providers<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token class-name">ChangeNotifierProvider</span><span class="token punctuation">(</span>create<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token class-name">ContactsViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        child<span class="token punctuation">:</span> <span class="token class-name">MaterialApp</span><span class="token punctuation">(</span>          title<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">'app标题'</span></span><span class="token punctuation">,</span>          debugShowCheckedModeBanner<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>          theme<span class="token punctuation">:</span> <span class="token class-name">ThemeData</span><span class="token punctuation">(</span>primaryColor<span class="token punctuation">:</span> <span class="token class-name">Colors</span><span class="token punctuation">.</span>white<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="数据更改与获取"><a href="#数据更改与获取" class="headerlink" title="数据更改与获取"></a>数据更改与获取</h3><p>获取数据有两种方式，一个是通过<code>Provider.of&lt;逻辑类&gt;(context, listen: false).数据名</code>和<code> Consumer</code>包裹。</p><p>使用<code>Provider.of</code>来获取的话不会更新UI，即更新数据但用户看到的视图并不会进行改变，想要视图进行变更需要通过<code>Consumer</code>进行包裹， 这样可以减少<code>builder</code>的重复渲染。</p><h4 id="Provider-of来更改数据"><a href="#Provider-of来更改数据" class="headerlink" title="Provider.of来更改数据"></a><code>Provider.of</code>来更改数据</h4><p>在上方在<code>main.dart</code>中对所有<code>Widget</code>进行监听后，使用<code>Provider.of&lt;逻辑类&gt;(context, listen: false).数据名</code>的方式来进行数据修改。</p><p><img src="https://img-blog.csdnimg.cn/6ff1a90c49ac484d9a258be843c6870f.png" alt="provider"></p><p>这里调用了上方的<code>addFriend()</code>方法，当我点击右侧显示的聊天列表即会添加一个好友进<code>friendsList</code>数组中。并且在联系人的这部分使用<code>Consumer</code>来包裹，里面的数据则是用<code>friendsList</code>的数组。</p><p><img src="https://img-blog.csdnimg.cn/3dfb47389e1c4f10a4c63765f5cc2285.png" alt="consumer"></p><p>当点击后就向数组中<code>add</code>一个新对象，因为联系人列表中使用了<code>Consumer</code>包裹，所以当监听到数据有更新了，UI层也会跟着做出相应的变化。</p><p><img src="https://img-blog.csdnimg.cn/c979f4e2fbd049ffb18ca84056b8dcc5.png" alt="contact"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Provider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter实现rsa加密与解密</title>
      <link href="/2022/09/16/flutter-shi-xian-rsa-jia-mi-yu-jie-mi/"/>
      <url>/2022/09/16/flutter-shi-xian-rsa-jia-mi-yu-jie-mi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在想使用rsa加密前，应该首先了解什么是rsa加密。rsa作为目前流行的非对称加密，所需要公钥和私钥两把钥匙才能解开传输的数据。所以要使用rsa加密算法，首先就得要设置<strong>公钥</strong>和<strong>私钥</strong>（私钥一般都是放在后端，私钥在前端极其不安全，前端的代码几乎都是透明的，这里演示就全在前端中演示）。</p><h3 id="导包与获取钥匙"><a href="#导包与获取钥匙" class="headerlink" title="导包与获取钥匙"></a>导包与获取钥匙</h3><p>在<code>Flutter</code>中使用加密算法，需先在<code>pubspec.yaml</code>文件中导如<code>encrypt</code>包（版本以flutter社区的最新版为准），修改文件后保存会自动导包。</p><p><img src="https://img-blog.csdnimg.cn/a09eb410d52943a7b7e6474bf1814dad.png" alt="importPackage"></p><p>然后去获取公钥和私钥（可以在网页上生成），并放在静态资源文件夹中。</p><p><img src="https://img-blog.csdnimg.cn/66197e0ad4da47658847b835ce1788df.png" alt="key"></p><p>公钥格式为：（<code>-----BEGIN PUBLIC KEY-----</code>和结尾的<code>-----END PUBLIC KEY-----</code>是必加的，中间内容为公钥，私钥同理）</p><pre class="language-pem" data-language="pem"><code class="language-pem">-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2&#x2F;vF49zKHdP0EY1B9Zim5t4X1GsnP1TEYgYMnWXQNLluWV53iInEJBmw&#x2F;xf++Ohbgp7WhAFcjlRJ6Bxnqj6nCtAsXAjIXnv1UDCabw&#x2F;pUb2Tm349I990wSGEeIbuSRPD&#x2F;t1O4qOTgpvCWRDgVVfXPILWBkshMhQA7xs0LeEXtimtCLnjUywlXw+Hthlx2Zi6Ba656HKro9EPZ2BRGGUdmbPLWibeD7MF8ETz5R0w&#x2F;N+3GyTnizPihsFU4sPOnWwhsR0FWz0i+uVeYrIkpyo6hkXFQMLt4RzA9VVsd+nk5h&#x2F;SQ&#x2F;NQ38VrpUlLfcL4K&#x2F;pzUXCrJ6X5KYOIfEcG16QGsQIDAQAB-----END PUBLIC KEY-----</code></pre><p>私钥格式为：</p><pre class="language-pem" data-language="pem"><code class="language-pem">-----BEGIN PRIVATE KEY-----MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDb+8Xj3Mod0&#x2F;QRjUH1mKbm3hfUayc&#x2F;VMRiBgydZdA0uW5ZXneIicQkGbD&#x2F;F&#x2F;746FuCntaEAVyOVEnoHGeqPqcK0CxcCMhee&#x2F;VQMJpvD+lRvZObfj0j33TBIYR4hu5JE8P+3U7io5OCm8JZEOBVV9c8gtYGSyEyFADvGzQt4Re2Ka0IueNTLCVfD4e2GXHZmLoFrrnocquj0Q9nYFEYZR2Zs8taJt4PswXwRPPlHTD837cbJOeLM+KGwVTiw86dbCGxHQVbPSL65V5isiSnKjqGRcVAwu3hHMD1VWx36eTmH9JD81DfxWulSUt9wvgr+nNRcKsnpfkpg4h8RwbXpAaxAgMBAAECggEAOXZP39CJnzcBVyBd7WhdmIrFEMCYtOtQjQZlfyvcMhmJ4KBTev&#x2F;5kzB+0nOTL7OKS9lv0XWFlswfrhjVX1wUSDfOjo&#x2F;gvwWEM9kuTfqLCMYLa5+TGu7A0b4Om2krjz0xgj6O35a47nH&#x2F;V0KYRtK2L2FBxM0VM76T6+FgROe6SOOn8BOvAiljHu+hzxOAx8T881daO2TpLXGcwSHcT8UfhIIiE7KBjqUmgDQwkBNcZvhduhNsSMBjNpf0sws6N2bJ3fK&#x2F;Yo+23obW03yKqdWOXZ1&#x2F;QD8PfdRn1gkNn1HwNKTUJuC2K7gUNfHugYDywz2wL2YMiGwzBKOdVULMMPhzkQKBgQD3e2bOIcW5+OOeabIqgGBzoOLaElUwJtFKZBNPG84t+mfYAzwHYkf416WXsR6ql0mLsmZaKBGYk+H5&#x2F;Kco1xxPfHlENHHZVfof1K1pQLxLoF9vW7rtMVT+CwdgbppBXoVDcqkri8h9aVPTPL&#x2F;Dq6a9qFfcTO+wlfnCgaxXqlDAtQKBgQDjjhPx8sf55G7dZjl9wzfgGjsBRxOeecWrdcfRy4S&#x2F;WxTC0NwTNaPMyb534RbwHh&#x2F;MDg9naoLg0kUZQ+AfzleUC5D&#x2F;PI0G8fO7qADXenb2ZwflBkyw5JmSsk2iJ8tREFgLfqAKrGDTSVc33q6mfm+fZHvZsGVUgxvrriB1EZc3jQKBgFlUib9OIXkHheHgdRcyT55tLHVauLUwzcr0ZKPhfYLLKECoqjpgF2qTLIqcvF0HTtzGAHv6ip9wgdkigZQUUXu&#x2F;imY8J&#x2F;wzNJ3Yvt+HJnCF6uzfR5HmhK9Oe9MrGTMPUzsNYFL&#x2F;mdbq9f8BppaSlxVOdqhmfP5YpFa5R+Q87fkhAoGBAKnTrGEC72o5qOAFXdzVKEtRaD4A3MyGVxcq1NFnUZA6mpj2pXiUrMW2vzbav3K&#x2F;GL4CtE5bOIgvhbBgbtFt&#x2F;wCXTUSf3SSUyHGB5fbrCAPHSyYK+IuAYHkSJ0xg5KWATCVwAGNW2QB3GOeygqfxbr8HkEMcGdPj8Z+IGeMlGLU1AoGBANpu3Sx5J6ELxpL3110I6GfhmADZ&#x2F;k8rTlkST+sfUJI1R3TcKqLBbyiNd1id1O1rKrnPfym41lNWz6MWRn6m1GPrdTNZIfMJugEfJyaF2vojWyFXMEA&#x2F;pvjfHeEjQLsoEoupKXLH&#x2F;Tkm6zaNunJHcX2rgz3C2PGugq1h2EZGBU5z-----END PRIVATE KEY-----</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>接下来就是通过函数来进行全局使用。</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'package:encrypt/encrypt.dart'</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'package:flutter/services.dart'</span></span><span class="token punctuation">;</span><span class="token comment">// 加密 Future代表异步操作</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">encodeString</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> publicPem <span class="token operator">=</span> <span class="token keyword">await</span> rootBundle<span class="token punctuation">.</span><span class="token function">loadString</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'key/public.pem'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//key/public.pem为我上方放的公钥位置 这里不可使用encrypt文档中的parseKeyFromFile方法，会显示找不到文件</span>  <span class="token keyword">dynamic</span> publicKey <span class="token operator">=</span> <span class="token class-name">RSAKeyParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>publicPem<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> encrypter <span class="token operator">=</span> <span class="token class-name">Encrypter</span><span class="token punctuation">(</span><span class="token function">RSA</span><span class="token punctuation">(</span>publicKey<span class="token punctuation">:</span> publicKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加密使用公钥</span>  <span class="token keyword">return</span> encrypter<span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">.</span>base64<span class="token punctuation">;</span> <span class="token comment">//返回加密后的base64格式文件</span><span class="token punctuation">&#125;</span><span class="token comment">// 解密</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">decodeString</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> privatePem <span class="token operator">=</span> <span class="token keyword">await</span> rootBundle<span class="token punctuation">.</span><span class="token function">loadString</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'key/private.pem'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">dynamic</span> privateKey <span class="token operator">=</span> <span class="token class-name">RSAKeyParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>privatePem<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">final</span> encrypter <span class="token operator">=</span> <span class="token class-name">Encrypter</span><span class="token punctuation">(</span><span class="token function">RSA</span><span class="token punctuation">(</span>privateKey<span class="token punctuation">:</span> privateKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解密使用私钥</span>      <span class="token keyword">return</span> encrypter<span class="token punctuation">.</span><span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token class-name">Encrypted</span><span class="token punctuation">.</span><span class="token function">fromBase64</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="实际运行"><a href="#实际运行" class="headerlink" title="实际运行"></a>实际运行</h3><p><img src="https://img-blog.csdnimg.cn/0aa9eb0c8e8d4a2080c56893cff7e530.png" alt="show"></p><p>我在按钮中添加了点击事件，当点击后会调用<code>encodeString</code>方法，因为方法使用了<code>Future</code>包裹为异步返回结果，所以都用<code>then</code>进行取值（前端的小伙伴应该很熟悉），最后进行打印，然后又将获得的加密数据进行解密并打印（实际运行结果看下面结果图）。</p><p><img src="https://img-blog.csdnimg.cn/d7a0233a28744dedbd0afdc76324c3e9.png" alt="final"></p><p>可见数据成功进行了加密并解密了。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart语言学习</title>
      <link href="/2022/09/06/dart-yu-yan-xue-xi/"/>
      <url>/2022/09/06/dart-yu-yan-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>最近想开发一个即时通讯的app，想要通过跨端平台来做一个app，众所周知，目前比较流行的跨端平台有<code>electron</code>(主要桌面开发)、<code>uniapp</code>(小程序方面应用多)、<code>react native</code>(和<code>flutter</code>在app占比差不多)和<code>flutter</code>。当时技术选型时，因为本人是对<code>Vue</code>为主要前端框架进行深入学习，所以开发app时候<code>react native</code>就没有纳入我的范围，<code>uniapp</code>又因为觉得做小程序比较多，在网上搜索<code>uniapp</code>对app的兼容不如<code>react native</code>和<code>flutter</code>，所以最后就决定选择学习<code>flutter</code>来作为主要开发工具。</p><p>本文主要介绍<code>Dart</code>的基本语法，<code>Dart</code>大部分都是为了<code>flutter</code>而服务，所以这里并不会对<code>Dart</code>进行过多的了解，相信要是有<code>javascript</code>或<code>java</code>语言等高级语言基础的话，可以很快的进行入门。</p><blockquote><p>文章参考了<a href="https://dart.cn/">Dart</a>的官网。</p></blockquote><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Dart</code>和<code>Java</code>一样是面向对象的语言，所以他们都有一个<code>main</code>方法，要是数据不是在函数体内声明，则默认为全局方法，不会像<code>Javascript</code>那种面向编程的语言一样，无论在什么环境修改变量都不会报错，在<code>Dart</code>中，全局是默认只能声明不能进行修改的，要想数据必须在<code>void main()&#123;&#125;</code>中，所以以下的代码测试默认处于<code>void main()&#123;&#125;</code>环境。</p><h3 id="Dart数据类型"><a href="#Dart数据类型" class="headerlink" title="Dart数据类型"></a>Dart数据类型</h3><p><code>Dart</code>的数据类型基本与<code>Java</code>的相同，作为一个类型安全的语言，虽然其中可以使用<code>var</code>来声明变量，但声明后就不能修改类型。</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'小明'</span></span><span class="token punctuation">;</span>name <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">//报错</span></code></pre><p>所以要用类型最好就在声明时候确定下来。</p><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'小明'</span></span><span class="token punctuation">;</span></code></pre><h4 id="Dart数据类型种类"><a href="#Dart数据类型种类" class="headerlink" title="Dart数据类型种类"></a>Dart数据类型种类</h4><table><thead><tr><th align="center">类型</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center">Numbers（数字）</td><td align="center">int a &#x3D; 1;或double &#x3D; 2.1;</td></tr><tr><td align="center">Strings（字符串）</td><td align="center">String a &#x3D; ‘你好’;</td></tr><tr><td align="center">Booleans（布尔）</td><td align="center">bool b &#x3D; true;</td></tr><tr><td align="center">Lists（数组）</td><td align="center">var list &#x3D; [1, 2, 3];</td></tr><tr><td align="center">Sets（无序集合）</td><td align="center">var halogens &#x3D; {‘fluorine’, ‘chlorine’, ‘bromine’, ‘iodine’, ‘astatine’}; 或 var names &#x3D; <String>{};</td></tr><tr><td align="center">Map（对象，即Key:value）</td><td align="center">var gifts &#x3D; {‘first’: ‘partridge’,   ‘second’: ‘turtledoves’,   ‘fifth’: ‘golden rings’ }; 或构造器创建：var gifts &#x3D; Map&lt;String, String&gt;();</td></tr><tr><td align="center">Runes</td><td align="center">需要导入 <a href="https://pub.flutter-io.cn/packages/characters">characters 包</a>，可以用Unicode字符来显示emoji表情，如：大笑的 emoji 表情（😆）的 Unicode 为 <code>\u&#123;1f600&#125;</code>。</td></tr><tr><td align="center">Symbols（用的比较少）</td><td align="center">Symbol obj &#x3D; new Symbol(‘name’);</td></tr><tr><td align="center">null</td><td align="center">null即为null</td></tr></tbody></table><p><strong>各种数值类型具体使用方法下方介绍！（以下Numbers，Strings，Booleans皆可用var声明）</strong></p><h5 id="Numbers（数字类型）"><a href="#Numbers（数字类型）" class="headerlink" title="Numbers（数字类型）"></a>Numbers（数字类型）</h5><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//定义整数类型</span>int a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">10.9</span><span class="token punctuation">;</span> <span class="token comment">//报错</span>a <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'123'</span></span><span class="token punctuation">;</span> <span class="token comment">//报错</span><span class="token comment">//定义浮点数类型</span>double b <span class="token operator">=</span> <span class="token number">1.9</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> <span class="token comment">//不报错</span>b <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'123'</span></span><span class="token punctuation">;</span> <span class="token comment">//报错</span></code></pre><h5 id="Strings（字符串）"><a href="#Strings（字符串）" class="headerlink" title="Strings（字符串）"></a>Strings（字符串）</h5><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//定义字符串</span><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'123'</span></span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">//报错</span>s <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'147'</span></span><span class="token punctuation">;</span> <span class="token comment">//不报错</span></code></pre><h5 id="Booleans（布尔）"><a href="#Booleans（布尔）" class="headerlink" title="Booleans（布尔）"></a>Booleans（布尔）</h5><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//定义布尔</span>bool b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//报错</span>b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//不报错</span></code></pre><h5 id="Lists（数组）"><a href="#Lists（数组）" class="headerlink" title="Lists（数组）"></a>Lists（数组）</h5><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//定义一个内部全为字符串的数组 &lt;>符号是为了限制类型</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'1'</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">'2'</span></span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//不报错</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//报错</span></code></pre><h5 id="Sets（无序集合）"><a href="#Sets（无序集合）" class="headerlink" title="Sets（无序集合）"></a>Sets（无序集合）</h5><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//用&#123;&#125;创建时候默认为Map，Dart通过调用方法来判断为Set还是Map &lt;>用来限制Set里面为String类型</span><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>elements<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'fluorine'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>elements<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string-literal"><span class="token string">'a'</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">'b'</span></span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出&#123;fluorine, a, b&#125;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>num<span class="token punctuation">></span></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出 &#123;2&#125;</span></code></pre><h5 id="Map（对象）"><a href="#Map（对象）" class="headerlink" title="Map（对象）"></a>Map（对象）</h5><pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token comment">//定义一个key和value都是字符串的对象</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> m <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string-literal"><span class="token string">'a'</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">'a的value'</span></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'a'</span></span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出 a的value</span></code></pre><p><strong>Runes和Symbol目前用的比较少，所以也没有过多研究，等到时候摸透了再回来补….</strong></p>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dart </tag>
            
            <tag> android </tag>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常用语句总结</title>
      <link href="/2022/09/01/mysql-yu-ju/"/>
      <url>/2022/09/01/mysql-yu-ju/</url>
      
        <content type="html"><![CDATA[<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASE 数据库名；</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">drop database 数据库名;</code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">#IF NOT 表示不存在就创建CREATE TABLE IF NOT 表名 (column_name column_type);</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">#AUTO_INCREMENT 表示自增 NOT NULL表示不为空 PRIMARY表示主键CREATE TABLE IF NOT user(id int PRIMARY KEY NOT NULL AUTO_INCREMENT,name VARCHAR(20) NOT NULL);</code></pre><h3 id="表创建时添加外键约束"><a href="#表创建时添加外键约束" class="headerlink" title="表创建时添加外键约束"></a>表创建时添加外键约束</h3><p>两个表之间需要相关的值的话就可以使用外键约束，并且设置外键的字段名所用的是主表的主键字段才行。</p><h4 id="表创建时添加外键约束-1"><a href="#表创建时添加外键约束-1" class="headerlink" title="表创建时添加外键约束"></a>表创建时添加外键约束</h4><pre class="language-mysql" data-language="mysql"><code class="language-mysql">CONSTRAINT 外键名 FOREIGN KEY(从表的外键字段名) REFERENCES 主表名(主表的主键字段名)</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">#主表CREATE TABLE IF NOT user(id int PRIMARY KEY NOT NULL AUTO_INCREMENT,name VARCHAR(20) NOT NULL);#从表CREATE TABLE user_contacts (id INT PRIMARY KEY NOT NULL,name VARCHAR(20) not null,avatar VARCHAR(40),user_id INT,    #添加外键约束CONSTRAINT fk_user_contacts_user FOREIGN KEY(user_id) REFERENCES user(id));</code></pre><h4 id="已存在表添加外键约束"><a href="#已存在表添加外键约束" class="headerlink" title="已存在表添加外键约束"></a>已存在表添加外键约束</h4><pre class="language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY(从表的外键字段名) REFERENCES 主表名(主表的主键字段名)</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">#主表用上方的user表ALTER TABLE user_contacts ADD CONSTRAINT fk_user_contacts_user FOREIGN KEY(user_id) REFERENCES user(id)</code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">DROP TABLE table_name ;</code></pre><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN );</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO user(id,name,phone,permissions) VALUES(1,&#39;张三&#39;,&#39;17857956137&#39;,&#39;管理员&#39;)</code></pre><h3 id="为已有表添加字段"><a href="#为已有表添加字段" class="headerlink" title="为已有表添加字段"></a>为已有表添加字段</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">alter table 表名 ADD 字段名 字段类型</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">alter table user ADD password varchar(20)</code></pre><h3 id="将已有字段设置为非空字段"><a href="#将已有字段设置为非空字段" class="headerlink" title="将已有字段设置为非空字段"></a>将已有字段设置为非空字段</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">alter table 表名 CHANGE 字段名 字段名 字段类型 NOT NULL;</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">alter table login_user CHANGE phone phone VARCHAR(11) NOT NULL;</code></pre><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><pre class="language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 DROP 字段名;</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE user DROP name;</code></pre><h3 id="更新表字段数据"><a href="#更新表字段数据" class="headerlink" title="更新表字段数据"></a>更新表字段数据</h3><h4 id="更新所有"><a href="#更新所有" class="headerlink" title="更新所有"></a>更新所有</h4><pre class="language-mysql" data-language="mysql"><code class="language-mysql">update 表名 set 字段名 &#x3D; 要修改的数据</code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">update user set password &#x3D; &#39;123456&#39;</code></pre><h3 id="字段默认值"><a href="#字段默认值" class="headerlink" title="字段默认值"></a>字段默认值</h3><h4 id="创建表时添加默认值"><a href="#创建表时添加默认值" class="headerlink" title="创建表时添加默认值"></a>创建表时添加默认值</h4><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create table 表名(  name varchar(50) not null default &#39;0&#39;)</code></pre><h4 id="为已存在字段附上默认值"><a href="#为已存在字段附上默认值" class="headerlink" title="为已存在字段附上默认值"></a>为已存在字段附上默认值</h4><pre class="language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 ALTER COLUMN 字段名 SET DEFAULT 默认值</code></pre><p><strong>(注：已有默认值的话需要先删除默认值后再添加，删除语法：<code>alter table 表名 alter column 字段名 drop default</code>)</strong></p><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE login_user ALTER COLUMN password SET DEFAULT &#39;123456&#39;</code></pre><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><pre class="language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM 表名</code></pre><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="查询表中的字段数量"><a href="#查询表中的字段数量" class="headerlink" title="查询表中的字段数量"></a>查询表中的字段数量</h5><pre class="language-mysql" data-language="mysql"><code class="language-mysql">SELECT count(*)  FROM 表名</code></pre><h5 id="查询出固定数量"><a href="#查询出固定数量" class="headerlink" title="查询出固定数量"></a>查询出固定数量</h5><pre class="language-mysql" data-language="mysql"><code class="language-mysql">#偏移量不填默认为0SELECT * FROM 表名 LIMIT 偏移量,数量 </code></pre><p>例子：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">#查出user表中第10条开始，取出11条数据SELECT * FROM user LIMIT 10,11</code></pre><h4 id="使用distinct去重查询"><a href="#使用distinct去重查询" class="headerlink" title="使用distinct去重查询"></a>使用distinct去重查询</h4><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> 列<span class="token punctuation">,</span>列<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">from</span> 表</code></pre><p>例子：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#查出user表中name和address不相同的数据</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> name<span class="token punctuation">,</span>address <span class="token keyword">from</span> <span class="token keyword">user</span></code></pre><h4 id="查询列为空的值"><a href="#查询列为空的值" class="headerlink" title="查询列为空的值"></a>查询列为空的值</h4><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表 <span class="token keyword">where</span> 字段 <span class="token operator">is</span> <span class="token boolean">null</span></code></pre><p>例子：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#查出user表中address为空的值</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> address <span class="token operator">is</span> <span class="token boolean">null</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现方法的重载</title>
      <link href="/2022/08/26/javascript-shi-xian-fang-fa-de-chong-zai/"/>
      <url>/2022/08/26/javascript-shi-xian-fang-fa-de-chong-zai/</url>
      
        <content type="html"><![CDATA[<p>最近在使用<code>node.js</code>做后端时，想使用方法重载来实现一个函数可以接收不同的参数，但是<code>javascript</code>作为一个弱类型语言，无法实现方法的重载，就只能通过奇淫技巧来实现。</p><p>目前发现的方法有：</p><ul><li>使用<code>arguments</code> 参数的长度来判断传入参数的数量，从而实现不同业务逻辑</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//使用arguments来实现方法重载</span><span class="token keyword">function</span> <span class="token function">OverLoad</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//arguments.length===0说明没有传入参数</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>           代码块           <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">//传入了name走这块</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>           代码块           <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">//传入了age走这块</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>           代码块           <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>直接判断传入的参数是否为<code>undefined</code>。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">OverLoad</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>name<span class="token operator">===</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//走这说明没有传参</span>        代码块        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>age<span class="token operator">===</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//走这说明只传了一个参数</span>        代码块        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//走这说明只参数都传了</span>    代码块<span class="token punctuation">&#125;</span></code></pre></li></ul><p>用上面几种方法都有大量的判断语句，没有很好的实现重载，网上还有些通过闭包来实现，但现在可以使用<code>class</code>中的<code>#</code>来实现属性的私有，这里就没有介绍闭包的方法了。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取扇贝单词接口数据</title>
      <link href="/2022/08/19/huo-qu-shan-bei-dan-ci-jie-kou-shu-ju/"/>
      <url>/2022/08/19/huo-qu-shan-bei-dan-ci-jie-kou-shu-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>@<a href="%E4%B8%8D%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%89%87%E8%B4%9D%E5%8D%95%E8%AF%8D%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE">TOC</a></p><p>最近想做一个背单词相关的app，要是自己一个个去网站搜然后再复制到数据库中太慢了，所以就考虑能不能通过接口或者python自动将数据爬下来。</p><h2 id="第一步，登录并寻找可以爬取的数据（想直接看结论可以到第四步）"><a href="#第一步，登录并寻找可以爬取的数据（想直接看结论可以到第四步）" class="headerlink" title="第一步，登录并寻找可以爬取的数据（想直接看结论可以到第四步）"></a>第一步，登录并寻找可以爬取的数据（想直接看结论可以到第四步）</h2><p>首先要先登录去寻找扇贝单词中有显示单词的地方，在我找了一圈，发现在<a href="https://web.shanbay.com/wordsweb/#/study/entry">单词学习</a>的词表中（这要先自己提前添加一本词书），只要自己单词还没有开始背，可以在未学单词中来获取本词书的单词数据。</p><p><img src="https://img-blog.csdnimg.cn/69df9b19dee44d9281c715ec6ddc89a2.png" alt="单词展示"><br><strong>到这未学单词页面，首先就是先查看扇贝单词是通过服务器渲染还是客户端渲染，要是服务器渲染，在源码中就可以直接看到单词的数据，那样就可以直接通过python来进行爬取，要是客户端渲染，那就得考虑通过调用接口来拿取单词数据了。<br>这里我到源码中去搜索matter这个单词。</strong></p><p><img src="https://img-blog.csdnimg.cn/b17678c83bec4ddfbb1a8bf95c1241a5.png" alt="搜索单词"><br><strong>结果发现，源码中并没有这个单词的数据，就说明得通过接口的方式来获得数据了。</strong></p><h2 id="第二步，对症下药"><a href="#第二步，对症下药" class="headerlink" title="第二步，对症下药"></a>第二步，对症下药</h2><p><strong>那此时就是得通过F12的网络检查来进行抓包了。（注意：这里要在<code>Fetch/XHR</code>中才会更清晰的展示）</strong><br><img src="https://img-blog.csdnimg.cn/c3d5174dceb3496094757f8034a74c37.png" alt="抓包"></p><p><strong>通过下方的按钮，我们转换到第二页，看看发送的网络请求是什么样的。</strong><br><img src="https://img-blog.csdnimg.cn/c3729808b1894649b600c730ecbe4b1c.png" alt="抓包2"></p><p><strong>这里我们可以点击后在<code>preview</code>中查看，发现数据是有返回的，但却做了加密。</strong><br><img src="https://img-blog.csdnimg.cn/8481dc11da664837a7d455e4e2443e54.png" alt="加密数据"><br><strong>到这一步，接下来的问题也就明确了很多，就是需要来解密他这个数据了。</strong></p><h2 id="第三步，解密接口"><a href="#第三步，解密接口" class="headerlink" title="第三步，解密接口"></a>第三步，解密接口</h2><p>接下来点击<code>initiator</code>，来查看接口发请求的时候所调用的栈是怎么样的<br><img src="https://img-blog.csdnimg.cn/3c8476d4710041268c5f9b5cdb22dae5.png" alt="检查栈"><br>上方图片中蓝色标记的就是调用的文件名，因为我先前已经研究过扇贝的源码了，这里就直接到他接口解密的位置。（即在<code>learning.ts</code>文件）</p><p><img src="https://img-blog.csdnimg.cn/238bd63f26e746ae9eed673240e97328.png" alt="源文件"><br><strong>看着代码可以发现，代码发请求的url就是获取单词的url，所以可以断定就是通过了<code>bayDecode</code>来进行了解密（对比url图片在下面）</strong><br><img src="https://img-blog.csdnimg.cn/4427125400d5470980212dbc9f0843a9.png" alt="请求链接"><br><strong>接下来就需要先去寻找下解密的具体代码到底是什么，这里通过<code>Ctrl+F</code>调出搜索来搜索<code>bayDecode</code>在哪里出现过。</strong><br><img src="https://img-blog.csdnimg.cn/fefe31de104441ab880f9320231e92ef.png" alt="搜索"><br><strong>发现<code>bayDecode</code>是从<code>helpers</code>中解构出的一个函数，那接下来就是去寻找<code>helpers</code>文件所在位置了</strong><br><img src="https://img-blog.csdnimg.cn/ef9764d270fc4750a215b149c825cd43.png" alt="搜索"><br><strong>这里我就直接找出来给大家看代码所在位置</strong><br><img src="https://img-blog.csdnimg.cn/48ae33f41a8b49b69c861e2d2f0e6451.png" alt="bayDecode"><br><strong>上图可以发现，原来是调用了<code>bays4.d()</code>方法，并且还挂载在了<code>window</code>，那解密我们就可以直接通过别人写好的，直接在控制台中调用<code>bays4.d()</code>来进行解密(这里要是有兴趣也可以使用<code>debug</code>来看扇贝是怎么实现加密的)</strong></p><h2 id="第四步，使用现成的方法获取数据"><a href="#第四步，使用现成的方法获取数据" class="headerlink" title="第四步，使用现成的方法获取数据"></a>第四步，使用现成的方法获取数据</h2><p><strong>回到发请求的地方，将返回的加密数据<code>Ctrl+C</code>复制</strong><br><img src="https://img-blog.csdnimg.cn/e8db973b7bdd4340932f96eaf9652571.png" alt="复制"><br><strong>然后到控制台中，直接在控制台调用<code>bays4.d()</code>方法。</strong><br><img src="https://img-blog.csdnimg.cn/26717b7c45ac482382d158bac526196b.png" alt="调用函数"><br><strong>然后将加密的数据直接<code>Ctrl+V</code>粘贴进去，回车一按！</strong><br><img src="https://img-blog.csdnimg.cn/7bda675ab4784c0b92fc868c5f1903ea.png" alt="获取json"><br><strong>发现接口的数据我们就获取到了，最后再将数据保存到json格式中，使用vscode或其他编译器来查看</strong><br><img src="https://img-blog.csdnimg.cn/3532dbc8cedd47d894b541cdd635e322.png" alt="数据"><br><strong>音频，单词，中文释义，轻轻松松获取到。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3的ref与reactive的区别</title>
      <link href="/2022/08/18/vue3-de-ref-yu-reactive-de-qu-bie/"/>
      <url>/2022/08/18/vue3-de-ref-yu-reactive-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h4 id="Vue3中使用ref和reactive需要注意的点"><a href="#Vue3中使用ref和reactive需要注意的点" class="headerlink" title="Vue3中使用ref和reactive需要注意的点"></a>Vue3中使用ref和reactive需要注意的点</h4><p>最近在开发项目中，想到复杂的数据对象都应该用<code>reactive</code>，就想用<code>reactive</code>来接收父组件传来的值，再通过<code>emit</code>传递回去。</p><p>但在这遇到了一个坑，用<code>reactive</code>来接收对象时，控制台输出没有问题，但页面显示却是空白！</p><p>目前要实现的是一个编辑的功能，列表中的数据是通过父组件传递给子组件数据实现的，因为要保证单向数据流，所以当用户点击编辑按钮的时候（即触发<code>handleEdit</code>），将从父组件收到的点击的那一条数据存到<code>form</code>中。</p><img src="/2022/08/18/vue3-de-ref-yu-reactive-de-qu-bie/showpage.png" class=""><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// 对类型进行限制</span><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">&#123;</span>  barTitle<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>BarType<span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment">//这里类型不用多了解，就是为了减少维护成本</span>  tableData<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token comment">// 提供初始值</span><span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">withDefaults</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span>Props<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">barTitle</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function-variable function">tableData</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 点击编辑按钮后的模态框</span><span class="token keyword">const</span> dialogFormVisible <span class="token operator">=</span> <span class="token generic-function"><span class="token function">ref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">// 选择要编辑的索引值</span><span class="token keyword">let</span> indexEdit <span class="token operator">=</span> <span class="token generic-function"><span class="token function">ref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 用来编辑表格数据</span><span class="token keyword">let</span> form<span class="token operator">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 点击编辑按钮的回调</span><span class="token keyword">const</span> <span class="token function-variable function">handleEdit</span> <span class="token operator">=</span> <span class="token punctuation">(</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> row<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  dialogFormVisible<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">true</span>  indexEdit<span class="token punctuation">.</span>value <span class="token operator">=</span> index  form <span class="token operator">=</span> props<span class="token punctuation">.</span>tableData<span class="token punctuation">[</span>index<span class="token punctuation">]</span>  <span class="token comment">// console.log(index, row)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!-- 弹窗后的页面部分，与上方的页面不是同个代码 这里的props就是每个字段的标题，和表单的数据名相同 --&gt;    &lt;el-dialog v-model&#x3D;&quot;dialogFormVisible&quot; title&#x3D;&quot;编辑&quot;&gt;      &lt;el-form ref&#x3D;&quot;ruleFormRef&quot; &gt;        &lt;el-form-item :label-width&#x3D;&quot;formLabelWidth&quot; v-for&#x3D;&quot;item in barTitle&quot; :key&#x3D;&quot;item&quot;          label&#x3D;&quot;item.name&quot; &gt;          &lt;el-input v-model&#x3D;&quot;form[item.props]&quot; autocomplete&#x3D;&quot;off&quot; &#x2F;&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item :label-width&#x3D;&quot;formLabelWidth&quot;&gt;          &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;submitForm()&quot;&gt;Submit&lt;&#x2F;el-button&gt;          &lt;el-button @click&#x3D;&quot;resetForm()&quot;&gt;Reset&lt;&#x2F;el-button&gt;        &lt;&#x2F;el-form-item&gt;      &lt;&#x2F;el-form&gt;    &lt;&#x2F;el-dialog&gt;</code></pre><p>当点击了编辑后，理想状态应该是每个数据都会通过<code>v-model</code>展示在模态框中，即下图（这里点击的是第一个用户，即<code>index=0</code>）</p><img src="/2022/08/18/vue3-de-ref-yu-reactive-de-qu-bie/modalShow.png" class=""><p>但用<code>reactive</code>来做数据代理实际的效果却是：</p><img src="/2022/08/18/vue3-de-ref-yu-reactive-de-qu-bie/showpage2.png" class=""><p>并没有展示出预想的效果，结果去[官网](<a href="https://staging-cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#limitations-of-reactive">响应式基础 | Vue.js (vuejs.org)</a>)查看了 <code>reactive</code>只能进行深度监听，如果修改了第一层的值就会丢失响应！所以才会导致上方的响应丢失。如下代码，我在使用<code>reactive</code>在点击编辑的时候将最外层的对象进行的改变，所以导致了丢失响应。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 上面的引用 (&#123; count: 0 &#125;) 将不再被追踪（响应性连接已丢失！）</span>state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>真正的做法应该是把<code>let form:any = reactive(&#123;&#125;)</code>改为<code>let form:any = ref(&#123;&#125;)</code>后续调用内部数据加上<code>value</code>，这样就能正常实现响应式了。于此同时，要是对象或数组嵌套要实现响应式，就推荐用<code>reactive</code>，可以实行深度监听。</p>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js-fs文件操作模块</title>
      <link href="/2022/07/14/node-js-fs-wen-jian-cao-zuo-mo-kuai/"/>
      <url>/2022/07/14/node-js-fs-wen-jian-cao-zuo-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h3 id="fs文件操作模块"><a href="#fs文件操作模块" class="headerlink" title="fs文件操作模块"></a>fs文件操作模块</h3><p><code>fs</code>作为node.js的内置模块，只需用<code>require(&quot;fs&quot;)</code>引入后即可使用。可以用js来实现对计算机文件的增删改查操作</p><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在根目录下创建avatar文件夹 创建成功err为null，反之则有失败的原因</span>fs<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token string">'./avatar'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="目录重命名"><a href="#目录重命名" class="headerlink" title="目录重命名"></a>目录重命名</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//将avatar改名为avatar2</span>fs<span class="token punctuation">.</span><span class="token function">rename</span><span class="token punctuation">(</span><span class="token string">'./avatar'</span><span class="token punctuation">,</span><span class="token string">'./avatar2'</span><span class="token punctuation">,</span><span class="token parameter">err</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//删除名为avatar2的目录</span>fs<span class="token punctuation">.</span><span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token string">'./avatar2'</span><span class="token punctuation">,</span><span class="token parameter">err</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="往文件中写入数据-会覆盖其中内容"><a href="#往文件中写入数据-会覆盖其中内容" class="headerlink" title="往文件中写入数据  会覆盖其中内容"></a>往文件中写入数据  会覆盖其中内容</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//往text.txt文件中写入helloworld 文件不存在会自动创建</span>fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token string">'./text.txt'</span><span class="token punctuation">,</span><span class="token string">'helloWorld'</span><span class="token punctuation">,</span><span class="token parameter">err</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="往文件中追加数据"><a href="#往文件中追加数据" class="headerlink" title="往文件中追加数据"></a>往文件中追加数据</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//往text.txt文件中追加123 文件不存在会自动创建</span>fs<span class="token punctuation">.</span><span class="token function">appendFile</span><span class="token punctuation">(</span><span class="token string">'./text.txt'</span><span class="token punctuation">,</span><span class="token string">'\n123'</span><span class="token punctuation">,</span><span class="token parameter">err</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 读取的为字符流需转换 文件不存在则data为undefined 并且err有值</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./text.txt'</span><span class="token punctuation">,</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript">fs<span class="token punctuation">.</span><span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">'./text.txt'</span><span class="token punctuation">,</span><span class="token parameter">err</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="读取文件夹下的所有文件名和文件类型"><a href="#读取文件夹下的所有文件名和文件类型" class="headerlink" title="读取文件夹下的所有文件名和文件类型"></a>读取文件夹下的所有文件名和文件类型</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//读取dir目录下的所有文件 目录不存在则报错 返回值为数组</span>fs<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span><span class="token string">'./dir'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="同步删除文件"><a href="#同步删除文件" class="headerlink" title="同步删除文件"></a>同步删除文件</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript">fs<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span><span class="token string">'./dir'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>   data<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>     <span class="token comment">//使用Sync会将异步代码转为同步执行</span>     fs<span class="token punctuation">.</span><span class="token function">unlinkSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./dir/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>item<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="Promise读取文件"><a href="#Promise读取文件" class="headerlink" title="Promise读取文件"></a>Promise读取文件</h4><p>使用<code>promise</code>需要读取fs模块下的<code>promises</code>方法，即<code>const fs = require(&#39;fs&#39;).promises</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//这样读取的好处是不需要用sync来特地将代码转换为同步读取</span>fs<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token string">'./dir'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="使用Promise来删除文件夹下的所有文件"><a href="#使用Promise来删除文件夹下的所有文件" class="headerlink" title="使用Promise来删除文件夹下的所有文件"></a>使用Promise来删除文件夹下的所有文件</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>   fs<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span><span class="token string">'./dir'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>     data<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>       fs<span class="token punctuation">.</span><span class="token function">unlink</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./dir/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>item<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>   <span class="token comment">//删除内部文件后再删除目录</span>     fs<span class="token punctuation">.</span><span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token string">'./dir'</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js-http模块</title>
      <link href="/2022/07/12/nodejs-http-mo-kuai/"/>
      <url>/2022/07/12/nodejs-http-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h3 id="启动服务器热更新"><a href="#启动服务器热更新" class="headerlink" title="启动服务器热更新"></a>启动服务器热更新</h3><p>默认方式重启服务器为<code>node file</code>。</p><p>在全局安装<code>npm i -g nodemon</code>后可以自动服务器热更新</p><p>输入命令<code>nodemon file</code>即可开启热更新</p><h3 id="搭建HTTP服务器"><a href="#搭建HTTP服务器" class="headerlink" title="搭建HTTP服务器"></a>搭建HTTP服务器</h3><p>搭建一个简单的HTTP web 服务器</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//获取HTTP模块</span><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token comment">// 设置端口号</span><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">3000</span><span class="token comment">// 创建</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">//req接收浏览器传的参数</span>  <span class="token comment">//res 返回渲染的内容</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/html;charset=utf-8'</span><span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'你好世界\n'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 监听端口是否被访问，访问则输出其中内容</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">服务器已经启动</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="url模块介绍"><a href="#url模块介绍" class="headerlink" title="url模块介绍"></a>url模块介绍</h4><p>在引入<code>url</code>模块后，可以很好的对路由参数进行处理。</p><p>首先要使用<code>new URL(input[, base])</code>对路径进行解析</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token keyword">const</span> myURL <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myURL<span class="token punctuation">)</span></code></pre><p>上方输出一个对象</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token literal-property property">href</span><span class="token operator">:</span> <span class="token string">'https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'</span><span class="token punctuation">,</span>  <span class="token literal-property property">origin</span><span class="token operator">:</span> <span class="token string">'https://sub.example.com:8080'</span><span class="token punctuation">,</span>  <span class="token literal-property property">protocol</span><span class="token operator">:</span> <span class="token string">'https:'</span><span class="token punctuation">,</span>  <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span>  <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">'pass'</span><span class="token punctuation">,</span>  <span class="token literal-property property">host</span><span class="token operator">:</span> <span class="token string">'sub.example.com:8080'</span><span class="token punctuation">,</span>  <span class="token literal-property property">hostname</span><span class="token operator">:</span> <span class="token string">'sub.example.com'</span><span class="token punctuation">,</span>  <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token string">'8080'</span><span class="token punctuation">,</span>  <span class="token literal-property property">pathname</span><span class="token operator">:</span> <span class="token string">'/p/a/t/h'</span><span class="token punctuation">,</span>  <span class="token literal-property property">search</span><span class="token operator">:</span> <span class="token string">'?query=string'</span><span class="token punctuation">,</span>  <span class="token literal-property property">searchParams</span><span class="token operator">:</span> URLSearchParams <span class="token punctuation">&#123;</span> <span class="token string">'query'</span> <span class="token operator">=></span> <span class="token string">'string'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">hash</span><span class="token operator">:</span> <span class="token string">'#hash'</span><span class="token punctuation">&#125;</span></code></pre><p>当传入的<code>input</code>为相对路径的情况下</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token keyword">const</span> myURL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'/foo'</span><span class="token punctuation">,</span> <span class="token string">'https://example.org/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myURL<span class="token punctuation">)</span><span class="token comment">// https://example.org/foo</span></code></pre><h4 id="http服务器端发请求"><a href="#http服务器端发请求" class="headerlink" title="http服务器端发请求"></a>http服务器端发请求</h4><p>因为在浏览器端向服务器发送数据有时候会产生跨域问题，而在服务器端互相发送请求不会产生跨域，就产生用node来作为中间件进行发送请求，然后再将node获取的数据传回给前端，这样就不会产生跨域问题。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//获取HTTP模块</span><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> https <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'https'</span><span class="token punctuation">)</span><span class="token comment">// 设置端口号</span><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">3000</span><span class="token comment">// 创建</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>     <span class="token comment">//设置请求头</span>    <span class="token string-property property">"Content-Type"</span><span class="token operator">:</span> <span class="token string">"application/json;charset=utf-8"</span><span class="token punctuation">,</span>    <span class="token comment">//允许跨域</span>    <span class="token string-property property">"access-control-allow-origin"</span><span class="token operator">:</span> <span class="token string">"*"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token comment">//调用get方法  以回调函数形式写入数据</span>  <span class="token function">httpGet</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token comment">//调用post方法 </span>  <span class="token comment">//HttpPost(data=>&#123;res.end(data)&#125;)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 监听端口是否被访问，访问则输出其中内容</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">服务器已经启动</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h5 id="使用http发送get请求"><a href="#使用http发送get请求" class="headerlink" title="使用http发送get请求"></a>使用http发送get请求</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//httpGet 函数 </span><span class="token keyword">function</span> <span class="token function">httpget</span><span class="token punctuation">(</span><span class="token parameter">rs</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token string">''</span>  <span class="token comment">//模拟向猫眼发送请求数据</span>  https<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'https://i.maoyan.com/api/mmdb/movie/v3/list/hot.json?ct=%E6%9D%AD%E5%B7%9E&amp;ci=50&amp;channelId=4'</span><span class="token punctuation">,</span><span class="token parameter">res</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//返回数据流，在data将数据保存</span>    res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token parameter">chunk</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        data <span class="token operator">+=</span>chunk    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//在end模块将数据返回到服务器中</span>    res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>      <span class="token function">rs</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="使用http发送post请求"><a href="#使用http发送post请求" class="headerlink" title="使用http发送post请求"></a>使用http发送post请求</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//HttpPost 函数</span><span class="token keyword">function</span> <span class="token function">HttpPost</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token string">''</span>  <span class="token comment">//模拟向小米优品获取数据</span>  <span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">hostname</span><span class="token operator">:</span><span class="token string">'m.xiaomiyoupin.com'</span><span class="token punctuation">,</span>    <span class="token comment">//http协议端口号默认80 https协议端口号默认443</span>    <span class="token literal-property property">port</span><span class="token operator">:</span><span class="token string">'443'</span><span class="token punctuation">,</span>    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/mtop/mf/resource/data/batchList'</span><span class="token punctuation">,</span>    <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'POST'</span><span class="token punctuation">,</span>    <span class="token literal-property property">headers</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>      <span class="token string-property property">"Content-Type"</span><span class="token operator">:</span><span class="token string">"application/json"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> req <span class="token operator">=</span> https<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token parameter">chunk</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>      data <span class="token operator">+=</span>chunk    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>      <span class="token function">cb</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  req<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"newer_popup_ad"</span><span class="token punctuation">,</span> <span class="token string">"download_options"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  req<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="node搭建路由"><a href="#node搭建路由" class="headerlink" title="node搭建路由"></a>node搭建路由</h3><p>路由作为web开发中不可或缺的一部分，掌握路由可以更好的协助开发，并且能让代码显现的更有条理性。</p><p>搭建一个路由总共有以下几部分：</p><ol><li>开启服务器</li><li>静态资源管理</li><li>接口的提供</li></ol><h4 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h4><p>开启服务器可以直接使用<code>node</code>自带的<code>http</code>模块</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//这里用于使用下方的api接口路径</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server start'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>这样就在本地的3000端口开启了一台本地服务器</p><h4 id="静态资源管理"><a href="#静态资源管理" class="headerlink" title="静态资源管理"></a>静态资源管理</h4><p>每次访问服务器时，要判断是不是要访问静态资源中的文件，如果是的话要对其访问进行放行。</p><p>在编写代码前需要引入node内置的<code>path</code>和<code>fs</code>模块，即<code>require(&#39;fs&#39;)</code>和<code>require(&#39;path&#39;)</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 静态资源管理</span><span class="token keyword">function</span> <span class="token function">readStaticFile</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span>req</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> myURL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span><span class="token string">'http://127.0.0.1'</span><span class="token punctuation">)</span>  <span class="token comment">//__dirname为node内置的静态变量，可以获取当前目录</span>  <span class="token comment">//十四用path.join将当前目录和发请求的url地址进行拼接</span>  pathname <span class="token operator">=</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span>myURL<span class="token punctuation">.</span>pathname<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">existsSync</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token comment">//这里判断了为css样式的，其他需要额外添加</span>    <span class="token function">setHead</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span><span class="token string">'text/css'</span><span class="token punctuation">,</span>pathname<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// console.log(__dirname,__dirname+myURL.pathname)</span><span class="token punctuation">&#125;</span></code></pre><p>根据上面代码可以做一个简单的静态资源管理，调用该函数判断是属于静态资源范围则认为是合法路径，不是则返回false，进行下一步的逻辑。</p><h4 id="api接口"><a href="#api接口" class="headerlink" title="api接口"></a>api接口</h4><p>这里只写了<code>get</code>和<code>post</code>两种请求，实际开发可能会根据<code>Restful</code>接口规范开发。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//这里定义的apiRouter对象用于暴露给其他模块</span><span class="token keyword">const</span> apiRouter <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//因为上方在本地3000端口开的服务器，所以当访问 http://127.0.0.1/api/login走当前函数</span>  <span class="token string-property property">'/api/login'</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> req</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> myURL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token string">"http://127.0.0.1"</span><span class="token punctuation">)</span>    <span class="token comment">//这里判断前端传来的参数，即 http://127.0.0.1/api/login?username=123</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>myURL<span class="token punctuation">.</span>searchParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">render</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&#123;"ok":1&#125;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token function">render</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&#123;"error":"错误"&#125;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">//发送的为post请求</span>  <span class="token string-property property">'/api/loginpost'</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> req</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> post <span class="token operator">=</span> <span class="token string">''</span>    <span class="token comment">//将数据收集</span>    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token parameter">chunk</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>      post <span class="token operator">+=</span> chunk    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//当数据收集结束后向前端返回数据</span>    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span>      post <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span>      <span class="token function">render</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&#123;"ok":0&#125;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//该函数用于复用上方重复的操作</span><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token string">'application/json'</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> status <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"Content-Type"</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>type<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">;charset=utf-8</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>   <span class="token comment">//end即表示返回给前端的数据</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm包管理器</title>
      <link href="/2022/07/08/npm-bao-guan-li-qi/"/>
      <url>/2022/07/08/npm-bao-guan-li-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="npm包管理器简介"><a href="#npm包管理器简介" class="headerlink" title="npm包管理器简介"></a>npm包管理器简介</h3><p><code>npm</code> 是 Node.js 标准的软件包管理器。现在也可以使用<code>yarn</code>来代替<code>npm</code>作为一个包管理器。</p><h4 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h4><ul><li><p>下载<code>npm</code> 可以管理项目依赖:<code>npm i </code> 或 <code>npm install</code> </p><p>它会在 <code>node_modules</code> 文件夹（如果尚不存在则会创建）中安装项目所需的所有东西。</p></li><li><p>安装单个软件包<code>npm i &lt;package-name&gt; </code> 或 <code>npm install &lt;package-name&gt;</code> </p><ul><li><p>在安装软件包的时候添加<code>--save</code>表明安装并添加条目到 <code>package.json</code> 文件的 dependencies。</p></li><li><p><code>--save-dev</code> 安装并添加条目到 <code>package.json</code> 文件的 devDependencies。</p><p>区别主要是，<code>devDependencies</code> 通常是开发的工具（例如测试的库），而 <code>dependencies</code> 则是与生产环境中的应用程序相关。</p></li></ul></li><li><p>更新所有软件包：<code>npm update</code></p></li><li><p>更新指定软件包：<code>npm update &lt;package-name&gt;</code></p></li><li><p>运行指定任务：</p><p>在项目的<code>package.json</code>中的<code>scripts</code>配置了指定命令行任务可以通过<code>npm run &lt;task-name&gt;</code>进行运行。</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token comment">//webpack中启动服务器同理</span><span class="token punctuation">&#123;</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"watch"</span><span class="token operator">:</span> <span class="token string">"webpack --watch --progress --colors --config webpack.conf.js"</span><span class="token punctuation">,</span>    <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"webpack --progress --colors --config webpack.conf.js"</span><span class="token punctuation">,</span>    <span class="token property">"prod"</span><span class="token operator">:</span> <span class="token string">"NODE_ENV=production webpack -p --config webpack.conf.js"</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h4 id="npm软件包安装位置"><a href="#npm软件包安装位置" class="headerlink" title="npm软件包安装位置"></a>npm软件包安装位置</h4><p>当使用 <code>npm</code> 安装软件包时，可以执行两种安装类型：</p><ul><li>本地安装</li><li>全局安装</li></ul><p>默认情况下，当输入 <code>npm install</code> 命令时，默认将所有包安装到当前项目的<code>node_modules</code>文件夹中。</p><p>在这种情况下，<code>npm</code> 还会在当前文件夹中存在的 <code>package.json</code> 文件的 <code>dependencies</code> 属性中添加所安装包名的条目。</p><p>使用 <code>-g</code> 标志可以执行全局安装：<code>npm install -g</code></p><p>在 macOS 或 Linux 上，此位置可能是 <code>/usr/local/lib/node_modules</code>。 在 Windows 上，可能是 <code>C:\Users\YOU\AppData\Roaming\npm\node_modules</code>。</p><p>但是，如果使用 <code>nvm</code> 管理 Node.js 版本，则该位置会有所不同。</p><p>例如，使用 <code>nvm</code>，则软件包的位置可能为 <code>/Users/joe/.nvm/versions/node/v8.9.0/lib/node_modules</code>。</p><h4 id="使用npm安装的软件包"><a href="#使用npm安装的软件包" class="headerlink" title="使用npm安装的软件包"></a>使用npm安装的软件包</h4><p>在node.js中使用<code>require</code>来引入npm安装的包</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> lodash</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> _ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span></code></pre><p>通过<code>npm i</code>命令下载了一些可执行文件，一般都会放在<code>node_modules/.bin/</code> 文件夹下。</p><p>当想要执行这些文件可以输入 <code>./node_modules/.bin/name</code> 来运行它，但是最新版本的 npm（自 5.2 起）中包含的 npx 是更好的选择。 只需运行：</p><pre class="language-bash" data-language="bash"><code class="language-bash">npx name</code></pre><p>通过npx执行只需要在项目根目录就可输入，不需要进行下一步寻找路径。</p><h4 id="查看npm包安装的版本"><a href="#查看npm包安装的版本" class="headerlink" title="查看npm包安装的版本"></a>查看npm包安装的版本</h4><p>使用<code>npm list</code>可以查看当前目录下已安装的所有<code>npm</code>软件包：</p><pre class="language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>Study<span class="token punctuation">\</span>node.js<span class="token operator">></span>npm listnode.js@ D:<span class="token punctuation">\</span>Study<span class="token punctuation">\</span>node.js+-- cowsay@1.5.0`-- express@4.18.1</code></pre><p>使用<code>npm list -g</code>可以获取全局安装的软件包：</p><pre class="language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>Study<span class="token punctuation">\</span>node.js<span class="token operator">></span>npm list -gC:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>sink<span class="token punctuation">\</span>AppData<span class="token punctuation">\</span>Roaming<span class="token punctuation">\</span>npm+-- @vue/cli@5.0.4+-- hexo-cli@4.3.0+-- json-server@0.17.0+-- nodemon@2.0.15+-- typescript@4.6.4`-- vercel@24.2.4</code></pre><p>若要仅获取顶层的软件包（基本上就是告诉 npm 要安装并在 <code>package.json</code> 中列出的软件包），则运行 <code>npm list --depth=0</code>：</p><pre class="language-none"><code class="language-none">D:\Study\node.js&gt;npm list --depth&#x3D;0node.js@ D:\Study\node.js+-- cowsay@1.5.0&#96;-- express@4.18.1</code></pre><p>想要查看<code>npm</code>包中所依赖的包有哪些将<code>depth</code>的值进行修改即可。</p><h4 id="安装npm包中的旧版本"><a href="#安装npm包中的旧版本" class="headerlink" title="安装npm包中的旧版本"></a>安装npm包中的旧版本</h4><p>可以使用 <code>@</code> 语法来安装 npm 软件包的旧版本：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>package<span class="token operator">></span>@<span class="token operator">&lt;</span>version<span class="token operator">></span></code></pre><p>使用以下命令可以安装 1.2.0 版本：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> cowsay@1.2.0</code></pre><p>全局的软件包也可以这样做：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g webpack@4.16.4</code></pre><p>可能还有需要列出软件包所有的以前的版本。 可以使用 <code>npm view &lt;package&gt; versions</code>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"> <span class="token function">npm</span> view cowsay versions<span class="token punctuation">[</span> <span class="token string">'1.0.0'</span>,  <span class="token string">'1.0.1'</span>,  <span class="token string">'1.0.2'</span>,  <span class="token string">'1.0.3'</span>,  <span class="token string">'1.1.0'</span>,  <span class="token string">'1.1.1'</span>,  <span class="token string">'1.1.2'</span>,  <span class="token string">'1.1.3'</span>,  <span class="token string">'1.1.4'</span>,  <span class="token string">'1.1.5'</span>,  <span class="token string">'1.1.6'</span>,  <span class="token string">'1.1.7'</span>,  <span class="token string">'1.1.8'</span>,  <span class="token string">'1.1.9'</span>,  <span class="token string">'1.2.0'</span>,  <span class="token string">'1.2.1'</span>,  <span class="token string">'1.3.0'</span>,  <span class="token string">'1.3.1'</span> <span class="token punctuation">]</span></code></pre><h4 id="查看npm的依赖包是否需要更新"><a href="#查看npm的依赖包是否需要更新" class="headerlink" title="查看npm的依赖包是否需要更新"></a>查看npm的依赖包是否需要更新</h4><p>使用<code>npm outdated</code>命令可以查看当亲目录下的包的版本与最新版本，可以根据自己需要调用<code>npm update</code>来对包进行更新，运行<code>npmupdate</code>不会更新目前已经是主流版本的包</p><h4 id="npm版本控制说明"><a href="#npm版本控制说明" class="headerlink" title="npm版本控制说明"></a>npm版本控制说明</h4><p>在<code>package.json</code>或<code>package-lock.json</code>的  <code>version</code>块中，通常版本分为<code>x.y.z</code>（x表示主版本，y表示次版本,z表示补丁版本）三个数字。</p><p>当发布新的版本时，不仅仅是随心所欲地增加数字，还要遵循以下规则：</p><ul><li>当进行不兼容的 API 更改时，则升级主版本。</li><li>当以向后兼容的方式添加功能时，则升级次版本。</li><li>当进行向后兼容的缺陷修复时，则升级补丁版本。</li></ul><p>该约定在所有编程语言中均被采用，每个 <code>npm</code> 软件包都必须遵守该约定，这一点非常重要，因为整个系统都依赖于此。</p><p><code>npm</code> 设置了一些规则，可用于在 <code>package.json</code> 文件中选择要将软件包更新到的版本（当运行 <code>npm update</code> 时）。</p><p>规则使用的符号如下：</p><ul><li><p><code>^</code>: 该符号更新次版本之后的内容，不会进行大版本的更新，如<code>^0.13.0</code>使用<code>npm update</code>可以更新次版本到<code>0.14.0</code>或进行补丁更新<code>0.13.1</code></p></li><li><p><code>~</code>: 如果写入的是 <code>〜0.13.0</code>，则当运行 <code>npm update</code> 时，会更新到补丁版本：即 <code>0.13.1</code> 可以，但 <code>0.14.0</code> 不可以。</p></li><li><p><code>&gt;</code>: 接受高于指定版本的任何版本。</p></li><li><p><code>&gt;=</code>: 接受等于或高于指定版本的任何版本。</p></li><li><p><code>&lt;=</code>: 接受等于或低于指定版本的任何版本。</p></li><li><p><code>&lt;</code>: 接受低于指定版本的任何版本。</p></li><li><p><code>=</code>: 接受确切的版本。</p></li><li><p><code>-</code>: 接受一定范围的版本。例如：<code>2.1.0 - 2.6.2</code>。</p></li><li><p><code>||</code>: 组合集合。例如 <code>&lt; 2.1 || &gt; 2.6</code>。</p></li></ul><p>可以合并其中的一些符号，例如 <code>1.0.0 || &gt;=1.1.0 &lt;1.2.0</code>，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。</p><p>还有其他的规则：</p><ul><li>无符号: 仅接受指定的特定版本（例如 <code>1.2.1</code>）。</li><li><code>latest</code>: 使用可用的最新版本。</li></ul><h4 id="卸载npm包"><a href="#卸载npm包" class="headerlink" title="卸载npm包"></a>卸载npm包</h4><p>若要卸载之前在本地安装（在 <code>node_modules</code> 文件夹使用 <code>npm install &lt;package-name&gt;</code>）的软件包，则从项目的根文件夹（包含 <code>node_modules</code> 文件夹的文件夹）中运行：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> uninstall <span class="token operator">&lt;</span>package-name<span class="token operator">></span></code></pre><p>如果使用 <code>-S</code> 或 <code>--save</code> 标志，则此操作还会移除 <code>package.json</code> 文件中的引用。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> uninstall -S <span class="token operator">&lt;</span>package-name<span class="token operator">></span></code></pre><p>如果程序包是开发依赖项（列出在 <code>package.json</code> 文件的 devDependencies 中），则必须使用 <code>-D</code> 或 <code>--save-dev</code> 标志从文件中移除：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> uninstall -D <span class="token operator">&lt;</span>package-name<span class="token operator">></span></code></pre><p>如果该软件包是全局安装的，则需要添加 <code>-g</code> 或 <code>--global</code> 标志：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> uninstall -g <span class="token operator">&lt;</span>package-name<span class="token operator">></span></code></pre><p>可以在系统上的任何位置运行此命令，因为当前所在的文件夹无关紧要。</p><h3 id="当出现全局和本地安装相同包情况"><a href="#当出现全局和本地安装相同包情况" class="headerlink" title="当出现全局和本地安装相同包情况"></a>当出现全局和本地安装相同包情况</h3><p>可以是在项目的根目录下使用<code>npx</code>命令来调用当前目录的<code>npm</code>包，而不会使用全局的包。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
            <tag> 前端工程化 </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json相关介绍</title>
      <link href="/2022/07/08/package-json-xiang-guan-jie-shao/"/>
      <url>/2022/07/08/package-json-xiang-guan-jie-shao/</url>
      
        <content type="html"><![CDATA[<h3 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a><code>package.json</code>文件</h3><p><code>package.json</code> 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 <code>npm</code> 和 <code>yarn</code> 存储所有已安装软件包的名称和版本的地方。</p><p>例如<code>Vue</code>项目中的<code>package.json</code>文件:</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"test-project"</span><span class="token punctuation">,</span>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span>  <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"A Vue.js project"</span><span class="token punctuation">,</span>  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"src/main.js"</span><span class="token punctuation">,</span>  <span class="token property">"private"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span><span class="token punctuation">,</span>    <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"npm run dev"</span><span class="token punctuation">,</span>    <span class="token property">"unit"</span><span class="token operator">:</span> <span class="token string">"jest --config test/unit/jest.conf.js --coverage"</span><span class="token punctuation">,</span>    <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"npm run unit"</span><span class="token punctuation">,</span>    <span class="token property">"lint"</span><span class="token operator">:</span> <span class="token string">"eslint --ext .js,.vue src test/unit"</span><span class="token punctuation">,</span>    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"node build/build.js"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"vue"</span><span class="token operator">:</span> <span class="token string">"^2.5.2"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"autoprefixer"</span><span class="token operator">:</span> <span class="token string">"^7.1.2"</span><span class="token punctuation">,</span>    <span class="token property">"babel-core"</span><span class="token operator">:</span> <span class="token string">"^6.22.1"</span><span class="token punctuation">,</span>    <span class="token property">"babel-eslint"</span><span class="token operator">:</span> <span class="token string">"^8.2.1"</span><span class="token punctuation">,</span>    <span class="token property">"babel-helper-vue-jsx-merge-props"</span><span class="token operator">:</span> <span class="token string">"^2.0.3"</span><span class="token punctuation">,</span>    <span class="token property">"babel-jest"</span><span class="token operator">:</span> <span class="token string">"^21.0.2"</span><span class="token punctuation">,</span>    <span class="token property">"babel-loader"</span><span class="token operator">:</span> <span class="token string">"^7.1.1"</span><span class="token punctuation">,</span>    <span class="token property">"babel-plugin-dynamic-import-node"</span><span class="token operator">:</span> <span class="token string">"^1.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"babel-plugin-syntax-jsx"</span><span class="token operator">:</span> <span class="token string">"^6.18.0"</span><span class="token punctuation">,</span>    <span class="token property">"babel-plugin-transform-es2015-modules-commonjs"</span><span class="token operator">:</span> <span class="token string">"^6.26.0"</span><span class="token punctuation">,</span>    <span class="token property">"babel-plugin-transform-runtime"</span><span class="token operator">:</span> <span class="token string">"^6.22.0"</span><span class="token punctuation">,</span>    <span class="token property">"babel-plugin-transform-vue-jsx"</span><span class="token operator">:</span> <span class="token string">"^3.5.0"</span><span class="token punctuation">,</span>    <span class="token property">"babel-preset-env"</span><span class="token operator">:</span> <span class="token string">"^1.3.2"</span><span class="token punctuation">,</span>    <span class="token property">"babel-preset-stage-2"</span><span class="token operator">:</span> <span class="token string">"^6.22.0"</span><span class="token punctuation">,</span>    <span class="token property">"chalk"</span><span class="token operator">:</span> <span class="token string">"^2.0.1"</span><span class="token punctuation">,</span>    <span class="token property">"copy-webpack-plugin"</span><span class="token operator">:</span> <span class="token string">"^4.0.1"</span><span class="token punctuation">,</span>    <span class="token property">"css-loader"</span><span class="token operator">:</span> <span class="token string">"^0.28.0"</span><span class="token punctuation">,</span>    <span class="token property">"eslint"</span><span class="token operator">:</span> <span class="token string">"^4.15.0"</span><span class="token punctuation">,</span>    <span class="token property">"eslint-config-airbnb-base"</span><span class="token operator">:</span> <span class="token string">"^11.3.0"</span><span class="token punctuation">,</span>    <span class="token property">"eslint-friendly-formatter"</span><span class="token operator">:</span> <span class="token string">"^3.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"eslint-import-resolver-webpack"</span><span class="token operator">:</span> <span class="token string">"^0.8.3"</span><span class="token punctuation">,</span>    <span class="token property">"eslint-loader"</span><span class="token operator">:</span> <span class="token string">"^1.7.1"</span><span class="token punctuation">,</span>    <span class="token property">"eslint-plugin-import"</span><span class="token operator">:</span> <span class="token string">"^2.7.0"</span><span class="token punctuation">,</span>    <span class="token property">"eslint-plugin-vue"</span><span class="token operator">:</span> <span class="token string">"^4.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"extract-text-webpack-plugin"</span><span class="token operator">:</span> <span class="token string">"^3.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"file-loader"</span><span class="token operator">:</span> <span class="token string">"^1.1.4"</span><span class="token punctuation">,</span>    <span class="token property">"friendly-errors-webpack-plugin"</span><span class="token operator">:</span> <span class="token string">"^1.6.1"</span><span class="token punctuation">,</span>    <span class="token property">"html-webpack-plugin"</span><span class="token operator">:</span> <span class="token string">"^2.30.1"</span><span class="token punctuation">,</span>    <span class="token property">"jest"</span><span class="token operator">:</span> <span class="token string">"^22.0.4"</span><span class="token punctuation">,</span>    <span class="token property">"jest-serializer-vue"</span><span class="token operator">:</span> <span class="token string">"^0.3.0"</span><span class="token punctuation">,</span>    <span class="token property">"node-notifier"</span><span class="token operator">:</span> <span class="token string">"^5.1.2"</span><span class="token punctuation">,</span>    <span class="token property">"optimize-css-assets-webpack-plugin"</span><span class="token operator">:</span> <span class="token string">"^3.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"ora"</span><span class="token operator">:</span> <span class="token string">"^1.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"portfinder"</span><span class="token operator">:</span> <span class="token string">"^1.0.13"</span><span class="token punctuation">,</span>    <span class="token property">"postcss-import"</span><span class="token operator">:</span> <span class="token string">"^11.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"postcss-loader"</span><span class="token operator">:</span> <span class="token string">"^2.0.8"</span><span class="token punctuation">,</span>    <span class="token property">"postcss-url"</span><span class="token operator">:</span> <span class="token string">"^7.2.1"</span><span class="token punctuation">,</span>    <span class="token property">"rimraf"</span><span class="token operator">:</span> <span class="token string">"^2.6.0"</span><span class="token punctuation">,</span>    <span class="token property">"semver"</span><span class="token operator">:</span> <span class="token string">"^5.3.0"</span><span class="token punctuation">,</span>    <span class="token property">"shelljs"</span><span class="token operator">:</span> <span class="token string">"^0.7.6"</span><span class="token punctuation">,</span>    <span class="token property">"uglifyjs-webpack-plugin"</span><span class="token operator">:</span> <span class="token string">"^1.1.1"</span><span class="token punctuation">,</span>    <span class="token property">"url-loader"</span><span class="token operator">:</span> <span class="token string">"^0.5.8"</span><span class="token punctuation">,</span>    <span class="token property">"vue-jest"</span><span class="token operator">:</span> <span class="token string">"^1.0.2"</span><span class="token punctuation">,</span>    <span class="token property">"vue-loader"</span><span class="token operator">:</span> <span class="token string">"^13.3.0"</span><span class="token punctuation">,</span>    <span class="token property">"vue-style-loader"</span><span class="token operator">:</span> <span class="token string">"^3.0.1"</span><span class="token punctuation">,</span>    <span class="token property">"vue-template-compiler"</span><span class="token operator">:</span> <span class="token string">"^2.5.2"</span><span class="token punctuation">,</span>    <span class="token property">"webpack"</span><span class="token operator">:</span> <span class="token string">"^3.6.0"</span><span class="token punctuation">,</span>    <span class="token property">"webpack-bundle-analyzer"</span><span class="token operator">:</span> <span class="token string">"^2.9.0"</span><span class="token punctuation">,</span>    <span class="token property">"webpack-dev-server"</span><span class="token operator">:</span> <span class="token string">"^2.9.1"</span><span class="token punctuation">,</span>    <span class="token property">"webpack-merge"</span><span class="token operator">:</span> <span class="token string">"^4.1.0"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"engines"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"node"</span><span class="token operator">:</span> <span class="token string">">= 6.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"npm"</span><span class="token operator">:</span> <span class="token string">">= 3.0.0"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"browserslist"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"> 1%"</span><span class="token punctuation">,</span> <span class="token string">"last 2 versions"</span><span class="token punctuation">,</span> <span class="token string">"not ie &lt;= 8"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>这里有很多东西：</p><ul><li><code>version</code> 表明了当前的版本。</li><li><code>name</code> 设置了应用程序&#x2F;软件包的名称。</li><li><code>description</code> 是应用程序&#x2F;软件包的简短描述。</li><li><code>main</code> 设置了应用程序的入口点。</li><li><code>private</code> 如果设置为 <code>true</code>，则可以防止应用程序&#x2F;软件包被意外地发布到 <code>npm</code>。</li><li><code>scripts</code> 定义了一组可以运行的 node 脚本。</li><li><code>dependencies</code> 设置了作为依赖安装的 <code>npm</code> 软件包的列表。</li><li><code>devDependencies</code> 设置了作为开发依赖安装的 <code>npm</code> 软件包的列表。</li><li><code>engines</code> 设置了此软件包&#x2F;应用程序在哪个版本的 Node.js 上运行。</li><li><code>browserslist</code> 用于告知要支持哪些浏览器（及其版本）。</li></ul><p>以上所有的这些属性都可被 <code>npm</code> 或其他工具使用。</p><h4 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h4><p>在<code>package.json</code>中的<code>key</code>都有着不同的含义。(这里参考了[node.js](<a href="http://nodejs.cn/learn/the-package-json-guide/#%E5%B1%9E%E6%80%A7%E5%88%86%E7%B1%BB">package.json 指南 (nodejs.cn)</a>)的入门教程)</p><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><p>设置软件包的名称。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"nodejs_cn"</span></code></pre><p>名称必须少于 214 个字符，且不能包含空格，只能包含小写字母、连字符（<code>-</code>）或下划线（<code>_</code>）。</p><p>这是因为当软件包在 <code>npm</code> 上发布时，它会基于此属性获得自己的 URL。</p><h5 id="author"><a href="#author" class="headerlink" title="author"></a>author</h5><p>列出软件包的作者名称。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"name &lt;email> (url)"</span><span class="token punctuation">&#125;</span></code></pre><p>也可以使用以下格式：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"name"</span><span class="token punctuation">,</span>    <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"email"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"url"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="contributors"><a href="#contributors" class="headerlink" title="contributors"></a>contributors</h5><p>除作者外，该项目可以有一个或多个贡献者。 此属性是列出他们的数组。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"name &lt;email> (url)"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>也可以使用以下格式：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"name"</span><span class="token punctuation">,</span>    <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"email"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"url"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h5 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h5><p>链接到软件包的问题跟踪器，最常用的是 GitHub 的 issues 页面。</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"bugs"</span><span class="token operator">:</span> <span class="token string">"https://github.com/nodejscn/node-api-cn/issues"</span><span class="token punctuation">&#125;</span></code></pre><h5 id="homepage"><a href="#homepage" class="headerlink" title="homepage"></a>homepage</h5><p>设置软件包的主页。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token punctuation">&#123;</span>  <span class="token property">"homepage"</span><span class="token operator">:</span> <span class="token string">"http://nodejs.cn"</span><span class="token punctuation">&#125;</span></code></pre><h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>指定软件包的当前版本。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span></code></pre><p>此属性遵循版本的语义版本控制记法，这意味着版本始终以 3 个数字表示：<code>x.x.x</code>。</p><p>第一个数字是主版本号，第二个数字是次版本号，第三个数字是补丁版本号。</p><p>这些数字中的含义是：仅修复缺陷的版本是补丁版本，引入向后兼容的更改的版本是次版本，具有重大更改的是主版本。</p><h5 id="license"><a href="#license" class="headerlink" title="license"></a>license</h5><p>指定软件包的许可证。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"license"</span><span class="token operator">:</span> <span class="token string">"MIT"</span></code></pre><p>MIT 许可证 （The MIT License）是<strong>许多软件授权条款中，被广泛使用的其中一种</strong></p><h5 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h5><p>此属性包含与软件包功能相关的关键字数组。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"keywords"</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token string">"email"</span><span class="token punctuation">,</span>  <span class="token string">"machine learning"</span><span class="token punctuation">,</span>  <span class="token string">"ai"</span><span class="token punctuation">]</span></code></pre><p>这有助于人们在浏览相似的软件包或浏览 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站时找到你的软件包。</p><h5 id="description"><a href="#description" class="headerlink" title="description"></a>description</h5><p>此属性包含了对软件包的简短描述。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"包的描述"</span></code></pre><p>如果要将软件包发布到 <code>npm</code>，则这个属性特别有用，人们可以知道该软件包是干啥用的。</p><h5 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h5><p>此属性指定了此程序包仓库所在的位置。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"repository"</span><span class="token operator">:</span> <span class="token string">"github:nodejscn/node-api-cn"</span><span class="token punctuation">,</span></code></pre><p>注意 <code>github</code> 前缀。 其他流行的服务商还包括：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"repository"</span><span class="token operator">:</span> <span class="token string">"gitlab:nodejscn/node-api-cn"</span><span class="token punctuation">,</span>JSON<span class="token property">"repository"</span><span class="token operator">:</span> <span class="token string">"bitbucket:nodejscn/node-api-cn"</span><span class="token punctuation">,</span></code></pre><p>可以显式地设置版本控制系统：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"repository"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"git"</span><span class="token punctuation">,</span>  <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://github.com/nodejscn/node-api-cn.git"</span><span class="token punctuation">&#125;</span></code></pre><p>也可以使用其他的版本控制系统：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"repository"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"svn"</span><span class="token punctuation">,</span>  <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"..."</span><span class="token punctuation">&#125;</span></code></pre><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p>设置软件包的入口点。</p><p>当在应用程序中导入此软件包时，应用程序会在该位置搜索模块的导出。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"src/main.js"</span></code></pre><h5 id="private"><a href="#private" class="headerlink" title="private"></a>private</h5><p>如果设置为 <code>true</code>，则可以防止应用程序&#x2F;软件包被意外发布到 <code>npm</code> 上。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"private"</span><span class="token operator">:</span> <span class="token boolean">true</span></code></pre><h5 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h5><p>可以定义一组可以运行的 node 脚本。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span><span class="token punctuation">,</span>  <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"npm run dev"</span><span class="token punctuation">,</span>  <span class="token property">"unit"</span><span class="token operator">:</span> <span class="token string">"jest --config test/unit/jest.conf.js --coverage"</span><span class="token punctuation">,</span>  <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"npm run unit"</span><span class="token punctuation">,</span>  <span class="token property">"lint"</span><span class="token operator">:</span> <span class="token string">"eslint --ext .js,.vue src test/unit"</span><span class="token punctuation">,</span>  <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"node build/build.js"</span><span class="token punctuation">&#125;</span></code></pre><p>这些脚本是命令行应用程序。 可以通过调用 <code>npm run XXXX</code> 或 <code>yarn XXXX</code> 来运行它们，其中 <code>XXXX</code> 是命令的名称。 例如：<code>npm run dev</code>。</p><p>可以为命令使用任何的名称，脚本也可以是任何操作。</p><h5 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h5><p>设置作为依赖安装的 <code>npm</code> 软件包的列表。</p><p>当使用 npm 或 yarn 安装软件包时：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token environment constant">BASH</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>PACKAGENAME<span class="token operator">></span><span class="token function">yarn</span> <span class="token function">add</span> <span class="token operator">&lt;</span>PACKAGENAME<span class="token operator">></span></code></pre><p>该软件包会被自动地插入此列表中。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"vue"</span><span class="token operator">:</span> <span class="token string">"^2.5.2"</span><span class="token punctuation">&#125;</span></code></pre><h5 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h5><p>设置作为开发依赖安装的 <code>npm</code> 软件包的列表。</p><p>它们不同于 <code>dependencies</code>，因为它们只需安装在开发机器上，而无需在生产环境中运行代码。</p><p>当使用 npm 或 yarn 安装软件包时：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token environment constant">BASH</span><span class="token function">npm</span> <span class="token function">install</span> --save-dev <span class="token operator">&lt;</span>PACKAGENAME<span class="token operator">></span><span class="token function">yarn</span> <span class="token function">add</span> --dev <span class="token operator">&lt;</span>PACKAGENAME<span class="token operator">></span></code></pre><p>该软件包会被自动地插入此列表中。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"autoprefixer"</span><span class="token operator">:</span> <span class="token string">"^7.1.2"</span><span class="token punctuation">,</span>  <span class="token property">"babel-core"</span><span class="token operator">:</span> <span class="token string">"^6.22.1"</span><span class="token punctuation">&#125;</span></code></pre><h5 id="engines"><a href="#engines" class="headerlink" title="engines"></a>engines</h5><p>设置此软件包&#x2F;应用程序要运行的 Node.js 或其他命令的版本。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"engines"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"node"</span><span class="token operator">:</span> <span class="token string">">= 6.0.0"</span><span class="token punctuation">,</span>  <span class="token property">"npm"</span><span class="token operator">:</span> <span class="token string">">= 3.0.0"</span><span class="token punctuation">,</span>  <span class="token property">"yarn"</span><span class="token operator">:</span> <span class="token string">"^0.13.0"</span><span class="token punctuation">&#125;</span></code></pre><h5 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h5><p>用于告知要支持哪些浏览器（及其版本）。 Babel、Autoprefixer 和其他工具会用到它，以将所需的 polyfill 和 fallback 添加到目标浏览器。</p><p>示例：</p><pre class="language-json" data-language="json"><code class="language-json">JSON<span class="token property">"browserslist"</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token string">"> 1%"</span><span class="token punctuation">,</span>  <span class="token string">"last 2 versions"</span><span class="token punctuation">,</span>  <span class="token string">"not ie &lt;= 8"</span><span class="token punctuation">]</span></code></pre><p>此配置意味着需要支持使用率超过 1％（来自 <a href="https://caniuse.com/">CanIUse.com</a> 的统计信息）的所有浏览器的最新的 2 个主版本，但不含 IE8 及更低的版本。</p><h4 id="命令特有的属性"><a href="#命令特有的属性" class="headerlink" title="命令特有的属性"></a>命令特有的属性</h4><p><code>package.json</code> 文件还可以承载命令特有的配置，例如 Babel、ESLint 等。</p><p>每个都有特有的属性，例如 <code>eslintConfig</code>、<code>babel</code> 等。 它们是命令特有的，可以在相应的命令&#x2F;项目文档中找到如何使用它们。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js初步学习</title>
      <link href="/2022/07/08/node-js-chu-bu-xue-xi/"/>
      <url>/2022/07/08/node-js-chu-bu-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="命令行运行node-js"><a href="#命令行运行node-js" class="headerlink" title="命令行运行node.js"></a>命令行运行node.js</h3><p><code>app.js</code>为要运行的主程序文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> app.js</code></pre><h4 id="退出node-js程序"><a href="#退出node-js程序" class="headerlink" title="退出node.js程序"></a>退出node.js程序</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span> <span class="token comment">//1234 将不会输出</span></code></pre><p>exit(1)中 exit()括号中默认的退出码为0，表示成功。</p><h3 id="在node-js中导入其他包"><a href="#在node-js中导入其他包" class="headerlink" title="在node.js中导入其他包"></a>在node.js中导入其他包</h3><p><code>node.js</code>中使用的模块化语法为<code>common.js</code>，所以在导入文件时使用<code>require</code>，暴露文件则用<code>exports</code></p><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//export.js文件</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'小王'</span><span class="token punctuation">&#125;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> obj</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//导入文件</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./export.js'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">//控制台输出 &#123; name: '小王' &#125;</span></code></pre><h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//export.js文件</span>exports<span class="token punctuation">.</span>person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./export.js'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>person<span class="token punctuation">)</span> <span class="token comment">//控制台输出 &#123; name: '张三', age: 20 &#125;</span></code></pre><h4 id="两个方式的区别"><a href="#两个方式的区别" class="headerlink" title="两个方式的区别"></a>两个方式的区别</h4><p><code>module.exports</code>公开了它指向的对象。 <code>exports.obj</code>公开了它指向的对象的属性。</p><p><strong>当<code>module.exports</code>和<code>exports.obj</code>共同使用时会默认使用<code>module.exports</code></strong></p><h3 id="package-lock-json文件介绍"><a href="#package-lock-json文件介绍" class="headerlink" title="package-lock.json文件介绍"></a><code>package-lock.json</code>文件介绍</h3><p>该文件主要锁定项目目前所使用的所有<code>npm</code>包的版本号，当其他用户在<code>git</code>等平台使用了你的代码时能保证所依赖包的版本相同导致一些不必要的错误。</p><p><code>package-lock.json</code> 文件需要被提交到 Git 仓库，以便被其他人获取（如果项目是公开的或有合作者，或者将 Git 作为部署源）。</p><p><strong>当运行 <code>npm update</code> 时，<code>package-lock.json</code> 文件中的依赖的版本会被更新。</strong></p><h3 id="Node-js中的函数"><a href="#Node-js中的函数" class="headerlink" title="Node.js中的函数"></a>Node.js中的函数</h3><h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><p>该函数类似于<code>Promise</code>，可以异步执行其中的代码，执行顺序在计时器之前</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token comment">//最终输出 123 12345 1234 123456</span></code></pre><h4 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h4><p>该函数也是将数据进行异步处理，顺序在<code>process.nextTick()</code>之后，与定时器的顺序根据定时器的时间而变。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'外部内容1'</span><span class="token punctuation">)</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'外部内容2'</span><span class="token punctuation">)</span><span class="token comment">//最终输出 外部内容1 外部内容2 nextTick setTimeout setImmediate</span></code></pre><h3 id="Node-js事件触发器"><a href="#Node-js事件触发器" class="headerlink" title="Node.js事件触发器"></a>Node.js事件触发器</h3><p>类似于vue中的子组件与父组件的参数传递</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> EventEmitter <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token keyword">const</span> eventEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//用 on来添加触发器</span>eventEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span>num2</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">数字，</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>num1<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">+</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>num2<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//用emit触发触发器</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><h3 id="搭建HTTP服务器"><a href="#搭建HTTP服务器" class="headerlink" title="搭建HTTP服务器"></a>搭建HTTP服务器</h3><p>搭建一个简单的HTTP web 服务器</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//获取HTTP模块</span><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token comment">// 设置端口号</span><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">3000</span><span class="token comment">// 创建</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">//req接收浏览器传的参数</span>  <span class="token comment">//res 返回渲染的内容</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/html;charset=utf-8'</span><span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'你好世界\n'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 监听端口是否被访问，访问则输出其中内容</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">服务器已经启动</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决matery主题副标题无法显示的问题</title>
      <link href="/2022/05/27/jie-jue-matery-zhu-ti-fu-biao-ti-wu-fa-xian-shi-de-wen-ti/"/>
      <url>/2022/05/27/jie-jue-matery-zhu-ti-fu-biao-ti-wu-fa-xian-shi-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>今天部署博客发现在本地运行的时候也会出现页面迟迟无法出现的问题，结果打开控制台面板一看发现<code>type.js</code>没有使用上。</p><img src="/2022/05/27/jie-jue-matery-zhu-ti-fu-biao-ti-wu-fa-xian-shi-de-wen-ti/bug.png" class="" title="bug"><p>查看源代码发现<code>https://cdn.jsdelivr.net/npm/typed.js@2.0.11</code>挂了，而matery主题默认使用<code>jsdelivr</code>来引入一些js代码。</p><img src="/2022/05/27/jie-jue-matery-zhu-ti-fu-biao-ti-wu-fa-xian-shi-de-wen-ti/bug2.png" class=""><p>现在在控制台中发现了错误，那解决办法就很简单了，在matery主题的源代码中将cdn换成国内加速就可以完美解决副标题不显示的问题了。</p><img src="/2022/05/27/jie-jue-matery-zhu-ti-fu-biao-ti-wu-fa-xian-shi-de-wen-ti/bug3.png" class=""><p>经过一路筛查后发现在主题文件的<code>\layout\_partial\bg-cover-content.ejs</code>中发现了代码。接下来把他替换成<code>https://cdn.bootcss.com/typed.js/2.0.5/typed.js</code>，就可以完美解决问题了</p><img src="/2022/05/27/jie-jue-matery-zhu-ti-fu-biao-ti-wu-fa-xian-shi-de-wen-ti/bug4.png" class=""><img src="/2022/05/27/jie-jue-matery-zhu-ti-fu-biao-ti-wu-fa-xian-shi-de-wen-ti/bug5.png" class=""><p>重新启动后发现报错没了，副标题也一如既往的显示了。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 错误排查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vercel来部署静态页面并解决跨域问题</title>
      <link href="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/"/>
      <url>/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="Vercel的基本介绍"><a href="#Vercel的基本介绍" class="headerlink" title="Vercel的基本介绍"></a>Vercel的基本介绍</h3><p>要是用过<code>hexo</code>来搭建的博客的话，在<code>hexo</code>的官方文档中就有介绍过如何将博客的静态页面搭建到Vercel平台中。但Vercel不仅能搭建静态的页面，也可以将自己github账号中的项目所作的页面进行一个展示，可以省去自己使用服务器搭建的费用。这里只对Vercel基础搭建做一个介绍，想了解更多可以查看官方文档<a href="https://vercel.com/docs">Introduction to Vercel – Vercel Docs</a></p><h4 id="注册Vercel"><a href="#注册Vercel" class="headerlink" title="注册Vercel"></a>注册Vercel</h4><p>进入到<a href="https://vercel.com/">Vercel</a>登录页面，这里直接连接你的github账号。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/page3.png" class=""><p>因为我早已经连接过了，其他的步骤就无法演示了。根据提示一步步下去到最后出现下面这个页面就成功了。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/page4.png" class=""><h3 id="搭建使用vue3-vite所建立的的项目"><a href="#搭建使用vue3-vite所建立的的项目" class="headerlink" title="搭建使用vue3+vite所建立的的项目"></a>搭建使用vue3+vite所建立的的项目</h3><p>在<code>node.js</code>环境下使用<code>npm init vite@latest</code>来创建一个vite项目</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/cmd1.png" class=""><p>这里接下来会有让你选择项目名与框架。如上图可知我目前创建的项目名是<code>vite-project</code>使用的框架为vue，并且使用ts语法。</p><p>在项目的根目录中使用<code>npm install</code>命令导入了vite所需要的包。接下来就是启动项目看看项目页面如何。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/page.png" class=""><p>vite默认开启了端口号3000。看页面展示无误，接下来就该实现如何将该网页部署到Vercel平台中。</p><p>（使用Vercel前需要拥有自己的github账号才行，这里就默认已经都有了github账号）。</p><p>使用<code>npm i -g vercel </code>在全局安装vercel脚手架。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/cmd2.png" class=""><p>因为我先前安装过了，这里文字显示的就是我更新了包。（接下来的操作我会在vscode的集成终端中进行，这样可以更加直观）</p><p>在vscode集成终端中使用<code>vercel</code>对vite项目进行部署</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/cmd3.png" class=""><p>输入后会先让你确认是要部署当前项目，输入y或者按回车即可进行下一步。</p><p>第二步则是需要绑定你自己的github账号，因为我先前已经绑定过了就会出现我github的用户名，没有绑定过根据提示一步步进行就好了，绑定过了按回车进行下一步。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/cmd4.png" class=""><p>然后到<code>Link to existing project</code>位置，问你是否要连接已存在的项目，输入n或回车则是不连接，有的话可以和自己github的项目进行绑定。</p><p>第四步则会设置你在vercel平台中你的项目名是什么，这里我是默认与我当前项目名同名。</p><p>第五步是提示你需要重写你项目这些目前的配置吗？我默认为n，因为当前的vite配置项并没有做任何修改，默认即可。</p><p>然后就进入到了部署阶段。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/cmd5.png" class=""><p>出现<code>production</code>就说明项目已经成功部署到vercel平台中，可以复制<code>Production</code>的连接来看你项目的页面。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/page2.png" class=""><p>vercel中也会出现页面的相关信息。</p><h4 id="解决vercel搭建项目的跨域问题"><a href="#解决vercel搭建项目的跨域问题" class="headerlink" title="解决vercel搭建项目的跨域问题"></a>解决vercel搭建项目的跨域问题</h4><h5 id="首先在项目文件中解决跨域问题"><a href="#首先在项目文件中解决跨域问题" class="headerlink" title="首先在项目文件中解决跨域问题"></a>首先在项目文件中解决跨域问题</h5><p>根据上方搭建vite项目完成后，目前没有发任何请求所以没出现跨域等问题，接下来我就尝试在项目中发一个ajax请求。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require1.png" class=""><p>这里我使用<code>axios</code>发送了一个网络请求，没有配置代理的情况下会违背同源策略产生跨域问题。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require2.png" class=""><p>这里要是在本地处理可以使用vite配置项中的<code>proxy</code>代理来解决跨域问题</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require3.png" class=""><p>在这里我配置了代理，只要有发送<code>api</code>请求并且目标为<code>https://c.m.163.com</code>的时候就会启动代理。</p><p>同时原先请求中的<code>https://c.m.163.com</code>可以删除了。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require4.png" class=""><p>页面中也没有了跨域请求的报错，可以正常的获取数据了。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require5.png" class=""><p>接下来就部署到vercel中看看会不会产生跨域的问题。</p><p>每当项目修改后在终端中输入<code>vercel</code>即可重写上传到vercel平台中。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require6.png" class=""><p>文件上传可以正常进行，但阅览网页却发现请求报错了。说明vercel并不能因为我们在vite中配置了代理而不产生跨域问题。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require7.png" class=""><h5 id="配置vercel代理"><a href="#配置vercel代理" class="headerlink" title="配置vercel代理"></a>配置vercel代理</h5><p>这里配置代理参考了<a href="https://blog.csdn.net/qq_40890601/article/details/120755007">vercel 自动化部署项目和跨域问题_小k铁柱的博客-CSDN博客_vercel部署</a></p><p><strong>需要先在终端<code>npm i http-proxy-middleware</code>下载配置所需要的依赖包（重要的事情说三遍！！！）</strong></p><p><strong>需要先在终端<code>npm i http-proxy-middleware</code>下载配置所需要的依赖包（重要的事情说三遍！！！）</strong></p><p><strong>需要先在终端<code>npm i http-proxy-middleware</code>下载配置所需要的依赖包（重要的事情说三遍！！！）</strong></p><p>然后要在根目录创建<code>vercel.json</code>配置文件，让vercel知道我们要对其做一些修改。</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token comment">//vercel.json文件</span><span class="token punctuation">&#123;</span>  <span class="token property">"rewrites"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">//寻找/api下的文件 然后可以在/api/proxy文件中进行跨域处理</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"source"</span><span class="token operator">:</span> <span class="token string">"/api/(.*)"</span><span class="token punctuation">,</span>      <span class="token property">"destination"</span><span class="token operator">:</span> <span class="token string">"/api/proxy"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></code></pre><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require8.png" class=""><p>在根目录中创建<code>api</code>文件夹，其中添加<code>proxy.js</code>文件（不叫这个也可以，不过使用<code>proxy</code>更加语义化）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 该服务为 vercel serve跨域处理</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  createProxyMiddleware  <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span>  module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token string">''</span>  <span class="token comment">// 代理目标地址</span>  <span class="token comment">// xxxxx 替换为你跨域请求的服务器 如： http://baidu.com</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'/api'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//这里使用/api可能会与vercel serverless 的 api 路径冲突，根据接口进行调整</span>  target <span class="token operator">=</span> <span class="token string">'https://c.m.163.com'</span> <span class="token comment">//这里就是在vite中配置的一样</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 创建代理对象并转发请求</span>  <span class="token function">createProxyMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  target<span class="token punctuation">,</span>  <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token literal-property property">pathRewrite</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 通过路径重写，去除请求路径中的 `/api`</span>  <span class="token string-property property">'^/api/'</span><span class="token operator">:</span> <span class="token string">'/'</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span></code></pre><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require9.png" class=""><p>配置完成后终端使用<code>vercel</code>更新代码看看还有没有跨域问题。</p><img src="/2022/05/27/shi-yong-vercel-lai-bu-shu-jing-tai-ye-mian-bing-jie-jue-kua-yu-wen-ti/require10.png" class=""><p>发送请求成功，完美解决问题！</p>]]></content>
      
      
      <categories>
          
          <category> Velcel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript常见的数组方法与使用</title>
      <link href="/2022/05/26/javascript-shu-zu-de-shi-yong/"/>
      <url>/2022/05/26/javascript-shu-zu-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>数组Array是大家日常开发中使用的比较多的数据类型，这里就不进行过多赘述了，本文主要介绍一些数组常用的方法与操作，以供在写算法或在开发中更好的解决问题。（这里只做了一些我平常用到较多的方法，更多的方法参考<a href="https://developer.mozilla.org/zh-CN/">MDN Web Docs (mozilla.org)</a>官方文档）</p><h4 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h4><h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//使用new Array()创建数组</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">//[1, 2, 3]</span><span class="token comment">//使用字面量来创建数组</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">//[1, 2, 3]</span></code></pre><h5 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// undefined JavaScript中访问一个不存在的元素不会报错，会返回undefined</span></code></pre><h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//使用for循环遍历数组</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//依次输出 1 2 3</span><span class="token punctuation">&#125;</span><span class="token comment">//使用for...of遍历数组</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">//依次输出 1 2 3</span><span class="token punctuation">&#125;</span><span class="token comment">//使用forEach进行遍历数组</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span> <span class="token comment">//item表示内容 index表示索引值 array表示原数组</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array<span class="token punctuation">)</span> <span class="token comment">//依次输出 "1 0 [1, 2, 3]" "2  (3) [1, 2, 3]" "3 2 (3) [1, 2, 3]"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h5 id="添加元素到数组的末尾"><a href="#添加元素到数组的末尾" class="headerlink" title="添加元素到数组的末尾"></a>添加元素到数组的末尾</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">//使用push()方法会改变原数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4]</span></code></pre><h5 id="添加元素到数组的首部"><a href="#添加元素到数组的首部" class="headerlink" title="添加元素到数组的首部"></a>添加元素到数组的首部</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">//使用unshift()方法会改变原数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [4, 1, 2, 3]</span></code></pre><h5 id="删除数组末尾的元素"><a href="#删除数组末尾的元素" class="headerlink" title="删除数组末尾的元素"></a>删除数组末尾的元素</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//使用pop()方法会改变原数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3]</span></code></pre><h5 id="找出某个元素在数组中的索引"><a href="#找出某个元素在数组中的索引" class="headerlink" title="找出某个元素在数组中的索引"></a>找出某个元素在数组中的索引</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'元素1'</span><span class="token punctuation">,</span><span class="token string">'元素2'</span><span class="token punctuation">,</span><span class="token string">'元素3'</span><span class="token punctuation">]</span><span class="token comment">//使用indexOf value存在返回index 不存在则返回-1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'元素2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'元素4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -1</span></code></pre><h5 id="通过索引删除元素"><a href="#通过索引删除元素" class="headerlink" title="通过索引删除元素"></a>通过索引删除元素</h5><p>语法</p><p><code>splice(start,deleteCount,item1,...)</code></p><ul><li><code>start</code>用于指定修改的开始位置（从0计数）</li><li><code>deleteCount</code>表示要移除的数组元素的个数</li><li><code>item1,...</code>表示要添加仅数组的元素，从<code>start</code>位置开始</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'元素1'</span><span class="token punctuation">,</span><span class="token string">'元素2'</span><span class="token punctuation">,</span><span class="token string">'元素3'</span><span class="token punctuation">]</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//使用splice改变原数组内容并返回包含删除元素的新数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'原数组'</span><span class="token punctuation">,</span>arr<span class="token punctuation">,</span><span class="token string">'新数组'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span> <span class="token comment">// 原数组 ['元素2', '元素3'] 新数组 ['元素1']</span></code></pre><h5 id="复制一个数组"><a href="#复制一个数组" class="headerlink" title="复制一个数组"></a>复制一个数组</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'元素1'</span><span class="token punctuation">,</span><span class="token string">'元素2'</span><span class="token punctuation">,</span><span class="token string">'元素3'</span><span class="token punctuation">]</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'原数组'</span><span class="token punctuation">,</span>arr<span class="token punctuation">,</span><span class="token string">'新数组'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span> <span class="token comment">// 原数组 ['元素1', '元素2', '元素3'] 新数组 ['元素1', '元素2', '元素3']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">===</span> newArr<span class="token punctuation">)</span> <span class="token comment">// false 此为深拷贝，修改新数组不会影响原数组</span>newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'元素4'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'原数组'</span><span class="token punctuation">,</span>arr<span class="token punctuation">,</span><span class="token string">'新数组'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span> <span class="token comment">//原数组 ['元素1', '元素2', '元素3'] 新数组 ['元素1', '元素2', '元素3', '元素4']</span></code></pre><h3 id="数组常见方法"><a href="#数组常见方法" class="headerlink" title="数组常见方法"></a>数组常见方法</h3><p>了解数组的一些基本操作后，可以使用JavaScript中数组方法能协助我们更好的开发。</p><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a><code>Array.from()</code></h4><p>对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p><code>Array.from(arrayLike,mapFn,thisArg)</code></p><ul><li><code>arrLike</code>表示想要转换成数组的伪数组对象或可迭代对象</li><li><code>mapFn</code>可选参数，为新数组中每个元素都会执行的回调函数</li><li><code>thisArg</code>可选参数，执行回调函数<code>mapFn</code>时的<code>this</code>对象</li></ul><p><code>from()</code>返回值为一个新的数组实例</p><p><code>from()</code>函数主要将<code>String</code>、<code>Set</code>、<code>Map</code>或类数组对象转变为数组，也可以在转变时做逻辑处理</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token operator">=></span>x<span class="token operator">+</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [2, 4, 6] </span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//它类似于数组，但成员的值都是唯一的</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [1, 2]</span><span class="token keyword">let</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'abc'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'bcd'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//它map类似于对象，也是键值对的集合</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>mapper<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['1', 'abc'],['2', 'bcd']</span></code></pre><h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a><code>Array.isArray()</code></h4><p>用来判断某个变量是否是一个数组对象</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token string">'foobar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// false</span></code></pre><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a><code>Array.prototype.concat()</code></h4><p>用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。（在ES6后有拓展运算符可以直接实现数组的合并）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">let</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token keyword">let</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">,</span><span class="token operator">...</span>arr2<span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4, 5, 6]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4, 5, 6]</span></code></pre><h4 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill()"></a><code>Array.prototype.fill()</code></h4><p>此方法用第一个传入的参数作为固定值，将起始索引值到终止索引值的所有值都用固定值来填充。</p><p><strong>此方法会对原数组进行修改，不会开辟新的内存</strong></p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p><code>arr.fill(value,start,end)</code></p><ul><li><code>value</code>表示用于填充数组的固定值</li><li><code>start</code>可选值，起始索引，默认为0。如果是负数则会被自动计算为<code>length+start</code></li><li><code>end</code>可选值，终止索引，默认值为<code>this.length</code>，即数组的长度。如果是负数则会被自动计算为<code>length+end</code></li><li>返回值为修改后的数组</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> array2 <span class="token operator">=</span> array1<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span> <span class="token comment">// ['d', 'b', 'c']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array1 <span class="token operator">===</span> array2<span class="token punctuation">)</span> <span class="token comment">// true</span><span class="token keyword">let</span> array3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token keyword">let</span> array4 <span class="token operator">=</span> array3<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array4<span class="token punctuation">)</span> <span class="token comment">// [5, 2, 3, 4]</span></code></pre><h4 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a><code>Array.prototype.filter()</code></h4><p>用于过滤出数组中想要的元素<strong>（这种方法不会改变原数组）</strong></p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><p><code>arr.filter(callback,element,index,array,thisArg)</code></p><ul><li><code>callback</code>表示要执行的回调函数，所有逻辑都写在这个参数中</li><li><code>element</code>表示当前在回调函数中正在处理的元素</li><li><code>index</code>可选值，表示当前在回调函数中正在处理的元素的索引值</li><li><code>array</code>可选值，数组本身</li><li><code>thisArg</code>可选值，执行<code>callback</code>回调函数的<code>this</code>的值</li><li>返回值为一个新的过滤后的数组，若没有元素符合回调函数的逻辑判断则返回空数组</li></ul><p>在<code>callback</code>调用可以传入三个参数</p><ol><li>元素的值</li><li>元素的索引</li><li>被遍历的数组本身</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token keyword">let</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span> <span class="token parameter">x</span> <span class="token operator">=></span> x <span class="token operator">></span> <span class="token number">20</span> <span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span> <span class="token comment">//[30, 40, 50]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">//[10, 20, 30, 40, 50]</span></code></pre><h4 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a><code>Array.prototype.map()</code></h4><p>这个方法会创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。(类似于<code>arr.filter</code>，与<code>arr.filter</code>不同的是<code>arr.map</code>方法数组的个数是不会改变的)</p><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><p><code>arr.map(callback,currentValue,index,array,thisArg)</code></p><ul><li><code>callback</code>表示要执行的回调函数，所有逻辑都写在这个参数中</li><li><code>currentValue</code>表示当前在回调函数中正在处理的元素</li><li><code>index</code>可选值，表示当前在回调函数中正在处理的元素的索引值</li><li><code>array</code>可选值，数组本身</li><li><code>thisArg</code>可选值，执行<code>callback</code>回调函数的<code>this</code>的值</li><li>返回值为由原数组每个元素执行回调结果返回所组成的新数组，不符合的则返回<code>undefined</code></li></ul><p>在<code>callback</code>调用可以传入三个参数</p><ol><li>元素的值</li><li>元素的索引</li><li>被遍历的数组本身</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token keyword">let</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> num <span class="token operator">=</span> value<span class="token keyword">return</span> num<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span> <span class="token comment">// [undefined, undefined, undefined, undefined, 5, 6, 7]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4, 5, 6, 7]</span></code></pre><p>在<code>callback</code>调用可以传入三个参数</p><ol><li>元素的值</li><li>元素的索引</li><li>被遍历的数组本身</li></ol><h4 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a><code>Array.prototype.find()</code></h4><p>返回数组中满足提供的测试函数的第一个元素的值，否则返回 <code>undefined</code></p><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><p><code>arr.find(callback,element,index,array,thisArg)</code></p><p>这个方法的内容与<code>arr.filter</code>基本相似，就不过多赘述了</p><p>返回值为数组中第一个满足要求的元素的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token string">'peach'</span><span class="token punctuation">,</span><span class="token string">'application'</span><span class="token punctuation">]</span><span class="token keyword">let</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^ap</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span>  <span class="token comment">//匹配以ap开头的字母</span>    <span class="token keyword">return</span> reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span> <span class="token comment">// apple</span></code></pre><h4 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a><code>Array.prototype.flat()</code></h4><p>用于数组扁平化(此方法不会改变原数组)</p><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><p><code>arr.flat(depth)</code></p><ul><li><code>depth</code>需要扁平的深度，默认为1</li><li>返回扁平后的新数组</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, Array(3)]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4, 5, 6]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">//[1, Array(3)]</span></code></pre><h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a><code>Array.prototype.includes()</code></h4><p>用来判断数组中是否包含指定的值，有返回<code>true</code>，没有返回<code>false</code></p><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><p><code>arr.includes(valueToFind,fromIndex)</code></p><ul><li><code>valueToFind</code>表示需要查找的值</li><li><code>fromIndex</code>可选值，从<code>fromIndex</code>开始查找值，如果为负值，则按升序从 <code>array.length + fromIndex</code>（要是计算还为负的话则默认为全部搜索） 的索引开始搜 ，默认为0</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span></code></pre><h4 id="Array-prototype-indexOf"><a href="#Array-prototype-indexOf" class="headerlink" title="Array.prototype.indexOf()"></a><code>Array.prototype.indexOf()</code></h4><p>用来查找给定元素的第一个索引值，有返回索引值，没有则返回-1</p><h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><p><code>arr.indexOf(searchElement,fromIndex)</code></p><ul><li><code>searchElement</code>表示要查找的元素</li><li><code>fromIndex</code>可选值，表示开始查找的位置，如果该索引值大于或等于数组长度，则直接返回-1。要是该值为-1则表示从数组的最后一位开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，默认值为0</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 5</span></code></pre><h4 id="Array-prototype-join"><a href="#Array-prototype-join" class="headerlink" title="Array.prototype.join()"></a><code>Array.prototype.join()</code></h4><p>将数组拼接称为一个字符串</p><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><p><code>arr.join(separator)</code></p><ul><li><code>separator</code>可选值，指定一个字符串来分割数组的每个元素，默认用”,”</li><li>返回值为数组元素连接的字符串，如果数组没有元素则返回空字符串。如果一个元素为 <code>undefined</code> 或 <code>null</code>，它会被转换为空字符串。</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// a,p,p,l,e</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// apple</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS正则表达式的运用</title>
      <link href="/2022/05/25/zheng-ze-biao-da-shi-de-yun-yong/"/>
      <url>/2022/05/25/zheng-ze-biao-da-shi-de-yun-yong/</url>
      
        <content type="html"><![CDATA[<p>在项目实际开发中，有时候需要对数据进行限制或模糊匹配的时候，正则可以很好的解决这些问题。</p><h5 id="正则表达式的基础使用"><a href="#正则表达式的基础使用" class="headerlink" title="正则表达式的基础使用"></a>正则表达式的基础使用</h5><p>正则表达式的语法：<code>/表达式/</code></p><p>在javascript中，创建正则表达式的方式有两种，一是用字面量的方式创建，即<code>let 变量名 = /表达式/</code>，另一种是通过<code>RegExp()</code>构造函数的方式创建。</p><p>在检测字符串是否符合正则编写规范时，可以使用<code>test()</code>来检测。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token keyword">let</span> reg1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">123</span><span class="token regex-delimiter">/</span></span><span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token function">RegExp</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">123</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span></code></pre><h5 id="模式修饰符"><a href="#模式修饰符" class="headerlink" title="模式修饰符"></a>模式修饰符</h5><p>模式修饰符是在正则基础表达式后面加上后缀，从而实现一些功能。</p><table><thead><tr><th align="center">模式符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">g</td><td align="center">用于在目标字符串中实现全局匹配</td></tr><tr><td align="center">i</td><td align="center">忽略大小写</td></tr><tr><td align="center">m</td><td align="center">实现多行匹配</td></tr><tr><td align="center">u</td><td align="center">以Unicode编码执行正则表达式</td></tr><tr><td align="center">y</td><td align="center">黏性匹配，仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引</td></tr></tbody></table><p>模式符可以根据需求多个混合使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'abcABCD123'</span><span class="token keyword">let</span> reg1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">d</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span> <span class="token comment">//i忽略大小写匹配d</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'\u4e00'</span> <span class="token comment">//一 的unicode编码是\u4e00</span><span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">一</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token keyword">let</span> reg3 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span><span class="token regex-flags">y</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg3<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">//lastIndex默认为0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg3<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span></code></pre><h5 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h5><table><thead><tr><th align="center">边界符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">表示匹配行首的文本</td></tr><tr><td align="center">$</td><td align="center">表示匹配行尾的文本</td></tr></tbody></table><p>在正则中，使用<code>^</code>表示开始，<code>$</code>表示结束。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^abc</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//表示以abc开始，之后的值无论什么都会匹配进去</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'dabc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span><span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">abc$</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//表示以abc结束，之前的值无论什么都会匹配进去</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'dabc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span><span class="token keyword">let</span> reg3 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^abc$</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//只有内容为abc才会匹配成功</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg3<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg3<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'eabcd'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg3<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre><h5 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h5><p>预定义类是某些常见模式的简写方式，具体内容看下表。<strong>其中匹配单个字符没<code>/表达式/g</code>的都是从左往右第一个匹配到接下来都不再匹配</strong></p><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配除”\n”外的任何单个字符</td></tr><tr><td align="center">\d</td><td align="center">匹配所有0~9之间的任意一个数字，相当于[0-9]</td></tr><tr><td align="center">\D</td><td align="center">匹配所有0~9以外的字符，相当于[^0-9](这里的^不在&#x2F;&#x2F;中所以不是边界符的意思)</td></tr><tr><td align="center">\w</td><td align="center">匹配任意的字母、数字和下划线，相当于[a-zA-Z0-9]</td></tr><tr><td align="center">\W</td><td align="center">匹配除所有字母、数字和下划线以外的字符，相当于[^a-zA-Z0-9]</td></tr><tr><td align="center">\s</td><td align="center">匹配空格（包括换行符、制表符、空格符等），相当于[\t\r\n\v\f]</td></tr><tr><td align="center">\S</td><td align="center">匹配非空字符，相当于[^\t\r\n\v\f]</td></tr><tr><td align="center">\f</td><td align="center">匹配一个换页符( form-feed )</td></tr><tr><td align="center">\b</td><td align="center">匹配单词分节符。如”\bg”可以匹配”best grade”，结果为”g”</td></tr><tr><td align="center">\B</td><td align="center">匹配非单词分节符。如”\Bade” 可以匹配”best grade”，结果为”ade”</td></tr><tr><td align="center">\t</td><td align="center">匹配一个水平制表符</td></tr><tr><td align="center">\n</td><td align="center">匹配一个换行符</td></tr><tr><td align="center">\x</td><td align="center">匹配ISO-8859-1中的字符，如”\x61”表示”a”</td></tr><tr><td align="center">\r</td><td align="center">匹配一个回车符</td></tr><tr><td align="center">\v</td><td align="center">匹配一个垂直制表符</td></tr><tr><td align="center">\u</td><td align="center">匹配Unicode中的字符，如”一”为”\u4e00”</td></tr></tbody></table><p>接下来使用<code>match()</code>方法来将匹配成功的结果保存到一个数组中，要是匹配失败则返回false。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//以下结果仅供参考，实际运用还得看使用场景</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果 ['a', 'b', 'c']</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'abc123'</span><span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果 ['1', '2', '3']</span><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'abc123'</span><span class="token keyword">let</span> reg3 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\D</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str3<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果 ['a', 'b', 'c']</span><span class="token keyword">let</span> str4 <span class="token operator">=</span> <span class="token string">'abc123'</span><span class="token keyword">let</span> reg4 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\w</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str4<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg4<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果 ['a', 'b', 'c', '1', '2', '3']</span><span class="token keyword">let</span> str5 <span class="token operator">=</span> <span class="token string">'abc123+-'</span><span class="token keyword">let</span> reg5 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\W</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str5<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg5<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果 ['+', '-']</span><span class="token keyword">let</span> str6 <span class="token operator">=</span> <span class="token string">'abc123\n\t+-'</span><span class="token keyword">let</span> reg6 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\s</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str6<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg6<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果 ['\n', '\t']</span><span class="token keyword">let</span> str7 <span class="token operator">=</span> <span class="token string">'abc123\n\t+-'</span><span class="token keyword">let</span> reg7 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\S</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str7<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg7<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果 ['a', 'b', 'c', '1', '2', '3', '+', '-']</span><span class="token keyword">let</span> str8 <span class="token operator">=</span> <span class="token string">'abc123\n\t\f+-'</span><span class="token keyword">let</span> reg8 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\f</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str8<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg8<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 \f</span><span class="token keyword">let</span> str9 <span class="token operator">=</span> <span class="token string">'ab cd e123\n\t\f+-'</span><span class="token keyword">let</span> reg9 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\bc</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str9<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg9<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 c</span><span class="token keyword">let</span> str10 <span class="token operator">=</span> <span class="token string">'ab cde fgh123\n\t\f+-'</span><span class="token keyword">let</span> reg10 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\Bde</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str10<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg10<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 de</span><span class="token keyword">let</span> str11 <span class="token operator">=</span> <span class="token string">'ab cde fgh123\n\t\f+-'</span><span class="token keyword">let</span> reg11 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\t</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str11<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg11<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 \t</span><span class="token keyword">let</span> str12 <span class="token operator">=</span> <span class="token string">'ab cde fgh123\n\t\f+-'</span><span class="token keyword">let</span> reg12 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\n</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str12<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg12<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 \n</span><span class="token keyword">let</span> str13 <span class="token operator">=</span> <span class="token string">'ab cde fgh123\n\t\f+-'</span><span class="token keyword">let</span> reg13 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\x61</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str13<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg13<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 a</span><span class="token keyword">let</span> str14 <span class="token operator">=</span> <span class="token string">'ab cde fgh123\n\t\f+-\r'</span><span class="token keyword">let</span> reg14 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\r</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str14<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg14<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 \r</span><span class="token keyword">let</span> str15 <span class="token operator">=</span> <span class="token string">'ab cde fgh123\n\t\f+-\r\v'</span><span class="token keyword">let</span> reg15 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\v</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str15<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg15<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 \v</span><span class="token keyword">let</span> str16 <span class="token operator">=</span> <span class="token string">'ab cde fgh123\n\t\f+-\r\v一'</span><span class="token keyword">let</span> reg16 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\u4e00</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str16<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg16<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//匹配结果只有 一</span></code></pre><p><strong>在正则表达式中<code>\</code>还可以作为转义字符使用。</strong></p><h5 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h5><p>正则表达式中的”[]”可以实现一个字符集合，只要求匹配其中的一项，所有可供选择的字符都放在方括号内。</p><table><thead><tr><th align="center">pattern(模式)</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[cat]</td><td align="center">匹配字符集合中的任意一个字符c、 a、 t</td></tr><tr><td align="center">[^cat]</td><td align="center">匹配除c、 a、 t以外的字符</td></tr><tr><td align="center">[A-Z]</td><td align="center">匹配字母A ~ Z范围内的字符</td></tr><tr><td align="center">[^a-z]</td><td align="center">匹配字母A ~ Z范围外的字符</td></tr><tr><td align="center">[a-zA-z0-9]</td><td align="center">匹配大小写字母和0 ~ 9范围内的字符</td></tr><tr><td align="center">[\u4e00-\u9fa5]</td><td align="center">匹配任意一个中文字符（用Unicode才能实现）</td></tr></tbody></table><p><strong>在”[]”中的”^”表示取反的意思</strong></p><p>使用了字符类就可以限定用户要输入的类型了</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span> <span class="token comment">//这里表示只要是输入的是字母就会被获取到</span>str <span class="token operator">=</span> <span class="token string">'abA1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['a', 'b', 'A']</span><span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[^a-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span> <span class="token comment">//这里表示开头不能为字母</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'1abc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'A1bc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span></code></pre><h5 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h5><p>量词符用来设定某个模式出现的次数，通过使用量词符(?、+、*、{ })能够完成某个字符连续出现的匹配</p><table><thead><tr><th align="center">字符</th><th align="center">说明</th><th align="center">示例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">匹配?前面的字符零次或一次</td><td align="center">&#x2F;hi?t&#x2F;</td><td align="center">可匹配ht和hit</td></tr><tr><td align="center">+</td><td align="center">匹配+前面的字符一次或多次</td><td align="center">&#x2F;bre+ad&#x2F;</td><td align="center">可匹配范围从bread到bre⋯ad</td></tr><tr><td align="center">*</td><td align="center">匹配*前面的字符零次或多次</td><td align="center">&#x2F;ro*se&#x2F;</td><td align="center">可匹配范围从rse到ro⋯se</td></tr><tr><td align="center">{n}</td><td align="center">匹配{}前面的字符n次</td><td align="center">&#x2F;hit{2}er&#x2F;</td><td align="center">只能匹配hitter</td></tr><tr><td align="center">{n,}</td><td align="center">匹配{}前面的字符最少n次</td><td align="center">&#x2F;hit{2,}er&#x2F;</td><td align="center">可匹配范围从hitter到hitt⋯er</td></tr><tr><td align="center">{n,m}</td><td align="center">匹配{}前面的字符最少n次，最多m次</td><td align="center">&#x2F;hit{0,2}er&#x2F;</td><td align="center">可匹配hier、hiter和hitter三种情况</td></tr></tbody></table><p><strong>在上方表中”⋯“来表示多次。</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^hi?t</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// ? 表示 1|| 0 可以出现0次或1次</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'hitt'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// hit</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'htt'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// ht</span><span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^bre+ad</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// + 相当于 >= 1 可以出现1次或多次</span><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'bread'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str3<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// bread</span><span class="token keyword">let</span> str4 <span class="token operator">=</span> <span class="token string">'breeeeeeeead'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str4<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// breeeeeeeead</span><span class="token keyword">let</span> reg3 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^ro*se</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// * 相当于 >=0 可以出现0次或多次</span><span class="token keyword">let</span> str5 <span class="token operator">=</span> <span class="token string">'rse'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str5<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// rse</span><span class="token keyword">let</span> str6 <span class="token operator">=</span> <span class="token string">'rooose'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str6<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// rooose</span><span class="token keyword">let</span> reg4 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^hit&#123;2&#125;er</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// &#123;2&#125; 就是重复t字符2次</span><span class="token keyword">let</span> str7 <span class="token operator">=</span> <span class="token string">'hitter'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str7<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// hitter</span><span class="token keyword">let</span> str8 <span class="token operator">=</span> <span class="token string">'hiter'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str8<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// null</span></code></pre><p>通过上方例子应该就可以对量词理解不少。</p><h4 id="括号字符"><a href="#括号字符" class="headerlink" title="括号字符"></a>括号字符</h4><p>在正则表达式中，中括号”[]”表示字符集合，匹配中括号立的任意字符；</p><p>大括号”{}”表示量词符，能够完成某个字符连续出现的匹配；</p><p>小括号”()”表示优先级，被括起来的内容称为”子表达式”</p><p>接下来我们就来介绍小括号”()” </p><h5 id="1-改变限定符的作用范围"><a href="#1-改变限定符的作用范围" class="headerlink" title="1.改变限定符的作用范围"></a>1.改变限定符的作用范围</h5><p>下面我们通过代码对比使用小括号与不适用小括号的区别</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//不使用小括号</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">catch|er</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// |表示或的意思</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'catch'</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'er'</span><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'cater'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span class="token comment">//使用小括号</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">cat(ch|er)</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// |表示或的意思</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'catch'</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'er'</span><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'cater'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span></code></pre><h5 id="2-分组"><a href="#2-分组" class="headerlink" title="2.分组"></a>2.分组</h5><p>使用小括号可以进行分组，当小括号后面有量词符时，就表示对整个组进行操作。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//不分组</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">cater&#123;2&#125;</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//可匹配结果为caterr</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'caterr'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span class="token comment">//使用小括号进行分组</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">cat(er)&#123;2&#125;</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//可匹配的结果为caterer</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'caterr'</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'caterer'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span></code></pre><h5 id="3-捕获与非捕获"><a href="#3-捕获与非捕获" class="headerlink" title="3.捕获与非捕获"></a>3.捕获与非捕获</h5><p>正则表达式中，当子表达式匹配到相应的内容时，系统会自动捕获这个匹配的行为，然后将子表达式匹配到的内容存储到系统的缓存区中，这个过程就称为”捕获“</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//非捕获</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?:J)(?:S)</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//使用(?:x)可以实现非捕获匹配</span><span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token string">'JS'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">'$2 $1'</span><span class="token punctuation">)</span> <span class="token comment">//$2表示reg中第二个表达式被捕获的内容 $1则表示reg中第一个表达式被捕获的内容</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// $2 $1</span><span class="token comment">//捕获</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(J)(-S)</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//使用(?:x)可以实现非捕获匹配</span><span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token string">'JS'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">'$2 $1'</span><span class="token punctuation">)</span> <span class="token comment">//$2表示reg中第二个表达式被捕获的内容 $1则表示reg中第一个表达式被捕获的内容</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// JS</span></code></pre><h5 id="4-贪婪与惰性匹配"><a href="#4-贪婪与惰性匹配" class="headerlink" title="4.贪婪与惰性匹配"></a>4.贪婪与惰性匹配</h5><p>正则表达式在实现指定数量范围的任意字符匹配时，支持贪婪匹配和惰性匹配两种方式。</p><p>所谓贪婪匹配就是尽可能多的字符，惰性表示匹配尽可能少的字符。</p><p><strong>正则匹配默认是贪婪匹配，若想要实现惰性匹配，需在上一个限定符的后面加上”?“符号</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'webWEBWebwEb'</span><span class="token keyword">let</span> reg1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">w.*b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span>  <span class="token comment">//贪婪匹配</span><span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">w.*?b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span> <span class="token comment">//惰性匹配</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//['webWEBWebwEb', index: 0, input: 'webWEBWebwEb', groups: undefined]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//['web', index: 0, input: 'webWEBWebwEb', groups: undefined]</span></code></pre><p>上面代码贪婪匹配会先获取最先出现的w到最后出现的b，即可获得匹配结果为”webWEBWebwEb“。</p><p>惰性匹配时，会获取最先出现的w和最先出现的b，即可获得到匹配结果为”web“。</p><h5 id="5-反向引用"><a href="#5-反向引用" class="headerlink" title="5.反向引用"></a>5.反向引用</h5><p>-在编写正则表达式时，若要在正则表达式中获取存放在缓存区内的子表达式的捕获内容，则可以使用<code>\n</code>（n是大于0的正整数）的方式引用，这个过程就是”反向引用“。其中，”\1“表示第1个子表达式的捕获内容，”\2“表示第2个子表达式的捕获内容，以此类推。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'13335 12345 56668'</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d)\1\1</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span> <span class="token comment">//添加了()后即可通过反向引用来获取捕获的内容</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//['333', '666']</span></code></pre><h5 id="6-零宽断言"><a href="#6-零宽断言" class="headerlink" title="6.零宽断言"></a>6.零宽断言</h5><p>零宽断言指的是一种零宽度的子表达式匹配，用于查找子表达式匹配的内容之前或子厚是否含有特定的字符集。它分为正向预查和反向预查（反向预查在ES2018后已经支持）。</p><p>正向预查：</p><table><thead><tr><th>字符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>x(?&#x3D;y)</td><td>仅当x后面紧跟着y时，才匹配x</td><td>Countr(?&#x3D;y|ies)用于匹配Country或Countries中的Countr</td></tr><tr><td>x(?!y)</td><td>仅当x后面不紧跟着y时，才匹配x</td><td>Countr(?!y|lies)用于匹配Countr后不是y或lies的任意字符串中的Countr</td></tr></tbody></table><p>反向预查：</p><table><thead><tr><th>字符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>(?&lt;&#x3D;y)x</td><td>匹配紧跟y后面的x</td><td>(?&lt;&#x3D;Countr)ylies用于匹配Countrylies后的ylies</td></tr><tr><td>(?&lt;!y)x</td><td>不匹配紧跟y后面的x</td><td>(?&lt;!Countr)ylies用于匹配Countrylies后不为ylies的任意字符串</td></tr></tbody></table><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//正向预查</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'Country'</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'Countries'</span><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'Countr'</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">Countr(?=y|ies)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//['Countr']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//['Countr']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str3<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//null 后方有y或ies才能匹配到</span><span class="token comment">//反向预查</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'Country'</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'Countries'</span><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'Countr'</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=Countr)y|ies</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//['y']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//['ies']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str3<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//null</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript的语法与使用</title>
      <link href="/2022/05/16/typescript-de-yu-fa-yu-shi-yong/"/>
      <url>/2022/05/16/typescript-de-yu-fa-yu-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="TypeScript的安装"><a href="#TypeScript的安装" class="headerlink" title="TypeScript的安装"></a>TypeScript的安装</h3><p>因为TypeScript只是相当于JavaScript的拓展，JavaScript所有语法并对其进行一些语法的增加，安装可以通过Node.js的npm包控制管理进行安装。使用<code>npm i -g typescript</code>进行全局安装。</p><p>浏览器目前默认识别不了ts文件，需要通过<code>tsc xxx.ts</code>来进行将ts转变为js，使用<code>tsc xxx.ts -w</code>会自动监听ts文件的变更。</p><h4 id="TypeScript配置"><a href="#TypeScript配置" class="headerlink" title="TypeScript配置"></a>TypeScript配置</h4><p>在根目录创建<code>tsconfig.json</code>对ts进行配置，在命令行中使用<code>tsc</code>或<code>tsc -w</code>来运行配置文件</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token comment">//tsconfig.json文件</span><span class="token punctuation">&#123;</span>    <span class="token comment">//"compilerOptions"编译器的选项</span>    <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//"target"用来指定ts编译为js的版本</span>        <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"ES6"</span><span class="token punctuation">,</span>        <span class="token comment">//"module"指定要使用的模块化的规范</span>        <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"ES6"</span><span class="token punctuation">,</span>                <span class="token comment">//"strict"所有严格检查开关</span>        <span class="token property">"strict"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment">//"lib"指定项目中要使用的库(一般不配置)</span>        <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token comment">//"outDir"指定编译后的文件所在目录</span>        <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"./dist"</span><span class="token punctuation">,</span>        <span class="token comment">//"outFile"用于将代码合并为一个文件</span>        <span class="token property">"outFile"</span><span class="token operator">:</span> <span class="token string">"/dist/app.js"</span><span class="token punctuation">,</span>        <span class="token comment">//"allowJs"是否对js文件进行编译</span>        <span class="token property">"allowJs"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//"checkJs"是否对js文件进行ts语法检查</span>        <span class="token property">"checkJs"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//"removeComments"是否移除注释</span>        <span class="token property">"removeComments"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//"noEmit"不生成编译后的文件</span>        <span class="token property">"noEmit"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//"noEmitOnError"有错误时不生成编译后的文件</span>        <span class="token property">"noEmitOnError"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//"alwaysStrict"编译后的文件是否开启严格模式</span>        <span class="token property">"alwaysStrict"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment">//"noImplicitAny"不允许隐式的any类型</span>        <span class="token property">"noImplicitAny"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//"noImplicitThis"不允许不明确的this</span>        <span class="token property">"noImplicitThis"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//"strictNullChecks"严格检查空值</span>        <span class="token property">"strictNullChecks"</span><span class="token operator">:</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">/*    "include"指定哪些ts文件需要被编译     **表示 递归匹配任意子目录     *表示 匹配0或多个字符（不包括目录分隔符）    */</span>    <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"./src/**/*"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">//"exclude"指定不需要被编译的文件目录</span>    <span class="token property">"exclude"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"./src/hello/**/*"</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>ts引入了类型的概念，可以对变量或形参进行类型的判断，如果类型不符则会直接报错</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">任意数字</td></tr><tr><td align="center">string</td><td align="center">任意字符串</td></tr><tr><td align="center">boolean</td><td align="center">布尔值true或false</td></tr><tr><td align="center">字面量</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td align="center">any</td><td align="center">任意类型</td></tr><tr><td align="center">unknown</td><td align="center">类型安全的any</td></tr><tr><td align="center">void</td><td align="center">没有值</td></tr><tr><td align="center">never</td><td align="center">不能是任何值</td></tr><tr><td align="center">object</td><td align="center">表示除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型</td></tr><tr><td align="center">array</td><td align="center">任意的js数组</td></tr><tr><td align="center">tuple</td><td align="center">元组（长度固定的数组）</td></tr><tr><td align="center">enum</td><td align="center">枚举</td></tr></tbody></table><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//声明一个变量a，同时指定它的类型是Number 以后a赋值只能为number类型 赋值其他类型会报错</span><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token builtin">number</span>a <span class="token operator">=</span> <span class="token number">100</span><span class="token comment">//声明变量类型为number并直接赋值 以后b的类型只能为number，修改会报错</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token comment">//声明函数接收到的形参和返回值必须为数字</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span class="token comment">//声明函数 使用 void 表示函数没有返回值（但可以返回undefined和null） 有返回值会报错</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//声明函数 使用 never 表示函数不会有返回结果</span><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'出错'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//使用 | 来连接多个类型， 这里c之后只能赋值成字符串或布尔类型</span><span class="token keyword">let</span> c<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token comment">//使用 any 相当于对变量关闭类型限制</span><span class="token keyword">let</span> d<span class="token operator">:</span><span class="token builtin">any</span><span class="token comment">//使用 unknown 表示未知类型的值 不能将 unknown类型的值赋值给其他已知类型的值，但any类型不受限制</span><span class="token keyword">let</span> e<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token comment">//可以使用 类型断言 将unknown的值赋值给其他已知类型 有以下两种语法</span>a <span class="token operator">=</span> e <span class="token keyword">as</span> <span class="token builtin">number</span>a <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">></span>e<span class="token comment">//指定变量f为一个对象，赋值内容必须包含name age?表示age属性为可选属性</span><span class="token comment">//[propName: string] : any 表示 属性名为任意字符串， 属性值为任意类型 就可以在后方追加属性了</span><span class="token keyword">let</span> f<span class="token operator">:</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">?</span><span class="token operator">:</span><span class="token builtin">number</span> <span class="token punctuation">,</span> <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">&#125;</span>f <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'名字'</span><span class="token punctuation">&#125;</span><span class="token comment">//设置函数结构的类型声明</span><span class="token keyword">let</span> <span class="token function-variable function">g</span> <span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span> <span class="token comment">//表示形参只能有两个而且为number 返回值也为number</span><span class="token function-variable function">g</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">&#125;</span><span class="token comment">//设置数组内部的数据类型</span><span class="token comment">//语法1</span><span class="token keyword">let</span> h <span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//表明数组内部只能是字符串</span>h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token comment">//语法2</span><span class="token keyword">let</span> j <span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token comment">//表明数组内部只能是字符串</span>j <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token comment">//定义元组</span><span class="token keyword">let</span> k<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token comment">////表明数组内部第一个是字符串，第二个是数字</span>k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'s'</span> <span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">]</span><span class="token comment">//定义枚举类型</span><span class="token keyword">enum</span> Gender<span class="token punctuation">&#123;</span>    male<span class="token punctuation">,</span>    female<span class="token punctuation">&#125;</span><span class="token keyword">let</span> l <span class="token operator">:</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>gender<span class="token operator">:</span>Gender<span class="token punctuation">&#125;</span> <span class="token comment">//使用枚举类型来判断性别</span>l <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'名字'</span><span class="token punctuation">,</span>    gender<span class="token operator">:</span> Gender<span class="token punctuation">.</span>male<span class="token punctuation">&#125;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>gender <span class="token operator">===</span> Gender<span class="token punctuation">.</span>male<span class="token punctuation">)</span><span class="token comment">//使用type关键字来为类型取别名</span><span class="token keyword">type</span> <span class="token class-name">myType</span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token keyword">let</span> i <span class="token operator">:</span> myType <span class="token comment">//此时类型和number是相同的</span></code></pre><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>当确定一个值的类型时但ts却出现报错的情况下，可以使用类型断言来断定当前变量的值一定为所断言的值。</p><p>断言的两种语法</p><ul><li><code>&lt;类型&gt;变量</code>，在要断言数据前面使用尖括号</li><li>使用<code>as</code>语法 (当在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的)</li></ul><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//使用尖括号</span><span class="token keyword">let</span> str<span class="token operator">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">'some thing'</span><span class="token keyword">let</span> strLength<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span>str<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token comment">//使用 as</span><span class="token keyword">let</span> str<span class="token operator">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">'some thing'</span><span class="token keyword">let</span> strLength<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length</code></pre><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>面向对象主要包括属性和方法。面向对象简而言之就是，万物皆是对象。</p><h5 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h5><p>通过类来创建不同的对象</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//定义一个类 对象中主要包含了两个部分： 属性  方法</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token comment">//定义实例属性</span>    name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'名字'</span>    <span class="token comment">//在属性前舒勇static关键字可以定义属性为静态属性</span>    <span class="token keyword">static</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span>    <span class="token comment">//定义只读属性只能看不能改</span>    <span class="token keyword">readonly</span> render<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'男'</span>    <span class="token comment">//定义方法</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">// console.log(per.age) 此时会报错</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token comment">//需要通过类进行访问</span><span class="token comment">//per.render = '女' 此时会报错</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per<span class="token punctuation">.</span>render<span class="token punctuation">)</span><span class="token comment">//调用方法 要是static修饰则为类方法</span>per<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>每次对类进行实例化时候会先调用一次构造函数，可以选择接收的参数，每次根据实例化对象的不同<code>this</code>指向也不同</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//定义一个类</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span>    age<span class="token operator">:</span> <span class="token builtin">number</span>    <span class="token comment">//创建构造函数  构造函数会在对象创建时调用 不初始化值的话，调用构造函数必须传值</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment">//在构造函数中this表示当前的实例对象</span>    <span class="token punctuation">&#125;</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'李四'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span></code></pre><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>让子类继承父类的方法和属性，提高代码的复用性。</p><p>如果子类当中添加了父类相同的方法，会覆盖掉父类的方法。这称为方法的重写</p><p>在继承中有<code>super</code>关键字，表示当前类的父类。</p><p>在子类中写构造函数必须通过<code>super</code>对父类构造函数进行调用</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//定义动物类</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span>    age<span class="token operator">:</span> <span class="token builtin">number</span>    <span class="token comment">//创建构造函数</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment">//在构造函数中this表示当前的实例对象</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'动物在叫'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//让Dog类继承动物类</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token comment">//继承父类构造函数</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'汪汪汪'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//让Cat类继承动物类</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'喵喵喵'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//让Tiger类继承动物类</span><span class="token keyword">class</span> <span class="token class-name">Tiger</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//继承父类方法</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">'旺财'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//输出 Dog &#123;name: '旺财', age: 3&#125;</span>dog<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 汪汪汪</span><span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'咪咪'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//输出 Cat &#123;name: '咪咪', age: 2&#125;</span>cat<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 喵喵喵</span><span class="token keyword">const</span> tiger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token string">'虎'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">//输出 Tiger &#123;name: '虎', age: 5&#125;</span>tiger<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 动物在叫</span></code></pre><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>使用<code>abstract</code>来定义抽象类，此类只能被继承不能直接调用，就是专门用来继承的类</p><p>抽象类可以使用<code>abstract</code>添加抽象方法，抽象方法没有方法体，抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写，不然会报错</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//定义抽象动物类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span>    <span class="token comment">//创建构造函数</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment">//在构造函数中this表示当前的实例对象</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//定义抽象方法</span>    <span class="token keyword">abstract</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token comment">//让Dog类继承动物类</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>    age<span class="token operator">:</span> <span class="token builtin">number</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">//继承父类构造函数</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token punctuation">&#125;</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'汪汪汪'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>使用<code>interface</code>关键字用来定义一个类结构，定义一个类中应该包含哪些属性和方法，接口也可以当成类型声明去使用。</p><p>接口只定义对象的结构，不能有实际的值</p><p>用<code>implements</code>来实现一个接口</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//定义接口</span><span class="token keyword">interface</span> <span class="token class-name">objInterface</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span><span class="token builtin">string</span>    age<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">&#125;</span><span class="token comment">//接口当作类型声明使用</span><span class="token keyword">const</span> obj<span class="token operator">:</span> objInterface <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span><span class="token string">'张三'</span><span class="token punctuation">,</span>    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">&#125;</span><span class="token comment">//定义接口</span><span class="token keyword">interface</span> <span class="token class-name">myInter</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">void</span><span class="token punctuation">&#125;</span><span class="token comment">//实现接口</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">myInter</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">&#125;</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'HelloWorld'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>封装是为了防止外部对属性进行修改，使用<code>private</code>进行修饰的属性则为私有属性（属性默认值为<code>public</code>），不允许在函数外部进行访问</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//定义动物类</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span>    <span class="token comment">//创建构造函数</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">&#125;</span>    <span class="token comment">//通过函数来获得内部的name</span>    <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name    <span class="token punctuation">&#125;</span>    <span class="token comment">//ts提供的get方法来获取name</span>    <span class="token keyword">get</span> <span class="token function">_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行get _name()'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name    <span class="token punctuation">&#125;</span>    <span class="token comment">//通过函数来设置内部的name</span>    <span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">&#125;</span>    <span class="token comment">//ts提供的set方法来设置name</span>    <span class="token keyword">set</span> <span class="token function">_name</span><span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行set _name()'</span><span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">&#125;</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'动物在叫'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">'dog'</span><span class="token punctuation">)</span>animal<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>animal<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出 cat</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>animal<span class="token punctuation">.</span>_name<span class="token punctuation">)</span><span class="token comment">//调用get方法</span>animal<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token string">'tiger'</span> <span class="token comment">//调用set方法</span></code></pre><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>在定义函数或者类时，如果遇到类型不明确时可以使用泛型</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//定义一个泛型为K，只有函数执行时才知道K的类型</span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">fn</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">&#125;</span><span class="token comment">//调用时候会自动判断传入的类型</span><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> result<span class="token punctuation">)</span><span class="token comment">//手动指定泛型为string</span><span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">fn</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> result2<span class="token punctuation">)</span><span class="token comment">//定义接口</span><span class="token keyword">interface</span> <span class="token class-name">Inter</span><span class="token punctuation">&#123;</span>    length<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span><span class="token comment">//让T继承接口Inter的类型</span><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">fn2</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Inter<span class="token operator">></span></span></span><span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>length<span class="token punctuation">&#125;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//输出3</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3新特性</title>
      <link href="/2022/05/09/vue3-xin-te-xing/"/>
      <url>/2022/05/09/vue3-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="常用Composition-API"><a href="#常用Composition-API" class="headerlink" title="常用Composition API"></a>常用<code>Composition API</code></h4><h5 id="setup"><a href="#setup" class="headerlink" title="setup"></a><code>setup</code></h5><p>组件中所需要用到的数据方法等，均要配置在<code>setup</code>中，<code>setup</code>值为一个函数</p><p>有两种返回值：</p><ol><li>若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用</li><li>若返回时一个渲染函数：则可以自定义渲染内容</li></ol><p><code>setup</code>函数会接收到两个参数，第一个为<code>props</code>为组件数据传递，第二个为<code>context</code>上下文</p><p><code>setup</code>不能使用<code>async</code>，但如果父组件中使用<code>Suspense</code>来修饰子组件并用动态引入则可以返回<code>Promise</code></p><p><strong><code>setup</code>会在<code>beforeCreate</code>之前执行一次，<code>this</code>是<code>undefined</code></strong></p><h5 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a><code>ref</code>函数</h5><p>原先<code>vue2</code>中的<code>ref</code>写在标签内部作为一个标识一样的存在</p><p>使用需要<code>import &#123;ref&#125; from &#39;vue&#39;</code>引入</p><p>数据经过<code>ref</code>加工变成<code>Reflmpl&#123;&#125;</code>进行包装实现响应式</p><p><code>ref</code>函数内部如果为对象等引用数据类型则会额外使用<code>reactive</code>函数</p><h5 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a><code>reactive</code>函数</h5><p>用于定义一个对象类型的响应式数据，通过<code>proxy</code>来实现响应式，并通过<code>reflect</code>操作源对象内部的数据调用数据可以不加<code>.value</code></p><h5 id="computed函数"><a href="#computed函数" class="headerlink" title="computed函数"></a><code>computed</code>函数</h5><p>定义在<code>setup</code>内部</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;h1&gt;&#123;&#123;person.fullName&#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;computed,reactive&#125; from &#39;vue&#39; &#x2F;&#x2F;引入vue中的函数export default &#123;  name: &#39;Demo&#39;,  setup()&#123;      const person &#x3D; reactive(&#123;          firstName:&#39;firstName&#39;,          lastName: &#39;lastName&#39;      &#125;)  &#x2F;&#x2F;只读，不考虑写      person.fullName &#x3D; computed(()&#x3D;&gt;&#123;          return person.firstName + &#39;-&#39; + person.lastName      &#125;)  &#x2F;&#x2F;考虑读写      person.fullName &#x3D; computed(&#123;          get()&#123;              return person.firstName + &#39;-&#39; + person.lastName          &#125;,          set(value)&#123;            const nameArr &#x3D; value.split(&#39;-&#39;)            person.firstName &#x3D; nameArr[0]            person.lastName &#x3D; nameArr[1]          &#125;      &#125;)      return &#123;          person      &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h5 id="watch函数"><a href="#watch函数" class="headerlink" title="watch函数"></a><code>watch</code>函数</h5><p>定义在<code>setup</code>内部，用法和vue2中差不多，只不过是在<code>setup</code>中定义</p><p><code>watch</code>接收三个参数：</p><ul><li>第一个为监视的数据</li><li>第二个为<code>(newValue,oldValue)=&gt;&#123;&#125;</code>函数</li><li>第三个为可以配置的参数，如<code>&#123;immediate:true&#125;</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>h1<span class="token operator">></span>当前求和为<span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>sum<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"sum++"</span><span class="token operator">></span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>  <span class="token operator">&lt;</span>h1<span class="token operator">></span>当前求和为<span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>num<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"num--"</span><span class="token operator">></span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>  <span class="token operator">&lt;</span>hr<span class="token operator">></span>  <span class="token operator">&lt;</span>h2<span class="token operator">></span>firstName<span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>person<span class="token punctuation">.</span>firstName<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>h2<span class="token operator">></span>lastName<span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>person<span class="token punctuation">.</span>lastName<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>h2<span class="token operator">></span>b<span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>person<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"person.firstName+='@'"</span><span class="token operator">></span>修改firstName<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"person.lastName +='!'"</span><span class="token operator">></span>修改lastName<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"person.a.b++"</span><span class="token operator">></span>修改b<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>watch<span class="token punctuation">,</span>ref<span class="token punctuation">,</span>reactive<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span> <span class="token comment">//引入vue中的函数</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Demo'</span><span class="token punctuation">,</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">/**       * 监视ref定义的属性       */</span>      <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token comment">//监视单个ref所定义的响应式数据</span>      <span class="token function">watch</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span>oldValue</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sum+1'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">,</span>oldValue<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token comment">//监视多个ref定义的响应式数据</span>      <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>sum<span class="token punctuation">,</span>num<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span>oldValue</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sum或num改变了'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">,</span>oldValue<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token literal-property property">immediate</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token comment">/**       * 监视reactive定义的属性       */</span>      <span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>          <span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">'firstName'</span><span class="token punctuation">,</span>          <span class="token literal-property property">lastName</span><span class="token operator">:</span> <span class="token string">'lastName'</span><span class="token punctuation">,</span>          <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>              <span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">200</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token comment">//监视reactive中的所有属性,此处监视的newValue,oldValue值一致，无法正确的进行监视,并且会强制开启了深度监视</span>      <span class="token function">watch</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span>oldValue</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'person变化了'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">,</span>oldValue<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token comment">//监视reactive的某一个属性 此时可以正常监视</span>      <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>person<span class="token punctuation">.</span>lastName<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span>oldValue</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'person变化了'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">,</span>oldValue<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token comment">//监视reactive的某一个属性 套用了数组和函数返回的方式，成功监视正常监视reactive中的属性</span>      <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>person<span class="token punctuation">.</span>lastName<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>person<span class="token punctuation">.</span>firstName<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span>oldValue</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'person变化了'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">,</span>oldValue<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token comment">//监视reactive的嵌套属性  修改内部属性必须开深度监视才能监视到</span>      <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>person<span class="token punctuation">.</span>a<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>person<span class="token punctuation">.</span>firstName<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span>oldValue</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'person变化了'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">,</span>oldValue<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token literal-property property">deep</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//此时深度监视生效</span>      <span class="token keyword">return</span><span class="token punctuation">&#123;</span>          sum<span class="token punctuation">,</span>          num<span class="token punctuation">,</span>          person      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><h5 id="watchEffect函数"><a href="#watchEffect函数" class="headerlink" title="watchEffect函数"></a><code>watchEffect</code>函数</h5><p>只有当<code>watchEffect</code>当中有调用了属性才会进行监视，并且在打开浏览器时就会进行一次监视。但不提供深度监视等配置</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;h1&gt;当前求和为:&#123;&#123;sum&#125;&#125;&lt;&#x2F;h1&gt;  &lt;button @click&#x3D;&quot;sum++&quot;&gt;+1&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref,watchEffect&#125; from &#39;vue&#39; &#x2F;&#x2F;引入vue中的函数export default &#123;  name: &#39;Demo&#39;,  setup()&#123;      &#x2F;**       * 监视ref定义的属性       *&#x2F;      let sum &#x3D; ref(0)      watchEffect(()&#x3D;&gt;&#123;          let a &#x3D; sum.value          console.log(&#39;watchEffect执行&#39;,a)      &#125;)      return&#123;          sum      &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h5 id="toRef函数和toRefs函数"><a href="#toRef函数和toRefs函数" class="headerlink" title="toRef函数和toRefs函数"></a><code>toRef</code>函数和<code>toRefs</code>函数</h5><p>可以用于引用<code>reactive</code>所创建的对象。</p><p><code>toRef</code>用于获取某一个数据，<code>toRefs</code>用于获取所有数据</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;h2&gt;firstName:&#123;&#123;firstName&#125;&#125;&lt;&#x2F;h2&gt;  &lt;h2&gt;lastName:&#123;&#123;lastName&#125;&#125;&lt;&#x2F;h2&gt;  &lt;!--toRefs来取深层次数据--&gt;  &lt;h2&gt;b:&#123;&#123;a.b&#125;&#125;&lt;&#x2F;h2&gt;  &lt;!--toRef来取深层次数据，因为在返回已经取到所以可以直接使用--&gt;  &lt;h2&gt;b:&#123;&#123;b&#125;&#125;&lt;&#x2F;h2&gt;  &lt;button @click&#x3D;&quot;firstName+&#x3D;&#39;@&#39;&quot;&gt;修改firstName&lt;&#x2F;button&gt;  &lt;button @click&#x3D;&quot;lastName +&#x3D;&#39;!&#39;&quot;&gt;修改lastName&lt;&#x2F;button&gt;  &lt;!--toRefs来取深层次数据--&gt;  &lt;button @click&#x3D;&quot;a.b++&quot;&gt;修改b&lt;&#x2F;button&gt;  &lt;!--toRef来取深层次数据，因为在返回已经取到所以可以直接使用--&gt;  &lt;button @click&#x3D;&quot;b++&quot;&gt;修改b&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;reactive, toRef&#125; from &#39;vue&#39; &#x2F;&#x2F;引入vue中的函数export default &#123;  name: &#39;Demo&#39;,  setup()&#123;      &#x2F;&#x2F;用reactive创建响应式数据      const person &#x3D; reactive(&#123;          firstName:&#39;firstName&#39;,          lastName: &#39;lastName&#39;,          a:&#123;              b:200          &#125;      &#125;)            return&#123;          &#x2F;&#x2F;使用toRef来实现响应式，在模板部分可以不用Person前缀          firstName: toRef(person,&#39;firstName&#39;),          lastName: toRef(person,&#39;lastName&#39;),          b: toRef(person.a,&#39;b&#39;)          &#x2F;&#x2F;使用toRefs来实现响应式，在模板部分可以不用Person前缀          ...toRefs(person)      &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h5 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a><code>shallowReactive</code> 与 <code>shallowRef</code></h5><p><code>shallowReactive</code> 与 <code>shallowRef</code>只考虑最外层的数据，对象嵌套的内部数据进行更改无法进行响应式。</p><h5 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a><code>customRef</code></h5><p>用于创建一个自定义的<code>ref</code>，并对其依赖跟踪和更新触发进行显式控制</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!-- 使用customRef实现延迟1秒更新数据 --&gt;&lt;template&gt;  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;keyWord&quot;&gt;  &lt;h2&gt;&#123;&#123;keyWord&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;customRef&#125; from &#39;vue&#39; &#x2F;&#x2F;引入vue中的函数export default &#123;  name: &#39;Demo2&#39;,  setup()&#123;      function myRef(value,delay)&#123;&#x2F;&#x2F;创建myRef函数          let timer &#x2F;&#x2F;定义定时器，用于到时候清除定时器          return  customRef((track,trigger)&#x3D;&gt;&#123;&#x2F;&#x2F;调用customRef              return &#123;                  get()&#123;                      track() &#x2F;&#x2F;让vue对数据改变进行追踪                      return value                  &#125;,                  set(newValue)&#123;                      clearTimeout(timer)                      value &#x3D; newValue                      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;                          trigger() &#x2F;&#x2F;让vue重新解析模板                      &#125;, delay);                  &#125;              &#125;          &#125;)      &#125;      let keyWord &#x3D; myRef(&#39;hello&#39;,1000)            return&#123;          keyWord      &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h5 id="provide与inject"><a href="#provide与inject" class="headerlink" title="provide与inject"></a><code>provide</code>与<code>inject</code></h5><p>用于实现祖与后代组件间的通信</p><p>使用祖组件的<code>provide</code>来提供数据，后代组件的<code>inject</code>来使用数据</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--祖组件--&gt;&lt;template&gt;&lt;div&gt;  &lt;h2&gt;祖组件data1:&#123;&#123;data1&#125;&#125;，data2:&#123;&#123;data2&#125;&#125;&lt;&#x2F;h2&gt;  &lt;FirstChild&gt;&lt;&#x2F;FirstChild&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; reactive, toRefs &#125; from &#39;@vue&#x2F;reactivity&#39;import FirstChild from &#39;.&#x2F;components&#x2F;FirstChild.vue&#39;import &#123; provide &#125; from &#39;@vue&#x2F;runtime-core&#39;export default &#123;  name: &#39;App&#39;,  components:&#123;FirstChild&#125;,  setup()&#123;    let data &#x3D; reactive(&#123;      data1: &#39;数据1&#39;,      data2: &#39;数据2&#39;    &#125;)    provide(&#39;data&#39;,data)&#x2F;&#x2F;给后代传递数据    return&#123;      ...toRefs(data)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--子组件--&gt;&lt;template&gt;  &lt;div&gt;      &lt;h3&gt;子组件收到的数据&#123;&#123;data1&#125;&#125;，&#123;&#123;data2&#125;&#125;&lt;&#x2F;h3&gt;      &lt;SecondChild&gt;&lt;&#x2F;SecondChild&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import SecondChild from &#39;..&#x2F;components&#x2F;SecondChild.vue&#39;import &#123; inject, toRefs &#125; from &#39;@vue&#x2F;runtime-core&#39;export default &#123;    name:&#39;FirstChild&#39;,    components:&#123;SecondChild&#125;,    setup()&#123;      let data &#x3D; inject(&#39;data&#39;)      return&#123;...toRefs(data)&#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--孙组件--&gt;&lt;template&gt;  &lt;div&gt;      &lt;h3&gt;孙组件收到的数据&#123;&#123;data1&#125;&#125;，&#123;&#123;data2&#125;&#125;&lt;&#x2F;h3&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; inject, toRefs &#125; from &#39;@vue&#x2F;runtime-core&#39;export default &#123;    name:&#39;SecondChild&#39;,    setup()&#123;      let data &#x3D; inject(&#39;data&#39;)      return&#123;...toRefs(data)&#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre><h5 id="Teleport组件"><a href="#Teleport组件" class="headerlink" title="Teleport组件"></a><code>Teleport</code>组件</h5><p>用于将组件内部的模块传送到其他部分去</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--引用上方的孙组件，并在其中实现模态框的效果--&gt;&lt;template&gt;  &lt;div class&#x3D;&quot;child2&quot;&gt;      &lt;h3&gt;孙组件收到的数据&#123;&#123;data1&#125;&#125;，&#123;&#123;data2&#125;&#125;&lt;&#x2F;h3&gt;      &lt;button @click&#x3D;&quot;isShow &#x3D; true&quot;&gt;显示&lt;&#x2F;button&gt;       &lt;teleport to&#x3D;&quot;html&quot;&gt; &lt;!--to代表跳转到的页面根标签 --&gt;          &lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;            &lt;div class&#x3D;&quot;dialog&quot;&gt;              &lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;隐藏&lt;&#x2F;button&gt;            &lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;      &lt;&#x2F;teleport&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; inject, toRefs , ref &#125; from &#39;@vue&#x2F;runtime-core&#39;export default &#123;    name:&#39;SecondChild&#39;,    setup()&#123;      const isShow &#x3D; ref(false)      let data &#x3D; inject(&#39;data&#39;)      return&#123;...toRefs(data),isShow&#125;    &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt;  .child2&#123;    background-color: greenyellow;    padding: 10px;  &#125;  .mask&#123;    position: absolute;    left: 0;    top: 0;    bottom: 0;    right: 0;    background-color: rgba(0, 0, 0, 0.5);      &#125;  .dialog&#123;    line-height: 300px;    text-align: center;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%,-50%);    width: 300px;    height: 300px;    background-color: aqua;  &#125;&lt;&#x2F;style&gt;</code></pre><h4 id="Vue2响应式与Vue3响应式对比"><a href="#Vue2响应式与Vue3响应式对比" class="headerlink" title="Vue2响应式与Vue3响应式对比"></a>Vue2响应式与Vue3响应式对比</h4><h5 id="Vue2的响应式"><a href="#Vue2的响应式" class="headerlink" title="Vue2的响应式"></a>Vue2的响应式</h5><ul><li>实现原理<ul><li>对象类型：通过<code>Object.defineProperty()</code>对属性进行读取，进行数据劫持</li><li>数组类型：通过重写数组的方法来实现拦截</li></ul></li><li>存在问题：<ul><li>对对象中元素进行新增页面不会更新</li><li>直接通过数组下标对数组修改页面不会更新</li></ul></li></ul><p>Vue2对存在问题提供的解决方案：</p><ul><li><p>对象：使用<code>set</code>方法来新增数据，使用<code>delete</code>方法来删除数据</p></li><li><p>数据：使用<code>set</code>方法来新增数据或者使用数组中的<code>splice</code>进行更改</p></li></ul><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;export default&#123;        data()&#123;            person:&#123;                name:&#39;张三&#39;,                age:18,                hobby:[&#39;学习&#39;,&#39;吃饭&#39;]            &#125;        &#125;,        methods: &#123;            addSex()&#123;                this.$set(this.person,&#39;sex&#39;,&#39;男&#39;)&#x2F;&#x2F;新增sex，并页面会进行更新            &#125;,            deleteName()&#123;                this.$delete(this.person,&#39;name&#39;)&#x2F;&#x2F;删除name，并页面会进行更新            &#125;,            updateHobby()&#123;                this.$set(this.person.hobby,0,&#39;游戏&#39;)&#x2F;&#x2F;修改数组第一个元素                this.person.hobby.splice(0,1,&#39;游戏&#39;)&#x2F;&#x2F;修改数组第一个元素            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h5 id="Vue3的响应式"><a href="#Vue3的响应式" class="headerlink" title="Vue3的响应式"></a>Vue3的响应式</h5><p>Vue3中解决了以上Vue2中存在的问题</p><p>通过<code>proxy</code>来实现数据代理，实现一些基本操作的拦截。再在返回的时候通过<code>Reflect</code>进行数据返回。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token punctuation">&#123;</span>    <span class="token comment">//拦截读取属性值</span>    <span class="token function">get</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">//拦截设置属性值或添加新属性</span>    <span class="token function">set</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span>prop<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>prop<span class="token punctuation">,</span>value<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">//拦截删除属性</span>    <span class="token function">deleteProperty</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>prop</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>prop<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>在vue3中可以在组件的<code>&lt;script&gt;&lt;/script&gt;</code>标签中加入<code>setup</code>，使整个变为<code>setup</code>函数。</p><p>效果与<code>&lt;script&gt;setup()&#123;&#125;&lt;/script&gt;</code>相同，可以使整个代码更加的简洁。</p><p>在单文件组件中使用的变量、函数声明，以及import引入的内容都能在模板中直接引用</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;    const msg &#x3D; ref(&#39;Hello&#39;)&#x2F;&#x2F;使用ref包裹会自动return,可以直接在模块中调用    function log() &#123;  console.log(msg)&#125;&lt;&#x2F;script&gt;&lt;template&gt;&lt;div @click&#x3D;&quot;log&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre><h5 id="组件数据传递"><a href="#组件数据传递" class="headerlink" title="组件数据传递"></a>组件数据传递</h5><p>在原先的vue2.x中使用<code>props</code>来接收从父组件从来的数据，而在vue3.x中推荐组件式API，因此使用<code>defineProps</code>来代替了<code>props</code>。（这里使用TypeScript展示）</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;    const props &#x3D; defineProps(&#123;  foo: String        bar?: number&#x2F;&#x2F;? 表示可选参数&#125;)&lt;&#x2F;script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack的应用</title>
      <link href="/2022/05/04/li-jie-webpack/"/>
      <url>/2022/05/04/li-jie-webpack/</url>
      
        <content type="html"><![CDATA[<img src="/2022/05/04/li-jie-webpack/introduce.png" class=""><p><code>Webpack</code>就是将浏览器识别不了的文件转换为浏览器能识别的文件</p><h4 id="webpack4的安装（以下全以webpack4版本进行，之后再用webpack5进行比较）"><a href="#webpack4的安装（以下全以webpack4版本进行，之后再用webpack5进行比较）" class="headerlink" title="webpack4的安装（以下全以webpack4版本进行，之后再用webpack5进行比较）"></a><code>webpack4</code>的安装（以下全以webpack4版本进行，之后再用webpack5进行比较）</h4><p><strong>在安装<code>webpack</code>前要确保电脑已经安装了<code>node.js</code></strong></p><p><code>npm i webpack@4 -D -g</code>是全局安装开发者模式的<code>webpack</code>其中<code>-g</code>代表全局安装<code>-D</code>代表开发者模式</p><p><code>npm i webpack-cli@3 -D -g</code>是全局安装开发者模式的<code>webpack-cli</code>其中<code>-g</code>代表全局安装<code>-D</code>代表开发者模式</p><p>其他的安装与上同理</p><p>如果想局部安装就去掉<code>-g</code>即可。</p><p>全局运行<code>webpack</code>可以直接在命令行输入<code>webpack</code>就可进行打包</p><p>没有全局安装，但局部安装了。局部运行<code>webpack</code>需要在命令行输入<code>npx webpack</code>才能进行打包</p><h4 id="webpack的配置文件"><a href="#webpack的配置文件" class="headerlink" title="webpack的配置文件"></a><code>webpack</code>的配置文件</h4><p><code>webpack.config.js</code>为<code>webpack</code>的配置文件，当运行webpack会加载里面的配置</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js 模块化默认采用采用commonjs</span><span class="token comment">//resolve用来拼接绝对路径的方法</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> resolve <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//webpack配置</span>    <span class="token comment">//入口，webpack的打包起点文件</span>    <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    <span class="token comment">//输出</span>    <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//输出文件名</span>        <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'built.js'</span><span class="token punctuation">,</span>        <span class="token comment">//输出路径</span>        <span class="token comment">//__dirname是node.js的变量，代表当前文件的目录绝对路径</span>        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'bulid'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">//loader的配置</span>    <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token comment">//详细loader配置  不同文件必须配置不同loader处理</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//text匹配哪些文件</span>            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token comment">//这里解析css资源</span>            <span class="token comment">//use使用哪些loader进行处理</span>            <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token comment">//use数组中loader执行顺序：从右到左，从下到上依次执行</span>                <span class="token comment">//创建style标签，将js中的样式资源插入进行，添加到head中生效</span>                <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                <span class="token comment">//将css文件变成common.js模块加载js中，里面内容是样式字符串</span>                <span class="token string">'css-loader'</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">//plugins的配置</span>    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">//模式</span>    <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'development'</span><span class="token comment">//开发模式</span>    <span class="token comment">//mode: 'production' 是生产模式，会对代码进行压缩</span><span class="token punctuation">&#125;</span></code></pre><p>配置解析<code>less</code>文件的<code>loader</code></p><p><strong>在loader文件中如果使用的webpack是4的版本则下载的loader版本也需要旧版本</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span><span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                <span class="token comment">//将less文件编译成css文件，然后依次编译为样式</span>                <span class="token comment">//打包前需要使用npm下载 less-loader和less</span>                <span class="token string">'less-loader'</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h5 id="打包html资源"><a href="#打包html资源" class="headerlink" title="打包html资源"></a>打包html资源</h5><p>只需在<code>plugins</code>中配置 <code>html-webpack-plugin</code>即可，打包自动引入打包输出的所有资源</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token comment">//html-webpack-plugin需要通过npm下载</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        <span class="token comment">//复制'./src/index.html'文件，并自动引入打包所有资源</span>    <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'./src/index.html'</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h5 id="打包图片资源"><a href="#打包图片资源" class="headerlink" title="打包图片资源"></a>打包图片资源</h5><p>在<code>loader</code>中进行配置</p><p>要是报错大部分只需根据下载依赖包即可</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span><span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//这种处理方式只能处理index.js中引入的图片资源</span>            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpg|png|gif)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>            <span class="token literal-property property">options</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>                <span class="token comment">//表示图片大小小于8kb，就会被base64处理</span>                <span class="token literal-property property">limit</span><span class="token operator">:</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span>                <span class="token comment">//要是解析出现路径变为:[object Module]，需要关闭es6模块化，使用commonjs解析</span>                <span class="token literal-property property">esModule</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token comment">//表示输出到根目录的imgs的文件夹中</span>                <span class="token literal-property property">outputPath</span><span class="token operator">:</span> <span class="token string">'imgs'</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.html$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token comment">//这是处理Html文件的img图片</span>            <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'html-loader'</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h5 id="打包其他资源"><a href="#打包其他资源" class="headerlink" title="打包其他资源"></a>打包其他资源</h5><p>需要在<code>loader</code>中进行配置</p><p>和打包图片资源方法几乎一致</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span><span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//表示排除css/js/html资源</span>            <span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(css|js|html)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">,</span>            <span class="token comment">//表示输出到根目录的media的文件夹中</span>                <span class="token literal-property property">outputPath</span><span class="token operator">:</span> <span class="token string">'media'</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h5 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h5><p>可以实现自动化（自动编译已修改的文件，自动打开浏览器，自动刷新浏览器）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span><span class="token comment">//devServer启动指令 npx webpack-dev-server</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> resolve <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">contentBase</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment">//启动gzip压缩</span>        <span class="token literal-property property">compress</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment">//开启的端口号</span>        <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">3000</span><span class="token punctuation">,</span>        <span class="token comment">//自动打开默认浏览器</span>        <span class="token literal-property property">open</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="提取css为单独资源"><a href="#提取css为单独资源" class="headerlink" title="提取css为单独资源"></a>提取<code>css</code>为单独资源</h5><p>用上方的方法打包<code>css</code>资源则会存在<code>js</code>文件中需要使用<code>npm i mini-css-extract-plugin -D</code>来进行安装，然后在<code>webpack.config.js</code>进行配置即可</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">module</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token comment">//用这个loader来代替style-loader</span>                MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>                <span class="token string">'css-loader'</span><span class="token punctuation">,</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token comment">//对输出的css文件进行重命名</span>            <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'./src/index.html'</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h5 id="js语法检查eslint"><a href="#js语法检查eslint" class="headerlink" title="js语法检查eslint"></a><code>js</code>语法检查<code>eslint</code></h5><p>语法检查用于检查语法错误和保证团队风格一致</p><p>这里使用<code>airbnb</code>来作为检查规则，需要安装<code>npm i eslint-loader eslint-config-airbnb-base eslint-plugin-import -D</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">rules</span><span class="token operator">:</span><span class="token punctuation">[</span>            <span class="token punctuation">&#123;</span>                <span class="token comment">//eslint只检查自己写的源代码</span>                <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                <span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token comment">//排除检查库</span>                <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'eslint-loader'</span><span class="token punctuation">,</span>                <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">fix</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">//可以自动修复eslint错误</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="eslint兼容性处理"><a href="#eslint兼容性处理" class="headerlink" title="eslint兼容性处理"></a><code>eslint</code>兼容性处理</h5><p>为保证在任何浏览器都能运行需要对<code>js</code>做兼容性处理</p><p>需要安装<code>npm i babel-loader @babel/core @babel/preset-env core-js -D </code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">rules</span><span class="token operator">:</span><span class="token punctuation">[</span>            <span class="token punctuation">&#123;</span>                <span class="token comment">//eslint只检查自己写的源代码</span>                <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                <span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token comment">//排除检查库</span>                <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>                <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//预设：指示babel做怎么样的兼容性处理</span>                    <span class="token literal-property property">presets</span><span class="token operator">:</span><span class="token punctuation">[</span>                        <span class="token punctuation">[</span>                            <span class="token string">'@babel/preset-env'</span><span class="token punctuation">,</span>                            <span class="token punctuation">&#123;</span><span class="token comment">//按需加载</span>                                <span class="token literal-property property">useBuiltIns</span><span class="token operator">:</span> <span class="token string">'usage'</span><span class="token punctuation">,</span>                                <span class="token literal-property property">corejs</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>                                    <span class="token literal-property property">version</span><span class="token operator">:</span><span class="token number">3</span><span class="token comment">//指定core-js把呢不能</span>                                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                                <span class="token literal-property property">targets</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token comment">//指定兼容性做到哪个版本浏览器</span>                                    <span class="token literal-property property">chrome</span><span class="token operator">:</span> '<span class="token number">60</span><span class="token punctuation">,</span>                                    <span class="token literal-property property">firefox</span><span class="token operator">:</span> '<span class="token number">60</span><span class="token punctuation">,</span>                               <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">]</span>                    <span class="token punctuation">]</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="webpack优化配置"><a href="#webpack优化配置" class="headerlink" title="webpack优化配置"></a><code>webpack</code>优化配置</h4><h5 id="HMR热模块替换"><a href="#HMR热模块替换" class="headerlink" title="HMR热模块替换"></a><code>HMR</code>热模块替换</h5><p>在开发环境中，一个模块发生变化，只会重新打包发生变化的模块</p><p><code>html</code>文件和<code>js</code>文件默认不能使用 <code>HMR</code>，因为开发都是单页面应用，所以没必要开启<code>html</code>的热更新</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">entry</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'./src/js/index.js'</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//开启HMR功能</span>        <span class="token literal-property property">hot</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//index.js文件  这种方法不能处理入口文件</span><span class="token keyword">if</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>hot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//一旦 module.hot 为 true， 说明开启了HMR功能</span>    module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./print.js'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建</span>        <span class="token comment">//会执行后面的回调函数</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">//修改./print.js信息，只有该文件重新构建了</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a><code>source-map</code></h5><p>提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射可以追踪源代码错误）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">devtool</span><span class="token operator">:</span> <span class="token string">'source-map'</span><span class="token comment">//这样就开启了source-map</span><span class="token punctuation">&#125;</span></code></pre><p><code>source-map</code>的模式：</p><ul><li><code>source-map</code>：单独生成一个以<code>.map</code>为后缀的文件,发生错误能表明是哪个文件和源代码的错误位置</li><li><code>inline-source-map</code>：直接在入口<code>js</code>文件中生成,发生错误能表明是哪个文件和源代码的错误位置</li><li><code>hidden-source-map</code>：单独生成一个以<code>.map</code>为后缀的文件，发生错误显示原因，但没有源代码错误位置</li><li><code>eval-source-map</code>：直接在入口<code>js</code>文件中生成,发生错误能表明是哪个文件和源代码的错误位置（为hash值）</li><li><code>nosources-source-map</code>：单独生成一个以<code>.map</code>为后缀的文件，能找到错误信息，但是没有源代码信息</li><li><code>cheap-source-map</code>：单独生成一个以<code>.map</code>为后缀的文件，能找到错误信息，但源代码错误信息只能精确到行</li><li><code>cheap-module-source-map</code>：单独生成一个以<code>.map</code>为后缀的文件，能找到错误信息和源代码的错误位置</li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>在生产环境中，对一个文件进行修改为了不需要所有文件都重新构建一次，就需要用到缓存</p><p>主要使用：</p><ul><li><code>cacheDirectory: true</code></li><li>文件名中添加<code>contenthash</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">output</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token comment">//这里增加contenthash值是因为保证重新构建文件发生改变，可以重新写入缓存</span>        <span class="token comment">//contenthash：根据文件的内容生成hash值。</span>        <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'js/built[contenthash:10].js'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>     <span class="token comment">//loader的配置</span>    <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>            <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//开启babel缓存，第二次构建时，会读取之前的缓存</span>                <span class="token literal-property property">cacheDirectory</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h5><p>通过<code>code split</code>可以更好的进行代码维护</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//可以将node_modules中代码单独打包成一个chunk</span>    <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">splitChunks</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">chunks</span><span class="token operator">:</span> <span class="token string">'all'</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在<code>index.js</code>入口文件中实现代码分割</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//index.js文件</span><span class="token comment">//import动态导入语法  能将某个文件单独打包 /* webpackChunkName: 'test' */代表打包后文件名为test</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: 'test' */</span><span class="token string">'./test'</span><span class="token punctuation">)</span><span class="token comment">//使用promise方法</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件加载成功'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件加载失败'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h5 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//index.js文件</span><span class="token comment">//放在按钮中当点击的时候才会加载test.js文件</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//正常加载可以认为是并行加载（同一时间加载多个文件）</span>    <span class="token comment">//webpackPrefetch: true表示启动预加载，预加载是指等其他资源加载完毕，浏览器空闲了再加载资源</span>    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: 'test', webpackPrefetch: true */</span><span class="token string">'./test'</span><span class="token punctuation">)</span><span class="token comment">//使用promise方法</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件加载成功'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件加载失败'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="dll"><a href="#dll" class="headerlink" title="dll"></a><code>dll</code></h5><p><code>dll</code>可以对第三窟进行单独打包，它的配置需要单独新建一个配置文件</p><p>运行打包需要使用<code>webpack --config webpack.dll.js</code>告诉<code>webpack</code>配置文件名变更了</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.dll.js文件</span><span class="token comment">//获取路径</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> resolve <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token comment">//引入插件</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//['jquery']表示要打包的库是jquery</span>        <span class="token literal-property property">jquery</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'jquery'</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//最终打包生成的[name]是jquery</span>        <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dll'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token literal-property property">library</span><span class="token operator">:</span> <span class="token string">'[name]_[hash]'</span><span class="token comment">//打包的库向外暴露的内容叫什么名字</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token comment">//打包生成一个manifest.json，提供和jquery映射关系</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'[name]_[hash]'</span><span class="token punctuation">,</span> <span class="token comment">//映射库的暴露内容名称</span>        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dll/manifest.json'</span><span class="token punctuation">)</span> <span class="token comment">//输出文件路径</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>同时需要在配置文件中告诉<code>webpack</code>哪些库不参与打包，并安装插件来让<code>html</code>自动引入资源<code>npm i add-asset-html-webpack-plugin -D</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js文件</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> resolve <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token keyword">const</span> AddAssetHtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'add-asset-html-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token comment">//告诉webpack哪些库不参与打包</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllReferencePlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">manifest</span><span class="token operator">:</span> <span class="token function">re3solve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dll/manifest.json'</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment">//让html自动引入资源</span>        <span class="token keyword">new</span> <span class="token class-name">AddAssetHtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">filepath</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dll/jquery.js'</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h5 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js文件</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//使用服务器代理来解决开发环境的跨域问题</span>        <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//一旦devServer服务器接收到 /api/xxx 的请求，就会把请求转发到另一个服务器</span>            <span class="token string-property property">'/api'</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000'</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="解决缓存失效问题"><a href="#解决缓存失效问题" class="headerlink" title="解决缓存失效问题"></a>解决缓存失效问题</h5><p>在原先的方法中，因为新增加<code>hash</code>值，其他文件修改会导致<code>hash</code>值变更也会修改主要入口文件<code>index.js</code>中的数据，导致重新打包后入口文件也会进行打包，这时就需要<code>runtimeChunk</code>配置来解决这个问题</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//webpack.config.js文件</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//将当前模块的记录其他模块的hash单独打包成一个文件 runtime</span>        <span class="token literal-property property">runtimeChunk</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token function-variable function">name</span><span class="token operator">:</span> <span class="token parameter">entrypoint</span> <span class="token operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">runtime-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>entrypoint<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue源码了解</title>
      <link href="/2022/04/30/vue-yuan-ma-liao-jie/"/>
      <url>/2022/04/30/vue-yuan-ma-liao-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="mustache模板引擎"><a href="#mustache模板引擎" class="headerlink" title="mustache模板引擎"></a>mustache模板引擎</h3><p>模板引擎是将数据变为视图的最优雅解决方案，用<code>&#123;&#123;&#125;&#125;</code>来进行表示</p><p><code>mustache</code>官方git: <a href="https://github.com/janl/mustache.js">janl&#x2F;mustache.js: Minimal templating with  in JavaScript (github.com)</a></p><h4 id="使用正则表达式来实现简单的模板替换"><a href="#使用正则表达式来实现简单的模板替换" class="headerlink" title="使用正则表达式来实现简单的模板替换"></a>使用正则表达式来实现简单的模板替换</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> templateStr <span class="token operator">=</span> <span class="token string">'&lt;h1>标题&#123;&#123;title&#125;&#125;,内容&#123;&#123;content&#125;&#125;&lt;/h1>'</span> <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'模板'</span><span class="token punctuation">,</span>    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">'了解'</span><span class="token punctuation">&#125;</span><span class="token comment">// 正则中用\进行转义 \w搜索字母 /g表示全局搜索</span><span class="token comment">//replace方法接收到参数</span><span class="token keyword">var</span> replaceStr <span class="token operator">=</span> templateStr<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\&#123;\&#123;(\w+)\&#125;\&#125;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">findStr<span class="token punctuation">,</span>$1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>findStr<span class="token punctuation">,</span>$1<span class="token punctuation">)</span> <span class="token comment">//输出 &#123;&#123;title&#125;&#125; title  &#123;&#123;content&#125;&#125; content</span>    <span class="token keyword">return</span> data<span class="token punctuation">[</span>$1<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>replaceStr<span class="token punctuation">)</span></code></pre><p>只能实现最简单的模板替换，无法实现循环等功能</p><h4 id="实现mustache模块的主要功能"><a href="#实现mustache模块的主要功能" class="headerlink" title="实现mustache模块的主要功能"></a>实现mustache模块的主要功能</h4><p><code>mustache</code>的主要功能就是以<code>tokens</code>为中介，将模板字符串进行编译成<code>dom</code>字符串，并在<code>tokens</code>解析时候结合数据。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//要传入的数据 在mustache中 '#'表示循环 '/'表示循环结束  '.'表示简单数组的遍历</span><span class="token keyword">var</span> templateStr <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>        &lt;ol>            &#123;&#123;#students&#125;&#125;             &lt;li>                学生&#123;&#123;name&#125;&#125;的爱好是                &lt;ol>                    &#123;&#123;#hobbies&#125;&#125;                    &lt;li>&#123;&#123;.&#125;&#125;&lt;/li>                    &#123;&#123;/hobbies&#125;&#125;                &lt;/ol>            &lt;/li>            &#123;&#123;/students&#125;&#125;        &lt;/ol>    &lt;/div></span><span class="token template-punctuation string">`</span></span>        <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">students</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"小明"</span><span class="token punctuation">,</span><span class="token string-property property">"hobbies"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"游泳"</span><span class="token punctuation">,</span><span class="token string">"健身"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"小红"</span><span class="token punctuation">,</span><span class="token string-property property">"hobbies"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"足球"</span><span class="token punctuation">,</span><span class="token string">"健身"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"小强"</span><span class="token punctuation">,</span><span class="token string-property property">"hobbies"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"吃饭"</span><span class="token punctuation">,</span><span class="token string">"健身"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    Mustache<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>templateStr<span class="token punctuation">,</span>data<span class="token punctuation">)</span> <span class="token comment">//将数据交给mustache进行解析，下方有介绍</span></code></pre><h5 id="实现模板字符串转变为tokens"><a href="#实现模板字符串转变为tokens" class="headerlink" title="实现模板字符串转变为tokens"></a>实现模板字符串转变为<code>tokens</code></h5><p>首先得要先了解什么是<code>tokens</code></p><img src="/2022/04/30/vue-yuan-ma-liao-jie/tokenslog.png" class=""><p>在源码部分添加<code>console.log()</code>在控制台中输出<code>tokens</code></p><img src="/2022/04/30/vue-yuan-ma-liao-jie/tokensexport.png" class=""><p>使用<code>Mustache.render(templateStr,data)</code>方法将数据输出</p><p>上方数据表明<code>tokens</code>为一个数组</p><p><code>tokens[0]</code>共分为<code>text</code>，<code>name</code>，<code>#</code>三种</p><p><code>text</code>用来表明遇到<code>&#123;&#123;`之前的字符串:因为在遇到一个`&#123;&#123;`之前模板字符串的内容为`<div><ol>`所以进行了记录`name`用来表明在`&#123;&#123;&#125;&#125;</code>之间的字符串:在<code>vue</code>中就相当于要在模板字符串中要显示的数据</p><p><code>#</code>如果在<code>&#123;&#123;&#125;&#125;</code>表示里面数据要进行循环遍历</p><p><code>tokens[1]</code>则为获取到的内容</p><p><code>tokens[2]-tokens[3]</code>为内容第几位开始和第几位结束(这里为了简洁就不过多追究)</p><p><code>tokens[4]</code>是当<code>tokens[0]</code>为<code>#</code>时新建的内容数组，结构也是<code>tokens</code>一样的</p><p>对<code>tokens</code>有一定了解后就可以进行将模板字符串变为<code>tokens</code>数组</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//扫描器类 通过对传进来的模板字符串进行扫描，如果碰到'&#123;&#123;'和'&#125;&#125;'就进行停止并将扫描的结果进行保存</span><span class="token keyword">class</span> <span class="token class-name">Scanner</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">templateStr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>templateStr <span class="token operator">=</span> templateStr        <span class="token keyword">this</span><span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token comment">//指针</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> templateStr<span class="token comment">//判断结束</span>    <span class="token punctuation">&#125;</span><span class="token comment">//scan是判断'&#123;&#123;'和'&#125;&#125;'的过程</span>    <span class="token function">scan</span><span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断tail变量是不是正好遇到了tag</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>pos <span class="token operator">+=</span> tag<span class="token punctuation">.</span>length <span class="token comment">//指针就增加tag的长度可以达到正好略过tag的效果</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>templateStr<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>pos<span class="token punctuation">)</span> <span class="token comment">//将指针后面的所有字符串传入tail变量</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//scanUtil是判断没有遇到'&#123;&#123;'和'&#125;&#125;'的过程</span>    <span class="token function">scanUtil</span><span class="token punctuation">(</span><span class="token parameter">stopTag</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//传入一个需要停止的标记 例如：'&#123;&#123;'和'&#125;&#125;'</span>        <span class="token keyword">const</span> pos_backup <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pos <span class="token comment">//将此时的指针传给一个变量，记录当前指针的初始值</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>stopTag<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">eos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//只要指针没有遇到需要停止的标记而且小于模板字符串的长度就不停止遍历</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>pos<span class="token operator">++</span> <span class="token comment">//每次循环指针向右移动</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>templateStr<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>pos<span class="token punctuation">)</span> <span class="token comment">//让tail变量不断右移全部扫描完就可退出循环</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>templateStr<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>pos_backup<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>pos<span class="token punctuation">)</span><span class="token comment">//substring来截断指针开始到结束位置所获得的字符串</span>    <span class="token punctuation">&#125;</span>    <span class="token function">eos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pos <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>templateStr<span class="token punctuation">.</span>length    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//将模板字符串变为tokens数组</span><span class="token keyword">function</span> <span class="token function">parseTemplateToTokens</span><span class="token punctuation">(</span><span class="token parameter">templateStr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//传参传入一个模板字符串</span>    <span class="token keyword">var</span> tokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//定义一个空的tokens数组</span>        <span class="token keyword">var</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>templateStr<span class="token punctuation">)</span> <span class="token comment">//将Scanner实例化</span>        <span class="token keyword">var</span> words <span class="token comment">//定义一个变量</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>scanner<span class="token punctuation">.</span><span class="token function">eos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//小于模板字符串的长度就不停止遍历</span>        words <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scanUtil</span><span class="token punctuation">(</span><span class="token string">'&#123;&#123;'</span><span class="token punctuation">)</span> <span class="token comment">//传入'&#123;&#123;'作为停止扫描的标记 并将结果字符串存入words</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>words <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//经过上一行代码一定会走入这语句</span>            tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'text'</span><span class="token punctuation">,</span>words<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//因为这时候扫描的是'&#123;&#123;'之前的数据，所以作为text进行传入tokens</span>        <span class="token punctuation">&#125;</span>                words <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token string">'&#123;&#123;'</span><span class="token punctuation">)</span> <span class="token comment">//说明上方已经扫描到'&#123;&#123;'并停止运行就得使用scan进行跳过</span>        words <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scanUtil</span><span class="token punctuation">(</span><span class="token string">'&#125;&#125;'</span><span class="token punctuation">)</span> <span class="token comment">//再传入'&#125;&#125;'作为停止扫描的标记 这时候扫描的就是'&#123;&#123;&#125;&#125;'之间的数据</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>words <span class="token operator">!=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//经过上一行代码一定会走入这语句</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//判断'&#123;&#123;&#125;&#125;'之间的第一个字符串是不是#,是#说明要进行循环，额外记录</span>                tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'#'</span><span class="token punctuation">,</span>words<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//判断'&#123;&#123;&#125;&#125;'之间的第一个字符串是不是/,是/说明要停止循环，额外记录</span>                tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/'</span><span class="token punctuation">,</span>words<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span> <span class="token comment">//以上都不是的话说明里面是要更换的数据</span>                tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span>words<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                words <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token string">'&#125;&#125;'</span><span class="token punctuation">)</span> <span class="token comment">//最后再跳过'&#125;&#125;' 可以进行下一轮扫描</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">nextTokens</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span> <span class="token comment">//因为遇到#需要遍历并将内容数据进行保存为数组，所以使用 nextTokens 折叠tokens nextTokens代码在下方</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//用于折叠tokens 用栈的形式，先进后出</span><span class="token keyword">function</span> <span class="token function">nextTokens</span><span class="token punctuation">(</span><span class="token parameter">tokens</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//tokens为上方已扫描完成的</span>    <span class="token keyword">var</span> nestedTokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">var</span> sections <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment">//创建一个栈</span>    <span class="token keyword">var</span> collector <span class="token operator">=</span> nestedTokens <span class="token comment">//因为引用数据类型只会改变指针，不会新复制内容</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//tokens.length是已扫描完成整个的数组长度</span>        <span class="token keyword">let</span> token <span class="token operator">=</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">//每次循环都将得到tokens赋值给token token每次运行完都会释放</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>token<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">'#'</span><span class="token operator">:</span> <span class="token comment">//判断第一个是不是 # ,是的话说明要新建数组 </span>                collector<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token comment">//此时collector新建数组相当于往nestedTokens中添加数组</span>                sections<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token comment">//同时向sections中添加数组 进栈</span>                collector <span class="token operator">=</span> token<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//这里将collector指向了token[2]</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>                sections<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//出栈</span>                collector <span class="token operator">=</span> sections<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> sections<span class="token punctuation">[</span>sections<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">:</span>nestedTokens <span class="token comment">//判断是不是栈所有数据都已经弹出，没有则将collector指向栈的最后一个位置继续添加数据，全部弹出则将collector继续指向nestedTokens再一次进行以上操作</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                collector<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token comment">//如果不是要新建数组则默认push</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> nestedTokens<span class="token punctuation">&#125;</span></code></pre><p>完成以上步骤就可以实现将模板字符串转变为<code>tokens</code>数组，接下来要做的就是读取数据了</p><p>在实现数据的读取前，需要做一个准备工作。</p><p>在js中无法通过<code>object1[&#39;object2.object3&#39;]</code>来读取嵌套的对象数据，举例代码如下：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> object1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">p</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">q</span><span class="token operator">:</span><span class="token number">123</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>object1<span class="token punctuation">[</span><span class="token string">'p.q'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//输出undefined </span></code></pre><p>在上文只有通过<code> object1[&#39;p&#39;]</code>先访问到<code>p</code>再<code>p[&#39;q&#39;]</code>访问到里面数据，整合<code> object1[&#39;p&#39;][&#39;q&#39;]</code>，因为<code>vue</code>中模板语法都是用<code> .</code> 形式来进行访问，所以我们需要通过算法来进行改进</p><h5 id="解决对象嵌套"><a href="#解决对象嵌套" class="headerlink" title="解决对象嵌套"></a>解决对象嵌套</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//可以在dataObj对象中，寻找用连续点符号的keyName属性</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token parameter">dataObj<span class="token punctuation">,</span>keyName</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//传入的第一个为数据对象，第二个则为token[1]的值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>keyName<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> keyName <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//判断数据对象中是否有 . 并且token[1]的值不为 . (token[1]的值为 . 说明是要进行简单数组循环，所以我们要排除这种情况)</span>        <span class="token keyword">var</span> keys <span class="token operator">=</span> keyName<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token comment">//因为想要读取对象数据会用'.'，所以用'.'将传入的token[1]原本的字符串分割为字符串数组</span>                <span class="token keyword">var</span> temp <span class="token operator">=</span> dataObj <span class="token comment">//将传入的参数指针赋值给一个变量</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">//这里类似剥洋葱，通过循环来获得内部数据</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> temp<span class="token comment">//最后返回数据</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dataObj<span class="token punctuation">[</span>keyName<span class="token punctuation">]</span><span class="token comment">//没有'.'则返回原数据</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>解决了对象嵌套问题就可以继续进行下一步</p><h5 id="将tokens数组变为dom字符串"><a href="#将tokens数组变为dom字符串" class="headerlink" title="将tokens数组变为dom字符串"></a>将<code>tokens</code>数组变为<code>dom</code>字符串</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> lookup <span class="token keyword">from</span> <span class="token string">"./lookup"</span><span class="token punctuation">;</span><span class="token keyword">import</span> renderTemplate <span class="token keyword">from</span> <span class="token string">"./renderTemplate"</span><span class="token punctuation">;</span><span class="token comment">//让tokens数组变为dom字符串</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">renderTemplate</span><span class="token punctuation">(</span><span class="token parameter">tokens<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//传入的tokens是已经成为tokens数组的，data则是源数据</span>    <span class="token keyword">var</span> resultStr <span class="token operator">=</span> <span class="token string">''</span> <span class="token comment">//定义个空字符串，将接下来解析出来的数据都存入此字符串中</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> token <span class="token operator">=</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">//通过遍历将tokens拆分为一个数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'text'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            resultStr <span class="token operator">+=</span> token<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">//token[0]值为text说明只需要加数据进行，不需要进行额外处理</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            resultStr <span class="token operator">+=</span> <span class="token function">lookup</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>token<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//token[0]值为name说明为'&#123;&#123;&#125;&#125;'之间的数据，使用lookup方法来读取里面数据后再添加到字符串中</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//token[0]值为'#'说明需要递归处理后再进行添加</span>            resultStr <span class="token operator">+=</span> <span class="token function">parseArray</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token comment">//parseArray在下方进行介绍，这里接收parseArray传回的字符串</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> resultStr<span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> lookup <span class="token keyword">from</span> <span class="token string">"./lookup"</span><span class="token keyword">import</span> renderTemplate <span class="token keyword">from</span> <span class="token string">"./renderTemplate"</span><span class="token punctuation">;</span><span class="token comment">// 处理数组，结合renderTemplate实现递归</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">parseArray</span><span class="token punctuation">(</span><span class="token parameter">token<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token function">lookup</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>token<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//判断token[1]是否有对象嵌套，没有的话这里的v是data[token[1]]</span>    <span class="token keyword">var</span> resultStr <span class="token operator">=</span> <span class="token string">''</span><span class="token comment">//定义一个字符串来进行拼接</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//能进入这个方法说明token[2]是一个tokens数组，所以需要重新调用renderTemplate</span>        resultStr <span class="token operator">+=</span> <span class="token function">renderTemplate</span><span class="token punctuation">(</span>token<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>            <span class="token string-property property">'.'</span><span class="token operator">:</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//'.'是因为其中要是有简单数组循环，需要添加这个元素，剩下的原本数组则拓展运算符来进行结合</span>            <span class="token operator">...</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> resultStr<span class="token comment">//最后返回字符串形成递归</span><span class="token punctuation">&#125;</span></code></pre><p>这样就可以实现一个简单的模板字符串的应用了。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> mustache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的基础</title>
      <link href="/2022/04/24/javascript-de-ji-zhi/"/>
      <url>/2022/04/24/javascript-de-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h4 id="javascript的数据类型："><a href="#javascript的数据类型：" class="headerlink" title="javascript的数据类型："></a><code>javascript</code>的数据类型：</h4><img src="/2022/04/24/javascript-de-ji-zhi/dataType.png" class=""><h5 id="使用typeof来判断数据类型"><a href="#使用typeof来判断数据类型" class="headerlink" title="使用typeof来判断数据类型"></a>使用<code>typeof</code>来判断数据类型</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">'字符串'</span><span class="token punctuation">)</span><span class="token comment">//输出 string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token comment">//输出 number</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment">//输出 boolean</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//输出 object null输出object是历史遗留问题</span><span class="token keyword">let</span> aconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token comment">//输出 undefined</span><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> s<span class="token punctuation">)</span><span class="token comment">//输出 symbol</span><span class="token keyword">const</span> bigInt <span class="token operator">=</span> <span class="token number">132n</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bigInt<span class="token punctuation">)</span><span class="token comment">//输出 bigint</span><span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'函数'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> fn<span class="token punctuation">)</span><span class="token comment">//输出 function</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> arr<span class="token punctuation">)</span><span class="token comment">//输出 object</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">)</span><span class="token comment">//输出 object</span></code></pre><h5 id="使用instanceof判断对象是否相等"><a href="#使用instanceof判断对象是否相等" class="headerlink" title="使用instanceof判断对象是否相等"></a>使用<code>instanceof</code>判断对象是否相等</h5><p>判断方法： 实例对象 <code>instanceof</code> 构造函数</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">Fn</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token comment">//返回true 因为所有函数的原型链上都有Object方法</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token comment">//返回true</span></code></pre><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象是用数据来表示现实中的某一个具体的事物，对象中通常存储多个数据。</p><p>对象由一组<code>key:value</code>来相互对相应</p><p>对象中属性调用方法：</p><ul><li><code>key.value</code></li><li><code>key[&#39;value&#39;]</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建一个对象</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'Tom'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token function-variable function">setName</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string-property property">'special-type'</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">//第一种调用对象方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">//输出 Tom</span><span class="token comment">//第二种调用对象方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token string">'special-type'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//输出 1 用[]来调用必须加引号</span><span class="token keyword">const</span> propName <span class="token operator">=</span> <span class="token string">'Sname'</span><span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token string">'Jack'</span> p<span class="token punctuation">[</span>propName<span class="token punctuation">]</span> <span class="token operator">=</span> value <span class="token comment">//当要传入的key不确定的时候可以使用这种方式调用</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">//输出 &#123;name: 'Tom', age: 18, special-type: 1, Sname: 18, setName: ƒ&#125;</span></code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>定义函数的方法：</p><ul><li>函数声明<code>function fn()&#123;&#125;</code></li><li>表达式<code>const fn = function()&#123;&#125;</code></li><li>匿名函数的方式<code>(function()&#123;&#125;)()</code></li></ul><p>调用（执行）函数：</p><ul><li><code>fn()</code>：直接调用</li><li><code>obj.fn()</code>：通过对象调用</li><li><code>new fn()</code>：new调用</li><li><code>fn.call/apply(obj)</code>：临时让<code>fn</code>称为<code>obj</code>的方法进行调用</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//定义函数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token comment">//因为js预加载的缘故，这里会输出fn并不会报错</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn被调用'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn2<span class="token punctuation">)</span><span class="token comment">//报错，用es6语法声明函数变量并不会进行变量提升</span><span class="token keyword">const</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//调用函数</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//输出 fn被调用</span><span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//输出 fn被调用 new主要用来实例化函数</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//输出 fn被调用 call主要改变this的指向</span><span class="token comment">//匿名函数  无需调用，自动执行，在common js中可以暴露js文件</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是一个匿名函数'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h5 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的<code>this</code></h5><p><code>this</code>的指向总的来说就是谁调用就指向谁（不用ES6的箭头函数的情况下）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建一个函数</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token comment">//此时this指向window</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token comment">//此时this指向p</span>p<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//此时this指向p</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>p<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token comment">//使用call来改变this指向 此时this指向obj</span><span class="token keyword">const</span> test <span class="token operator">=</span> p<span class="token punctuation">.</span>setName<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//此时this指向window</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//由于在全局中调用所以 此时this指向window</span></code></pre><h4 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h4><img src="/2022/04/24/javascript-de-ji-zhi/proto.png" class=""><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>一般有需要有多个函数复用的方法或给实例对象使用的方法可以放到函数的原型上</p><ul><li>每个函数都有一个<code>prototype</code>，即为显式原型（属性）</li><li>每个实例对象都有一个<code>__proto__</code>，可称为隐式原型（属性）</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值</li></ul><p><strong>堆中的函数对象创建的<code>prototype</code>也是一个地址值</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//新建一个函数</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token comment">//默认指向一个Object空对象 输出 object对象 这里不考虑函数提升</span><span class="token comment">//给原型对象添加属性 </span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是test函数'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token comment">//输出 object对象 其中有test方法</span><span class="token comment">//创建实例对象</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fn<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 '这是test函数'</span><span class="token comment">//原型对象中的constructor方法，它指向函数对象本身</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token comment">//输出 true</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//判断实例对象的原型是否和函数的原型相等</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token comment">//输出 true</span><span class="token comment">//判断实例对象的地址值是否与函数的地址值相等</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn <span class="token operator">===</span> Fn<span class="token punctuation">)</span><span class="token comment">//输出 false</span></code></pre><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>在访问对象的一个属性时，首先会在自身所定义的属性中查找，若没有找到则会顺着<code>__proto__</code>进行查找，若最终没有找到会返回<code>undefined</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> fn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//判断两个实例对象的原型是否相等</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> fn2<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token comment">//输出 true</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//判断原型链的尽头是否为null</span><span class="token comment">//Fn.prototype为Object函数对象</span><span class="token comment">//Fn.prototype.__proto__ 为Object原型对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token comment">//输出 null</span></code></pre><h4 id="变量提升和与函数提升"><a href="#变量提升和与函数提升" class="headerlink" title="变量提升和与函数提升"></a>变量提升和与函数提升</h4><p>在<code>javascript</code>用<code>var</code>和 <code>function</code>声明的变量和函数会在赋值前提前就可以提前访问到</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//变量提升</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment">//输出undifined 并不会报错</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token comment">//函数提升</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 'fn()'</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn()'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//判断先函数提升还是先变量提升</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> Fnconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Fn<span class="token punctuation">)</span><span class="token comment">//输出 function</span><span class="token comment">//结果先执行变量提升，在进行函数提升，所以最后函数覆盖了变量</span></code></pre><h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><img src="/2022/04/24/javascript-de-ji-zhi/context.png" class=""><h5 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h5><p>在执行全局代码前会将<code>window</code>确定确定为全局执行上下文。</p><p>对全局数据会进行预处理</p><ul><li><code>var</code>定义的全局变量会先赋值为<code>undefined</code></li><li><code>function</code>声明的全局函数会赋值为<code>fun</code></li></ul><p>预处理结束以后才会执行全局代码 <strong>所以才会有了上方的函数提升与变量提升</strong></p><h5 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h5><p>在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象</p><p>对局部数据进行预处理</p><ul><li>形参变量进行赋值（实参）</li><li><code>arguments</code>进行赋值（实参列表）</li><li><code>var</code>定义的局部变量为<code>undefined</code></li><li><code>function</code>声明的函数会赋值为<code>fun</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn2()'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment">//输出 undifined 因为内部定义了 a 所以会先预处理内部属性，要是内部没有定义才会向上一级进行查找</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment">//输出 2</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token comment">//输出 1</span>    <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 'fn2()'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token comment">//输出 Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><p><strong>即使return了函数也会将下面代码执行完再出栈</strong></p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>分为全局作用域和函数作用域与块作用域（用<code>const</code>和<code>let</code>进行声明变量）</p><p>作用域主要问题用于隔离变量，不同作用域下的同名变量不会冲突</p><p>与执行上下文区别：</p><ul><li>除全局作用域外，作用域在函数定义时就已经确定了，而不是在函数调用时</li><li>全局执行上下文实在全局作用域确定之后，js代码马上执行之前创建</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token comment">//输出 '1 2 3' a是从全局作用域中寻找到的值</span>    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token number">4</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token comment">//输出 '1 2 4 3' a,b都是从外部作用域中寻找到的值</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//这里传参3</span></code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><img src="/2022/04/24/javascript-de-ji-zhi/closure.png" class=""><p>当一个嵌套的内部函数引用了外部函数的数据（变量&#x2F;函数）并执行外部函数就会产生闭包</p><p>闭包的作用：</p><ul><li>使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）</li><li>让函数外部可以操作（读写）到函数内部的数据</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//因为函数提升，此时闭包就已经创建</span>    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a<span class="token operator">++</span> <span class="token comment">//此时调用了外部的变量就会产生闭包</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//调用函数 输出 3</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//调用函数 输出 4</span>f <span class="token operator">=</span> <span class="token keyword">null</span><span class="token comment">//包含闭包函数对象成为垃圾对象 闭包才会死亡 不然会一直占用内存</span></code></pre><h4 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h4><h5 id="主线程（同步执行）"><a href="#主线程（同步执行）" class="headerlink" title="主线程（同步执行）"></a>主线程（同步执行）</h5><ul><li>JS引擎模块</li><li><code>html</code>，<code>css</code>文档解析模块</li><li><code>DOM/CSS</code>模块 等等…</li></ul><h5 id="分线程（异步执行）"><a href="#分线程（异步执行）" class="headerlink" title="分线程（异步执行）"></a>分线程（异步执行）</h5><p>包括宏队列与微队列</p><p>宏队列：</p><ul><li><code>dom</code>事件回调</li><li><code>ajax</code>回调</li><li>定时器回调</li></ul><p>微队列：</p><ul><li><code>promise</code>回调</li><li><code>mutation</code>回调</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//最后控制台输出 3 6 4 7 1 2 5</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span> <span class="token comment">//定时器中的代码属于宏队列中，会在同步代码与微队列中的代码执行完成后最后再进行执行</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span> <span class="token comment">//Promise的内部代码是同步先执行的，只有调用了then或catch等方法才会进入微队列成为异步执行</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//Promise的then为微队列中的代码，会在同步代码全部执行完后进行执行，在宏队列的代码之前执行</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//即使定时器then内部也不会优先执行，还是会进入到宏队列中</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">Fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//async里面的代码是同步执行的</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">Fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//通过await调用Fn2()</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token comment">//这里的代码要等上方的Fn2()的Promise执行完才执行</span><span class="token punctuation">&#125;</span><span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="Web-Worker-用的比较少"><a href="#Web-Worker-用的比较少" class="headerlink" title="Web Worker(用的比较少)"></a>Web Worker(用的比较少)</h4><p>因为js是单线程运行，为了增加运行的效率，h5中引入了新的api使得js可以模拟多线程运行，但同时也有一些缺点：</p><ul><li>运行速度比较慢</li><li>不能跨域加载JS</li><li><code>worker</code>内代码不能访问DOM（因为worker代码的<code>this</code>不是指向<code>window</code>）</li><li>浏览器兼容性差</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建一个Worker对象</span><span class="token keyword">var</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">'worker.js'</span><span class="token punctuation">)</span><span class="token comment">//内部传参为js文件夹名加后缀</span><span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token number">123</span><span class="token comment">//绑定接收消息的监听</span>worker<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'分线程返回的数据'</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">//输出分线程返回的数据124</span><span class="token punctuation">&#125;</span><span class="token comment">//向分线程发送消息</span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'向分线程发送数据'</span> <span class="token operator">+</span> number<span class="token punctuation">)</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//worker.js文件</span><span class="token keyword">var</span> <span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//这里不能使用函数声明，只能用变量声明，并且不能用const let，否则不会返回数据</span>    <span class="token keyword">var</span> number <span class="token operator">=</span> event<span class="token punctuation">.</span>data    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'分线程收到主线程发送的数据'</span><span class="token operator">+</span>number<span class="token punctuation">)</span>    <span class="token function">postMessage</span><span class="token punctuation">(</span>number<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//向主线程发送数据</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的基本使用</title>
      <link href="/2022/04/21/shen-ru-jie-xi-axios/"/>
      <url>/2022/04/21/shen-ru-jie-xi-axios/</url>
      
        <content type="html"><![CDATA[<p><strong>本文的后台数据通过<code>json-server</code>来模拟，对<code>json-server</code>感兴趣可以去看<a href="https://github.com/typicode">typicode</a>的github源网站</strong></p><h4 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h4><p>在<code>axios</code>的作者<a href="https://github.com/axios/axios/commits?author=jasonsaayman">jasonsaayman</a>可以看到<code>axios</code>的几种引入方式</p><pre class="language-none"><code class="language-none">Using npm:$ npm install axiosUsing bower:$ bower install axiosUsing yarn:$ yarn add axiosUsing jsDelivr CDN:&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;Using unpkg CDN:&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p><strong>这里以<code>script</code>方式引入来进行介绍</strong></p><h5 id="使用axios-方法来发送请求"><a href="#使用axios-方法来发送请求" class="headerlink" title="使用axios()方法来发送请求"></a>使用<code>axios()</code>方法来发送请求</h5><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送POST请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送PUT请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送DELETE请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token comment">//接收数据</span>        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token comment">//获取元素</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span><span class="token comment">//发送GET请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts'</span> <span class="token comment">//地址是json-server的地址</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//axios返回结果是promise，用then方法来接收</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//发送数据</span>        btns<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'POST'</span><span class="token punctuation">,</span><span class="token comment">//发送POST请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts'</span><span class="token punctuation">,</span><span class="token comment">//根据json-server的规则来编写地址</span>            <span class="token comment">//设置请求体</span>                <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token comment">//要发送的数据</span>                    <span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'今天天气不错'</span><span class="token punctuation">,</span>                    <span class="token literal-property property">author</span><span class="token operator">:</span><span class="token string">'张三'</span>                <span class="token punctuation">&#125;</span><span class="token comment">//此时在自己的json-server中创建的json文件中就会看到发送到的数据</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//更新数据</span>        btns<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'PUT'</span><span class="token punctuation">,</span><span class="token comment">//发送PUT请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts/3'</span><span class="token punctuation">,</span><span class="token comment">// /3表示要修改id为3的内容</span>            <span class="token comment">//设置请求体</span>                <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token comment">//要发送的数据</span>                    <span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'今天天气不错'</span><span class="token punctuation">,</span>                    <span class="token literal-property property">author</span><span class="token operator">:</span><span class="token string">'李四'</span>                <span class="token punctuation">&#125;</span><span class="token comment">//此时在自己的json-server中创建的json文件中就会看到发送到的数据</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//删除数据</span>        btns<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'DELETE'</span><span class="token punctuation">,</span><span class="token comment">//发送DELETE请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts/3'</span><span class="token punctuation">,</span><span class="token comment">// /3表示要删除id为3的内容</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="使用axios-request-来发送请求"><a href="#使用axios-request-来发送请求" class="headerlink" title="使用axios.request()来发送请求"></a>使用<code>axios.request()</code>来发送请求</h5><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            axios<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'GET'</span><span class="token punctuation">,</span><span class="token comment">//发送GET请求</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts'</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="使用axios-post-来发送请求"><a href="#使用axios-post-来发送请求" class="headerlink" title="使用axios.post()来发送请求"></a>使用<code>axios.post()</code>来发送请求</h5><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送POST请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//axios.post(url[, data[, config]])</span>            <span class="token comment">//post第一个参数为url,第二个为请求体内容,第三个为配置 二三都是可选的</span>            axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'http://localhost:3000/comments'</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token comment">//向comments部分发送数据</span>                <span class="token string-property property">"body"</span><span class="token operator">:</span> <span class="token string">"some comment"</span><span class="token punctuation">,</span>                <span class="token string-property property">"postId"</span><span class="token operator">:</span> <span class="token string">"2"</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//发送成功的回调</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p>多余的<code>axios</code>方法基本都与上方相同，就不再过多演示了</p><h5 id="axios默认配置"><a href="#axios默认配置" class="headerlink" title="axios默认配置"></a><code>axios</code>默认配置</h5><p>可以设置一些默认配置来减少代码的冗余</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>method <span class="token operator">=</span> <span class="token string">'GET'</span> <span class="token comment">//设置默认的请求类型为 GET</span>        axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>baseURL <span class="token operator">=</span> <span class="token string">'http://localhost:3000'</span> <span class="token comment">//设置基础URL</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            axios<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'/posts'</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//返回成功内容</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="axios创建实例对象来发送请求"><a href="#axios创建实例对象来发送请求" class="headerlink" title="axios创建实例对象来发送请求"></a><code>axios</code>创建实例对象来发送请求</h5><p>当想对两个域名不相同的服务器发送请求就可以使用创建实例对象来发送</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送服务器1GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送服务器2GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> server1 <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://api.bilibili.com'</span><span class="token punctuation">,</span> <span class="token comment">//演示这里的api就随便写了</span>            <span class="token literal-property property">timeout</span><span class="token operator">:</span><span class="token number">2000</span><span class="token comment">//设置2秒超时终止</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> server2 <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://sentry.music.163.com'</span><span class="token punctuation">,</span> <span class="token comment">//演示这里的api就随便写了</span>            <span class="token literal-property property">timeout</span><span class="token operator">:</span><span class="token number">2000</span><span class="token comment">//设置2秒超时终止</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">server1</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">'/x/web-interface/zone?jsonp=jsonp'</span><span class="token comment">//发送请求</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        btns<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">server2</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">'/wapm/api/sdk/collect'</span><span class="token comment">//发送请求</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a><code>axios</code>拦截器</h5><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--结果：输出：  请求拦截器 成功   响应拦截器 成功   发送请求成功--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>    btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//发送请求</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>                <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">'http://localhost:3000/posts'</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发送请求成功'</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'失败回调'</span><span class="token punctuation">)</span><span class="token comment">//请求拦截器失败会输出</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token comment">// 添加请求拦截器</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//use相当于promise的then方法，前面返回成功值，后面返回失败值</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求拦截器 成功'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> config<span class="token punctuation">;</span><span class="token comment">//这里要是抛出异常或promise返回值为失败则响应拦截器为失败</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求拦截器 失败'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加响应拦截器</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//只要请求码是2xx就是会接收到响应</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'响应拦截器 成功'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> response<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'响应拦截器 失败'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6与之后的语法</title>
      <link href="/2022/04/17/ecmascript6-yu-zhi-hou-de-yu-fa/"/>
      <url>/2022/04/17/ecmascript6-yu-zhi-hou-de-yu-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>注意：具体内容可以去参考<a href="https://www.ecma-international.org/">ECMA</a>官方文档，这里只是对某些语法进行总结与参考</strong></p><h3 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p><code>let</code>不能重复声明<code>var</code>可以重复声明</p><p><code>let</code>用来声明变量<code>const</code>用来声明常量<code>const</code>声明后不可以重新赋值，<code>let</code>可以重新赋值。<code>const</code>一定要赋初始值。</p><p>cs6后新增了块级作用域，使用<code>let</code>和<code>const</code>声明只在代码块中生效</p><p><code>let</code>和<code>const</code>不存在变量提升，用<code>var</code>声明变量会参与预加载</p><p>而且不影响作用域链</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> example <span class="token operator">=</span> <span class="token string">'例子'</span>    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//最终输出'例子'</span><span class="token punctuation">&#125;</span></code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这称为解构赋值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//数组解构</span><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子1'</span><span class="token punctuation">,</span><span class="token string">'例子2'</span><span class="token punctuation">,</span><span class="token string">'例子3'</span><span class="token punctuation">]</span><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">,</span><span class="token string">'example3'</span><span class="token punctuation">]</span> <span class="token operator">=</span> example<span class="token comment">//对象解构</span><span class="token keyword">const</span> exampleObj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'title'</span><span class="token punctuation">,</span>    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">'content'</span><span class="token punctuation">,</span>    <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是一个方法'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//let &#123;title,content,fn&#125; = exampleObj</span><span class="token comment">//可以单独解构出某一条你想用的方法或参数，可以直接调用函数</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span>fn<span class="token punctuation">&#125;</span> <span class="token operator">=</span> exampleObj<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以多级解构赋值，以对象为例子</span><span class="token keyword">const</span> reduplicate <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'title'</span><span class="token punctuation">,</span>    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">'content'</span><span class="token punctuation">,</span>    <span class="token literal-property property">obj</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">innterTitle</span><span class="token operator">:</span> <span class="token string">'内部标题'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">obj</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>innterTitle<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> reduplicateconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>innterTitle<span class="token punctuation">)</span><span class="token comment">//控制台输出'内部标题'</span></code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>ES6引入了新的声明字符串方式<code>[``]</code></p><p>特性：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//内容可以直接出现换行符</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;ul>&lt;li>不会报错&lt;/li>&lt;/ul></span><span class="token template-punctuation string">`</span></span><span class="token comment">//可以进行变量拼接</span><span class="token keyword">let</span> example <span class="token operator">=</span> <span class="token string">'例子1'</span><span class="token keyword">let</span> out <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>example<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">是第一个例子</span><span class="token template-punctuation string">`</span></span> <span class="token comment">//$&#123;&#125;是固定格式，里面放要拼接的变量名</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token comment">//输出'例子1是第一个例子'</span></code></pre><h4 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h4><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> example <span class="token operator">=</span> <span class="token string">'例子1'</span><span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//完整写法</span>    <span class="token comment">//example:example,</span>    <span class="token comment">//fn:fn</span>    <span class="token comment">//简化写法</span>    example<span class="token punctuation">,</span>    fn<span class="token punctuation">,</span>    <span class="token comment">//可以简化对象写法，不用再加function</span>    <span class="token literal-property property">Second</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第二个'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数this始终指向函数声明时所在作用域下的this的值</p><p>普通函数this谁调用指向谁</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//判断箭头函数this指向</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//设置window的a属性</span>window<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'window中的a'</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">'对象中的a'</span><span class="token punctuation">&#125;</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'window中的a'</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'window中的a'</span><span class="token comment">//接下来用call方法来调用改变this</span><span class="token function">fn1</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//对象中的a</span><span class="token function">fn2</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//输出'window中的a'</span></code></pre><p>箭头函数不能作为构造实例化对象</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//判断箭头函数是否能构造实例化对象</span><span class="token keyword">let</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">&#125;</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//结果报错Person is not a constructor</span></code></pre><p>箭头函数不能使用<code>arguments</code>变量（arguments是函数内部用来保存实参）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//判断箭头函数是否能使用使用arguments变量</span><span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//输出Arguments</span><span class="token keyword">let</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//结果报错arguments is not defined</span></code></pre><p>箭头函数的简写</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//当形参有且只有一个的时候可以省略小括号</span><span class="token keyword">let</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> n <span class="token operator">+</span> n <span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'2'</span><span class="token comment">//当代码提只有一条需要return语句的时候，可以省略花括号</span><span class="token keyword">let</span> <span class="token function-variable function">pow</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=></span> n<span class="token operator">*</span>nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'4'</span></code></pre><h4 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h4><p>ES6允许给函数参数赋值初始值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//具有默认值的参数，一般位置要靠后</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">3</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">&#125;</span><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment">//输出'6'</span></code></pre><p>可以与解构赋值相结合</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//没有传参数则用初始值</span><span class="token keyword">function</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>host<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>username<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token comment">//输出'127.0.0.1'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token comment">//输出'root'</span><span class="token punctuation">&#125;</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">username</span><span class="token operator">:</span><span class="token string">'root'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a><code>rest</code>参数</h4><p>ES6引入<code>rest</code>参数，用于获取函数的实参，用来代替<code>arguments</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token comment">//输出的是数组，可以使用数组的API，arguments输出的是对象</span><span class="token punctuation">&#125;</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token string">'数据'</span><span class="token punctuation">,</span><span class="token string">'数据2'</span><span class="token punctuation">)</span><span class="token comment">//如果要形参有多个，rest参数必须要放在最后</span></code></pre><h4 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h4><p>[…]扩展运算符能将[数组]转换为逗号分隔的[参数序列]</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//声明一个数组</span><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子1'</span><span class="token punctuation">,</span><span class="token string">'例子2'</span><span class="token punctuation">,</span><span class="token string">'例子3'</span><span class="token punctuation">]</span><span class="token comment">//声明一个函数</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token comment">//输出对象，对象中包含'0: "例子1"  1: "例子2"  2: "例子3"'</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>example<span class="token punctuation">)</span></code></pre><p>扩展运算符可以用于数组的合并</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子1'</span><span class="token punctuation">,</span><span class="token string">'例子2'</span><span class="token punctuation">,</span><span class="token string">'例子3'</span><span class="token punctuation">]</span><span class="token keyword">const</span> example2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子4'</span><span class="token punctuation">,</span><span class="token string">'例子5'</span><span class="token punctuation">,</span><span class="token string">'例子6'</span><span class="token punctuation">]</span><span class="token comment">//const gather = example.concat(example2)  传统方法</span><span class="token keyword">const</span> gather <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>example<span class="token punctuation">,</span><span class="token operator">...</span>example2<span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gather<span class="token punctuation">)</span><span class="token comment">//输出['例子1', '例子2', '例子3', '例子4', '例子5', '例子6']</span></code></pre><p>还能将伪数组转为真正的数组</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">const</span> divs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> divArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>divs<span class="token punctuation">]</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>divArr<span class="token punctuation">)</span><span class="token comment">//输出 [div, div, div]</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="Symbol数据类型"><a href="#Symbol数据类型" class="headerlink" title="Symbol数据类型"></a><code>Symbol</code>数据类型</h4><p><code>ES6</code>引入了一种新的原始数据类型<code>Symbol</code>，用来表示独一无二的值，是一种字符串类型。</p><p><code>Symbol</code>特点</p><ol><li><code>Symbol</code>的值是唯一的，用来解决命名冲突的问题。</li><li><code>Symbol</code>值不能与其他数据进行运算。</li><li><code>Symbol</code>定义的对象属性不能使用 <code>for...in</code> 循环遍历，但是可以使用<code>Reflect.ownKeys</code>来获取对象的所有键名。</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建Symbol</span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s2 <span class="token operator">===</span> s<span class="token punctuation">)</span><span class="token comment">//输出false</span><span class="token comment">//Symbol.for 创建</span><span class="token keyword">let</span> s3 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span><span class="token keyword">let</span> s4 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s3<span class="token operator">===</span>s4<span class="token punctuation">)</span><span class="token comment">//输出true</span><span class="token comment">//在不确定对象里是否有要创建的值的时候可以使用Symbol来添加方法</span><span class="token comment">//向对象中添加up down方法</span><span class="token keyword">let</span> game<span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">up</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'gameup'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> methods <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">up</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token literal-property property">down</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> game<span class="token punctuation">[</span>methods<span class="token punctuation">.</span>up<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'up'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>game<span class="token punctuation">[</span>methods<span class="token punctuation">.</span>down<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'down'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>game<span class="token punctuation">.</span><span class="token function">up</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'gameup'</span>game<span class="token punctuation">[</span>methods<span class="token punctuation">.</span>up<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'up'</span><span class="token comment">//在对象中直接定义Symbol</span><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>   <span class="token punctuation">[</span>example<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>obj<span class="token punctuation">[</span>example<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'例子'</span></code></pre><p><code>Sybol</code>的<code>hasInstance()</code>可以自己控制类型检测值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//param是判断类型的值</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token comment">//这里因为和o判断所以输出的就是&#123;&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token comment">//因为上方return true 输出的就是true</span></code></pre><p>剩下的方法可以通过官方文档了解更多，这里就不过多赘述了。</p><h4 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h4><p>迭代器（iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p><p><code>ES6</code>创造了一种新的遍历命令<code>for...of</code>循环，iterator接口主要供<code>for...of</code>消费</p><p>原生具备iterator接口的数据</p><ul><li>Array</li><li>Arguments</li><li>Set</li><li>Map</li><li>String</li><li>TypedArray</li><li>NodeList</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//只要有Symbol.iterator()就可以使用for...of</span><span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'exam'</span><span class="token punctuation">,</span><span class="token string">'exam2'</span><span class="token punctuation">,</span><span class="token string">'exam3'</span><span class="token punctuation">]</span><span class="token comment">//先用for...in循环遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">in</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//保存的是键名，输出'0 1 2'</span><span class="token punctuation">&#125;</span><span class="token comment">//使用for...of遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//保存的是键值，输出'exam exam2 exam3</span><span class="token punctuation">&#125;</span></code></pre><p><strong>工作原理</strong></p><ul><li>创建一个指针对象，指向当前数据结构的起始位置</li><li>第一次调用对象的<code>next</code>方法，指针自动指向数据结构的第一个成员</li><li>接下来不断调用<code>next</code>方法，指针一直往后移动，直到指向最后一个成员</li><li>每调用<code>next</code>方法返回一个包含<code>value</code>和<code>done</code>属性的对象</li><li>当<code>value</code>为<code>undefined</code>且<code>done</code>为<code>true</code>时，结束调用</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//手写调用iterator()</span><span class="token comment">//声明一个对象</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'name'</span><span class="token punctuation">,</span>    <span class="token literal-property property">arr</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token string">'arr1'</span><span class="token punctuation">,</span>        <span class="token string">'arr2'</span><span class="token punctuation">,</span>        <span class="token string">'arr3'</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//对象中没有迭代器方法，我们手动添加</span>        <span class="token comment">//用索引变量来判断是否超过了数组的长度</span>        <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">return</span><span class="token punctuation">&#123;</span>            <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token comment">//原本的迭代器需要返回value和done属性，所以我们也要添加上</span>                    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token literal-property property">done</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span>                    index<span class="token operator">++</span>                    <span class="token keyword">return</span> result                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">value</span><span class="token operator">:</span><span class="token keyword">undefined</span> <span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//遍历这个对象,不使用obj.arr拿到arr中数据</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//结果输出'arr1 arr2 arr3'</span><span class="token punctuation">&#125;</span></code></pre><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同</p><p>生成器是一种特殊的函数</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//生成器函数必须要加*</span><span class="token keyword">function</span> <span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'helloWorld'</span><span class="token punctuation">)</span>    <span class="token comment">//内部可以使用yield来作为分隔符</span>    <span class="token keyword">yield</span> <span class="token string">'slide'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'helloHTML'</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span> <span class="token string">'slide2'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'helloJS'</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span> <span class="token string">'slide3'</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> iterator <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//使用迭代器方法调用</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'helloWorld'</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'helloHTML'</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'helloJS'</span><span class="token comment">//也可以使用for...of遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//输出'helloWorld' 加上分隔符名 'slide' 'helloHTML' 加上分隔符名 'slide'以此类推</span><span class="token punctuation">&#125;</span></code></pre><p>生成器函数参数传递</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> one <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">111</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token comment">//输出next()传递的'one中的BBB'</span>    <span class="token keyword">let</span> two <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">222</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token comment">//输出next()传递的'two中的BBB'</span>    <span class="token keyword">let</span> three <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">333</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span><span class="token comment">//输出next()传递的'three中的BBB'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> interator <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//第一次调用</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'one中的BBB'</span><span class="token punctuation">)</span><span class="token comment">//第二次调用作为第一次yield的返回结果</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'two中的BBB'</span><span class="token punctuation">)</span><span class="token comment">//第三次调用作为第二次yield的返回结果</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'three中的BBB'</span><span class="token punctuation">)</span><span class="token comment">//第四次调用作为第三次yield的返回结果</span></code></pre><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>promise</code>是<code>ES6</code>引入的异步编程的新解决方案。用来封装异步操作并可以获取其成功或失败的结果</p><ul><li><code>Promise</code>构造函数：<code>Promise(excutor)&#123;&#125;</code></li><li><code>Promise.prototype.then</code>方法</li><li><code>Promise.prototype.catch</code>方法(就是捕获<code>promise</code>失败,这里就不过多介绍了)</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//实例化Promise</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">'数据'</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment">//调用resolve即为成功</span>        <span class="token keyword">const</span> err <span class="token operator">=</span> <span class="token string">'错误'</span>        <span class="token comment">//reject(err)  调用reject即为失败</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//then方法返回的也是promise对象，可以继续调用promise方法。状态由回调函数的结果决定</span><span class="token comment">//如果返回的是非promise类型的属性，状态为成功，返回值为对象的成功值</span><span class="token comment">//then中是异步调用，Promise中式同步调用</span><span class="token keyword">const</span> result <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token comment">//输出'数据'</span>    <span class="token keyword">return</span> <span class="token keyword">throw</span> <span class="token number">1</span> <span class="token comment">//不返回默认undifiend 返回错误或者在promise中调用reject都是返回失败的promise</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token parameter">reason</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//失败时候会调用reason</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">//输出中PromiseResult值为1</span></code></pre><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h4><p><code>ES6</code>提供了新的数据结构<code>Set</code>(集合)。它类似于数组，但成员的值都是唯一的，集合实现了<code>iterator</code>接口，所以可以使用扩展运算符和<code>for...of</code>进行遍历</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//自动去重1就只输出一次</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出Set中包含'1 2 3 4'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment">//输出'4' 类似数组length方法</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">//添加新的元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出Set中包含'1 2 3 4 5'</span>s<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//删除元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出Set中包含'2 3 4 5'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//检测是否有5这个元素  输出'true'</span>s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//清空集合</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出元素为空</span></code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>ES6</code>提供了<code>Map</code>数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<code>Map</code>也实现了<code>iterator</code>接口，所以可以使用扩展运算符和<code>for...of</code>进行遍历</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'title'</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'title1'</span><span class="token punctuation">,</span><span class="token string">'title2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment">//元素的键为对象，值为数组</span><span class="token comment">//查看长度</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment">//输出1</span><span class="token comment">//获取元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出的是上方数组</span><span class="token comment">//删除元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment">//为空对象</span></code></pre><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p><code>ES6</code>提供了更接近传统语言的写法，引入了<code>Class</code>（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，<code>ES6</code>的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，<code>ES5</code>都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更加面向对象编程的语法</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token comment">//构造方法 名字不能修改</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span> price</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> brand        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price    <span class="token punctuation">&#125;</span>    <span class="token comment">//方法必须使用该语法，不能使用ES5的对象完整写法</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以打电话'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token constant">HW</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token string">'max'</span> <span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">HW</span><span class="token punctuation">)</span><span class="token comment">//输出函数</span></code></pre><p>static静态成员</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token comment">//使用static标识的只属于Phone这个类</span>    <span class="token keyword">static</span> name <span class="token operator">=</span> <span class="token string">'手机'</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> nokia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nokia<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">//输出'undifined'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Phone<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">//输出'手机'</span></code></pre><p>对象继承</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//ES6之前实现继承，原理是使用原型链来实现继承</span><span class="token keyword">function</span> <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span>price</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> brand    <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">&#125;</span><span class="token class-name">Phone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以打电话'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//子级构造函数</span><span class="token keyword">function</span> <span class="token function">SmartPhone</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span>price<span class="token punctuation">,</span>color<span class="token punctuation">,</span>size</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Phone</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>brand<span class="token punctuation">,</span>price<span class="token punctuation">)</span><span class="token comment">//用call()方法改变this指向</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">&#125;</span><span class="token comment">//设置子级构造函数的原型</span><span class="token class-name">SmartPhone</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token class-name">SmartPhone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SmartPhone<span class="token comment">//声明调用子类的方法</span><span class="token class-name">SmartPhone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">photo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以拍照'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> chuizi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmartPhone</span><span class="token punctuation">(</span><span class="token string">'锤子'</span><span class="token punctuation">,</span><span class="token number">2499</span><span class="token punctuation">,</span><span class="token string">'黑色'</span><span class="token punctuation">,</span><span class="token string">'5.5'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chuizi<span class="token punctuation">)</span><span class="token comment">//父类方法在原型链上</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//ES6实现继承</span><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span> price</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> brand        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price    <span class="token punctuation">&#125;</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以打电话'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">SmartPhone</span> <span class="token keyword">extends</span> <span class="token class-name">Phone</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span>price<span class="token punctuation">,</span>color<span class="token punctuation">,</span>size</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//用super来继承父类,super只能再创建对象时候调用，不能直接调用父类方法</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>brand<span class="token punctuation">,</span>price<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size    <span class="token punctuation">&#125;</span>        <span class="token function">photo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'拍照'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//因为父类有了call方法，子类再添加相同名的方法会进行重写call的方法</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以视频通话'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> chuizi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmartPhone</span><span class="token punctuation">(</span><span class="token string">'锤子'</span><span class="token punctuation">,</span><span class="token number">2499</span><span class="token punctuation">,</span><span class="token string">'黑色'</span><span class="token punctuation">,</span><span class="token string">'5.5'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chuizi<span class="token punctuation">)</span><span class="token comment">//父类方法在原型链上</span><span class="token function">chuizi</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'我可以视频通话'</span></code></pre><p><code>getter</code>和<code>setter</code>设置</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token comment">//只要被读取就会触发get方法</span>    <span class="token keyword">get</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'价格被读取了'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">'get返回了'</span><span class="token comment">//返回值就是属性值</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">set</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//必须设置参数</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'价格属性被修改了'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>price <span class="token operator">=</span> <span class="token string">'1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token comment">//输出'get返回了'</span></code></pre><h4 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//Number.EPSILON 是 JavaScript 表示的最小精度 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token comment">//因为浮点数精度问题 返回的是false</span><span class="token keyword">function</span> <span class="token function">equal</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//判断传过来的两数之差的绝对值是否小于最小精度</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token comment">//小于就认为两数相等</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token operator">+</span><span class="token number">0.2</span><span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出true</span><span class="token comment">//Number.isFinite 检测一个数值是否为有限数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回false</span><span class="token comment">//Number.isNaN 检测是否为NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回false</span><span class="token comment">//Number.isInteger 判断是否为整数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回true</span><span class="token comment">//Math.trunc 将数字的小数部分抹掉</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">trunc</span><span class="token punctuation">(</span><span class="token number">123.123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'123'</span><span class="token comment">//Math.sign 判断一个数为正数 负数 还是零</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'0'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'-1'</span></code></pre><h4 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h4><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p><p>模块化的好处：</p><ol><li>防止命名冲突</li><li>代码复用</li><li>高维护性</li></ol><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code></p><ul><li><code>export</code>用于规定模块的对外接口</li><li><code>import</code>用于输入其他模块提供的功能</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//要暴露的文件 所有使用的语法就全在这代码块中演示了，不做分割了</span><span class="token keyword">export</span> <span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token string">'标题'</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这里是内容'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//统一暴露</span><span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token string">'标题'</span><span class="token keyword">function</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这里是内容'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>title<span class="token punctuation">,</span>content<span class="token punctuation">&#125;</span><span class="token comment">//默认暴露,内容以对象居多</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'标题'</span><span class="token punctuation">,</span>    <span class="token function-variable function">content</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这里是内容'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//引入上方的文件</span><span class="token comment">//通用的导入方式</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> m1 <span class="token keyword">from</span> <span class="token string">'./src/js/m1.js'</span> <span class="token comment">//'*'表示全引入</span><span class="token comment">//解构赋值形式</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>title<span class="token punctuation">,</span>content<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./src/js/m1.js'</span> <span class="token comment">//使用方法就和解构语法一样</span><span class="token comment">//简便形式 针对默认暴露</span><span class="token keyword">import</span> m3 <span class="token keyword">from</span> <span class="token string">'./src/js/m1.js'</span></code></pre><h3 id="ES7新特性"><a href="#ES7新特性" class="headerlink" title="ES7新特性"></a>ES7新特性</h3><p><code>Array.includes</code>来判断数组中是否有当前元素</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出true</span><span class="token comment">//之前可以使用indexOf来判断是否有当前元素，返回的是下标，不存在则返回-1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出4</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出-1</span></code></pre><p>幂运算<code>**</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token comment">//输出8</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出8 效果相同</span></code></pre><h3 id="ES8新特性"><a href="#ES8新特性" class="headerlink" title="ES8新特性"></a>ES8新特性</h3><p><code>async</code>和<code>await</code>可以让异步代码像同步代码一样</p><p><code>async</code>函数返回值是<code>promise</code>对象</p><p><code>promise</code>对象的结果由<code>async</code>函数执行的返回值决定</p><p><code>await</code>必须写在<code>async</code>函数中</p><p><code>await</code>右侧的表达式一般为<code>promise</code>对象</p><p><code>await</code>返回的是<code>promise</code>成功的值</p><p><code>await</code>的<code>promise</code>失败了将会抛出异常，需要通过<code>try...catch</code>捕获处理</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//async中的函数为同步执行</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">333</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出结果为 222 111 333</span></code></pre><h3 id="ES9扩展运算符与rest参数"><a href="#ES9扩展运算符与rest参数" class="headerlink" title="ES9扩展运算符与rest参数"></a>ES9扩展运算符与<code>rest</code>参数</h3><p><code>rest</code>参数与<code>spread</code>扩展运算符在<code>ES6</code>中以及引入，不过<code>ES6</code>中只针对于数组，在<code>ES9</code>中为对象提供了像数组一样的<code>rest</code>参数和扩展运算符</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> ip <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">host</span><span class="token operator">:</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'root'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> pwd <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">password</span><span class="token operator">:</span><span class="token string">'root'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> connect <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span>ip<span class="token punctuation">,</span><span class="token operator">...</span>name<span class="token punctuation">,</span><span class="token operator">...</span>pwd<span class="token punctuation">&#125;</span><span class="token comment">//将三个对象的属性放在了一个对象中</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>connect<span class="token punctuation">)</span><span class="token comment">//输出对象包含上面三个属性</span></code></pre><p><strong><code>ES9</code>新增的正则扩展就不介绍了</strong></p><h3 id="ES10扩展方法"><a href="#ES10扩展方法" class="headerlink" title="ES10扩展方法"></a>ES10扩展方法</h3><p>对象扩展方法<code>Object.fromEntries</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建一个二维数组</span><span class="token keyword">const</span> result <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'名字'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span><span class="token string">'标题'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment">//输出&#123;name: '名字', title: '标题'&#125;</span><span class="token comment">//与ES8中的Object.entries相当于逆运算</span><span class="token comment">//Object.fromEntries是把二维数组转换为对象</span><span class="token comment">//Object.entries是把对象转换为二维数组</span><span class="token keyword">const</span> arr <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'名字'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">//输出[Array(2)]</span></code></pre><p>字符串方法扩展</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//trim用来清除字符串空白字符</span><span class="token comment">//ES10中引入trimStart trimEnd来选择清除开始还是结束的空白字符</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'   e    '</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment">//输出'   e    '</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">trimStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'e    '</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">trimEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'   e'</span></code></pre><p>数组方法扩展</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//flat </span><span class="token comment">//将多维数组转化为低维数组</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">//创建一个三维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出  [1, 2, 3, Array(3)]  三维数组变成了二维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出 [1, 2, 3, 4, 5, 6] 二维数组变成了一维数组  flat默认深度为1</span></code></pre><h3 id="ES11特性"><a href="#ES11特性" class="headerlink" title="ES11特性"></a>ES11特性</h3><p>私有属性</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token comment">//公有属性</span>    name    <span class="token comment">//私有属性</span>    #age    #weight        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>weight</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name        <span class="token keyword">this</span><span class="token punctuation">.</span>#age <span class="token operator">=</span> age        <span class="token keyword">this</span><span class="token punctuation">.</span>#weight <span class="token operator">=</span> weight    <span class="token punctuation">&#125;</span>        <span class="token function">intro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#age<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#weight<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//实例化</span><span class="token keyword">const</span> gril <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span> <span class="token punctuation">(</span><span class="token string">'小红'</span><span class="token punctuation">,</span> <span class="token number">18</span> <span class="token punctuation">,</span> <span class="token string">'45kg'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gril<span class="token punctuation">)</span>gril<span class="token punctuation">.</span><span class="token function">intro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 小红 18 45kg</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gril<span class="token punctuation">.</span>#age<span class="token punctuation">)</span><span class="token comment">//报语法错误，不能在类外部调用</span></code></pre><p><code>Promise.allSettled</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//声明两个promise对象</span><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第一个'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'第二个'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//调用allSettled方法</span><span class="token keyword">const</span> result <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment">//输出promise成功的值和结果数组  无论结果失败成功都会输出成功状态</span><span class="token comment">//调用all方法</span><span class="token keyword">const</span> result2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token comment">//值为失败并报错</span></code></pre><p>可选链操作符</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// ?. 用于判断前前面的值是否存在</span><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> db <span class="token operator">=</span> config <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>db <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>db<span class="token punctuation">.</span>host <span class="token comment">//原先的判断方法，当全为true再赋值</span>    <span class="token keyword">const</span> newDb <span class="token operator">=</span> config<span class="token operator">?.</span>db<span class="token operator">?.</span>host    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token comment">//输出172.0.0.1</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newDb<span class="token punctuation">)</span><span class="token comment">//输出172.0.0.1</span><span class="token punctuation">&#125;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">db</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">host</span><span class="token operator">:</span><span class="token string">'172.0.0.1'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>动态<code>import</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//要引入的文件</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是要暴露的文件'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用的时候在引入文件</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./fn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token operator">=></span><span class="token punctuation">&#123;</span> <span class="token comment">//是一个promise对象  路径是我随便瞎写的，根据实际情况调整</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>moudule<span class="token punctuation">)</span><span class="token comment">//使用的时候才会调用</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p><code>BigInt</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">123n</span> <span class="token comment">//加了n就表示大整形，bigInt用于更大数值的运算，bigInt不能和普通整形运算，必须都为bigInt</span><span class="token keyword">let</span> max <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token comment">//获取整数最大安全值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token comment">//输出9007199254740991</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token function">BigInt</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出9007199254741114n</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//报错</span></code></pre><p><code>globalThis</code>如字面意思，<code>this</code>始终指向全局对象，无论在任何环境，这里就不作代码介绍了。</p><hr><blockquote><p>目前就到这里先结束了，以后要是有新总结会新添加</p><p>文章参考了尚硅谷的ES6教程，非常感谢老师们的辛勤付出！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_应用层</title>
      <link href="/2022/04/16/ji-suan-ji-wang-luo-ying-yong-ceng/"/>
      <url>/2022/04/16/ji-suan-ji-wang-luo-ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="6-1客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#6-1客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="6.1客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>6.1客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h3><p>​开发一种新的网络应用首先要考虑的问题就是网络应用程序再各种端系统上的组织方式和它们之间的关系</p><h4 id="客户-x2F-服务器方式"><a href="#客户-x2F-服务器方式" class="headerlink" title="客户&#x2F;服务器方式"></a>客户&#x2F;服务器方式</h4><p>​客户和服务器是指通信中所设计的两个应用进程<br>​客户&#x2F;服务器方式所描述的是进程之间服务和被服务的关系<br>​客户是服务请求方，服务器是服务提供方<br>​服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号80），而运行服务器的主机也具有固定的IP地址<br>​基于C&#x2F;S方式的应用服务通常是服务集中型的，常会出现服务器计算跟不上众多客户机请求的情况</p><h4 id="对等方式"><a href="#对等方式" class="headerlink" title="对等方式"></a>对等方式</h4><p>​没有固定的服务请求者和服务提供者，分布再网络边缘各端系统中的应用进程是对等的，被称为对等方。对等相互之间直接通信<br>​目前，再因特网上流行的P2P应用主要包括P2P文件共享、即时通讯、P2P流媒体、分布式存储等<br>​P2P的应用是服务分散型<br>​P2P方式最突出的特性之一就是它的可扩展性，系统性能不会因规模的增大而降低<br>​P2P方式具有成本上的优势</p><hr><h3 id="6-2动态主机配置协议DHCP"><a href="#6-2动态主机配置协议DHCP" class="headerlink" title="6.2动态主机配置协议DHCP"></a>6.2动态主机配置协议DHCP</h3><p>​允许一台计算机加入新网络时可自动获取IP地址等网络配置信息而不用手工参与</p><h4 id="DHCP主要使用以下报文来实现其功能"><a href="#DHCP主要使用以下报文来实现其功能" class="headerlink" title="DHCP主要使用以下报文来实现其功能"></a>DHCP主要使用以下报文来实现其功能</h4><h5 id="DHCP-DISCOVER"><a href="#DHCP-DISCOVER" class="headerlink" title="DHCP DISCOVER"></a>DHCP DISCOVER</h5><p>​DHCP发现报文</p><h5 id="DHCP-REQUEST"><a href="#DHCP-REQUEST" class="headerlink" title="DHCP REQUEST"></a>DHCP REQUEST</h5><p>​DHCP请求报文</p><h5 id="DHCP-NACK"><a href="#DHCP-NACK" class="headerlink" title="DHCP NACK"></a>DHCP NACK</h5><p>​DHCP否认报文</p><h5 id="DHCP-OFFER"><a href="#DHCP-OFFER" class="headerlink" title="DHCP OFFER"></a>DHCP OFFER</h5><p>​DHCP提供报文</p><h5 id="DHCP-ACK"><a href="#DHCP-ACK" class="headerlink" title="DHCP ACK"></a>DHCP ACK</h5><p>​DHCP确认报文</p><h5 id="DHCP-RELEASE"><a href="#DHCP-RELEASE" class="headerlink" title="DHCP RELEASE"></a>DHCP RELEASE</h5><p>​DHCP释放报文</p><h4 id="DHCP报文再运输层使用UDP协议封装"><a href="#DHCP报文再运输层使用UDP协议封装" class="headerlink" title="DHCP报文再运输层使用UDP协议封装"></a>DHCP报文再运输层使用UDP协议封装</h4><p>​DHCP客户使用的UDP端口号为68<br>​DHCP服务器使用的UDP端口号为67</p><h4 id="DHCP客户再未获得IP地址时使用地址0-0-0-0"><a href="#DHCP客户再未获得IP地址时使用地址0-0-0-0" class="headerlink" title="DHCP客户再未获得IP地址时使用地址0.0.0.0"></a>DHCP客户再未获得IP地址时使用地址0.0.0.0</h4><p>​现在是使每一个网络至少有一个DHCP中继代理（通常是一台路由器），它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁</p><hr><h3 id="6-3域名系统DNS"><a href="#6-3域名系统DNS" class="headerlink" title="6.3域名系统DNS"></a>6.3域名系统DNS</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>​将服务器IP地址解析为域名<br>​因特网采用层次树状结构的域名结构</p><h4 id="域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名"><a href="#域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名" class="headerlink" title="域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名"></a>域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名</h4><p>​每一级域名不超过63个字符，不区分大小写字母<br>​级别最低的域名写在最左边，最高的顶级域名写在最右边<br>​完整的域名不超过255个字符</p><h4 id="各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理"><a href="#各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理" class="headerlink" title="各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理"></a>各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理</h4><h4 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h4><h5 id="国家顶级域名nTLD"><a href="#国家顶级域名nTLD" class="headerlink" title="国家顶级域名nTLD"></a>国家顶级域名nTLD</h5><h5 id="通用顶级域名gTLD"><a href="#通用顶级域名gTLD" class="headerlink" title="通用顶级域名gTLD"></a>通用顶级域名gTLD</h5><h5 id="反向域arpa"><a href="#反向域arpa" class="headerlink" title="反向域arpa"></a>反向域arpa</h5><p>​用于反向域名解析，即IP地址反向解析为域名</p><h4 id="在国家顶级域名下注册的二级域名均有该国家自行确定"><a href="#在国家顶级域名下注册的二级域名均有该国家自行确定" class="headerlink" title="在国家顶级域名下注册的二级域名均有该国家自行确定"></a>在国家顶级域名下注册的二级域名均有该国家自行确定</h4><h4 id="我国则将二级域名划分为两类"><a href="#我国则将二级域名划分为两类" class="headerlink" title="我国则将二级域名划分为两类"></a>我国则将二级域名划分为两类</h4><p>​类别域名<br>​行政区域名</p><h4 id="域名服务器可以划分为四种类型"><a href="#域名服务器可以划分为四种类型" class="headerlink" title="域名服务器可以划分为四种类型"></a>域名服务器可以划分为四种类型</h4><h5 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h5><p>​通常不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</p><h5 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h5><p>​管理在该顶级域名服务器注册的所有二级域名</p><h5 id="权限域名服务器"><a href="#权限域名服务器" class="headerlink" title="权限域名服务器"></a>权限域名服务器</h5><p>​负责管理某个区的域名</p><h5 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h5><p>​本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中，它有时也称为默认域名服务器</p><h4 id="域名解析的过程"><a href="#域名解析的过程" class="headerlink" title="域名解析的过程"></a>域名解析的过程</h4><p>​递归查询<br>​迭代查询<br>​递归查询对于被查询的域名服务器负担太大，通常采用以下模式：从请求主机到本地域名服务器的查询时递归查询，则其余的查询时迭代查询</p><h4 id="在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项"><a href="#在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项" class="headerlink" title="在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项"></a>在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项</h4><hr><h3 id="6-4文件传送协议FTP"><a href="#6-4文件传送协议FTP" class="headerlink" title="6.4文件传送协议FTP"></a>6.4文件传送协议FTP</h3><p>​FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限</p><p>​FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</p><h4 id="FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接"><a href="#FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接" class="headerlink" title="FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接"></a>FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接</h4><p>​控制连接在整个会话期间一直保持打开，用于传送FTP相关控制命令<br>​数据连接用于文件传输，在每次文件传输时才建立，传输结束就关闭</p><h4 id="默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定"><a href="#默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定" class="headerlink" title="默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定"></a>默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定</h4><hr><h3 id="6-5电子邮件"><a href="#6-5电子邮件" class="headerlink" title="6.5电子邮件"></a>6.5电子邮件</h3><p>​电子邮件时因特网上最早流行的一种应用<br>​电子邮件采用客户&#x2F;服务器方式</p><h4 id="电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议"><a href="#电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议" class="headerlink" title="电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议"></a>电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议</h4><h5 id="用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件"><a href="#用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件" class="headerlink" title="用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件"></a>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</h5><h5 id="邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱"><a href="#邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱" class="headerlink" title="邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱"></a>邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱</h5><h5 id="协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3-IMAP）"><a href="#协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3-IMAP）" class="headerlink" title="协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3,IMAP）"></a>协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3,IMAP）</h5><h6 id="SMTP协议只能传送ASCLL码文本数据"><a href="#SMTP协议只能传送ASCLL码文本数据" class="headerlink" title="SMTP协议只能传送ASCLL码文本数据"></a>SMTP协议只能传送ASCLL码文本数据</h6><h6 id="为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件"><a href="#为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件" class="headerlink" title="为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件"></a>为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件</h6><p>​增加了5各新的邮件首部字段，这些字段提供了有关邮件主体的信息<br>​定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化<br>​定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变<br>​常见的邮件读取协议<br>​邮局协议POP<br>​POP3是其第三个版本，是因特网正式标准<br>​用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机，不允许用户在邮件服务器上管理自己的邮件<br>​因特网邮件访问协议IMAP<br>​IMAP4是其第四个版本，目前还只是因特网建议标准<br>​用户在自己的计算机上就可以操控邮件服务器中的邮箱<br>​POP3和IMAP4都采用基于TCP连接的客户&#x2F;服务器方式。POP3使用熟知端口110，IMAP4使用熟知端口143</p><h4 id="电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322-一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成"><a href="#电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322-一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成" class="headerlink" title="电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322.一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成"></a>电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322.一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成</h4><hr><h3 id="6-7万维网WWW"><a href="#6-7万维网WWW" class="headerlink" title="6.7万维网WWW"></a>6.7万维网WWW</h3><p>​是运行在因特网上的一个分布式应用</p><h4 id="万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置"><a href="#万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置" class="headerlink" title="万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置"></a>万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置</h4><p>​URL的一般形式由四个部分组成<br>​&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</p><h4 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h4><h5 id="HTTP-x2F-1-0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接"><a href="#HTTP-x2F-1-0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接" class="headerlink" title="HTTP&#x2F;1.0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接"></a>HTTP&#x2F;1.0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接</h5><p>​每请求一次文档就要有两倍的RTT的开销<br>​为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但这会大量占用万维网服务器资源</p><h5 id="HTTP-x2F-1-1采用持续连接。"><a href="#HTTP-x2F-1-1采用持续连接。" class="headerlink" title="HTTP&#x2F;1.1采用持续连接。"></a>HTTP&#x2F;1.1采用持续连接。</h5><p>​HTTP是面向文本，其报文中的每一个字段都是一些ASCLL码串，并且每个字段的长度都是不确定的</p><h5 id="使用Cookie在服务器上记录用于信息"><a href="#使用Cookie在服务器上记录用于信息" class="headerlink" title="使用Cookie在服务器上记录用于信息"></a>使用Cookie在服务器上记录用于信息</h5><p>​Cookie是一种对无状态的HTTP进行状态化的技术</p><h5 id="万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器"><a href="#万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器" class="headerlink" title="万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器"></a>万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器</h5><h5 id="Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源"><a href="#Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源" class="headerlink" title="Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源"></a>Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源</h5>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理_总线</title>
      <link href="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/"/>
      <url>/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h3><h4 id="一、为什么要用总线"><a href="#一、为什么要用总线" class="headerlink" title="一、为什么要用总线"></a>一、为什么要用总线</h4><p>分散连接存在的问题：</p><p>​1.内部的连线复杂</p><p>​2.新增IO设备困难</p><h4 id="二、什么是总线"><a href="#二、什么是总线" class="headerlink" title="二、什么是总线"></a>二、什么是总线</h4><p>​总线是连接各个部件的信息传输线，是<strong>各个部件共享的传输介质</strong></p><h4 id="三、总线上信息的传送"><a href="#三、总线上信息的传送" class="headerlink" title="三、总线上信息的传送"></a>三、总线上信息的传送</h4><p>​串行：所谓的串行就是将要传输的信息一位一位的放在总线上，接收方一位一位的进行接收，支持距离长</p><p>​并行：需要多条数据线进行传输，数据能同步进行传输，如果传输距离长，线与线之间并行传输，传输信号可能会发生变形，接收方很难接收到正确信号</p><p>四、总线结构</p><p>​1.单总线结构</p><p>​所有数据在同一条总线上传输，会发生总线争用问题</p><p>​2.面向CPU双总线结构</p><p>​向CPU延生出两条总线，IO总线和M总线，M总线连接主存。</p><p>​存在问题：一旦IO总线和M总线同时向CPU发送数据，CPU的计算任务还是会被打断。</p><p>​3.以存储器为中心的双总线结构</p><p>​从贮存延生两条总线，一条连接系统总线（包括IO设备接口和CPU），一条存储总线连接CPU。</p><hr><h3 id="3-2总线的分类"><a href="#3-2总线的分类" class="headerlink" title="3.2总线的分类"></a>3.2总线的分类</h3><h4 id="1-片内总线（芯片内部的总线）"><a href="#1-片内总线（芯片内部的总线）" class="headerlink" title="1.片内总线（芯片内部的总线）"></a>1.片内总线（芯片内部的总线）</h4><h4 id="2-系统总线（计算机各部件之间的信息）"><a href="#2-系统总线（计算机各部件之间的信息）" class="headerlink" title="2.系统总线（计算机各部件之间的信息）"></a>2.系统总线（计算机各部件之间的信息）</h4><h5 id="1-数据总线"><a href="#1-数据总线" class="headerlink" title="1.数据总线"></a>1.数据总线</h5><p>​<strong>双向</strong>与机器字长、存储字长有关。通常情况下，总线宽度&lt;&#x3D;机器字长或存储字长</p><h5 id="2-地址总线"><a href="#2-地址总线" class="headerlink" title="2.地址总线"></a>2.地址总线</h5><p>​<strong>单向</strong>与存储地址、IO地址有关</p><h5 id="3-控制总线"><a href="#3-控制总线" class="headerlink" title="3.控制总线"></a>3.控制总线</h5><p>​<strong>有出</strong> <strong>有入</strong>：存储器读、存储器写，总线允许、中断确认（都是由CPU向外送）</p><h4 id="3-通信总线"><a href="#3-通信总线" class="headerlink" title="3.通信总线"></a>3.通信总线</h4><p>​用于<strong>计算机系统之间</strong>或<strong>计算机系统与其他系统</strong>（如控制仪表、移动通信等）之间的通信</p><p>​传输方式： </p><p>​串行通信总线 </p><p>​并行通信总线</p><hr><h3 id="3-3总线特性及性能指标"><a href="#3-3总线特性及性能指标" class="headerlink" title="3.3总线特性及性能指标"></a>3.3总线特性及性能指标</h3><h4 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h4><h5 id="机械特性"><a href="#机械特性" class="headerlink" title="机械特性"></a>机械特性</h5><p>​尺寸、形状、管脚数以及排列顺序</p><h5 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h5><p>​传输方向和有效的电平范围</p><h5 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h5><p>​每根传输线的功能</p><h5 id="时间特性"><a href="#时间特性" class="headerlink" title="时间特性"></a>时间特性</h5><p>​信号的时序关系</p><h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><ol><li><p>总线宽度： 数据线的根数</p></li><li><p>标准传输率：每秒传输的最大字节数（如MBps）  </p></li><li><p>时钟同步&#x2F;异步：同步还是不同步</p></li><li><p>总线复用： 地址线与数据线复用（如8086）</p></li><li><p>信号线数： 地址线、数据线和控制线的综合</p></li><li><p>总线控制方式： 突发、自动、仲裁、逻辑、计数</p></li><li><p>其他指标： 负载能力</p></li></ol><hr><h3 id="3-4总线结构"><a href="#3-4总线结构" class="headerlink" title="3.4总线结构"></a>3.4总线结构</h3><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p>​将所有设备都连接在一条总线（系统总线）上</p><h4 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h4><p>​分为主存总线与IO总线，通过通道（具有特殊功能的处理器，由通道对IO统一管理）进行连接</p><h5 id="主存总线"><a href="#主存总线" class="headerlink" title="主存总线"></a>主存总线</h5><p>​连接CPU和主存</p><h5 id="IO总线"><a href="#IO总线" class="headerlink" title="IO总线"></a>IO总线</h5><p>​连接各种IO设备</p><h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><h5 id="结构一："><a href="#结构一：" class="headerlink" title="结构一："></a>结构一：</h5><p>​分为主存总线、IO总线、DMA总线（直接存储器访问）。</p><p>​主存总线连接CPU与主存。</p><p>​IO总线连接CPU与IO接口。</p><p>​DMA总线连接主存与IO接口。</p><h5 id="结构二："><a href="#结构二：" class="headerlink" title="结构二："></a>结构二：</h5><p>​分为局部总线、系统总线、扩展总线。</p><p>​<strong>局部总线</strong>连接CPU和Cache与局部IO控制器。</p><p>​<strong>系统总线</strong>连接主存与扩展总线接口。</p><p>​<strong>扩展总线</strong>连接局域网、SCSI、扩展总线接口、Modem、串行接口</p><h4 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h4><p>​分为局部总线、系统总线、高速总线、扩展总线。</p><p>​<strong>局部总线</strong>连接CPU和Cache&#x2F;桥。</p><p>​<strong>系统总线</strong>连接主存与Cache&#x2F;桥。</p><p>​<strong>高速总线</strong>连接SCSI、图形、多媒体、局域网、Cache&#x2F;桥和扩展总线接口。</p><p>​<strong>扩展总线</strong>连接FAX、扩展总线接口、Modem、串行接口。</p><h4 id="传统微型机总线结构"><a href="#传统微型机总线结构" class="headerlink" title="传统微型机总线结构"></a>传统微型机总线结构</h4><p>​分为系统总线和IO总线</p><p>​<strong>系统总线</strong>通过<strong>33MHz的32位数据通路</strong>连接CPU和主存控制器与存储器。</p><p>​系统总线通过<strong>标准总线控制器</strong>与IO总线相连。</p><p>​<strong>IO总线</strong>通过<strong>8MHz的16位数据通路</strong>连接SCSI II控制器、多媒体、高速局域网、高性能图形、Modem等。</p><h4 id="VL-BUS局部总线结构"><a href="#VL-BUS局部总线结构" class="headerlink" title="VL-BUS局部总线结构"></a>VL-BUS局部总线结构</h4><p>​分为系统总线、VL-BUS总线、IO总线</p><p>​<strong>系统总线</strong>连接CPU和主存控制器与存储器并延生一条线连接局部总线控制器和VL-BUS总线。</p><p>​<strong>VL-BUS总线（高速总线）</strong>通过<strong>33MHz的32位数据通路</strong>连接标准总线控制器、SCSI II控制器、多媒体、高速局域网、高性能图形等。</p><p>​<strong>IO总线</strong>通过<strong>8MHz的16位数据通路</strong>连接标准总线控制器、图文传真、Modem等</p><h4 id="PCI总线结构"><a href="#PCI总线结构" class="headerlink" title="PCI总线结构"></a>PCI总线结构</h4><p>分为系统总线、PCI总线、IO总线</p><p><strong>系统总线</strong>连接CPU、存储器和<strong>PCI桥</strong></p><p><strong>PCI总线</strong>通过<strong>33MHz的32位数据通路</strong>连接标准总线控制器、SCSI II控制器、多媒体、高速局域网、高性能图形等。</p><p><strong>IO总线</strong>通过<strong>8MHz的16位数据通路</strong>连接标准总线控制器、图文传真、Modem等</p><h4 id="多层PCI总线结构"><a href="#多层PCI总线结构" class="headerlink" title="多层PCI总线结构"></a>多层PCI总线结构</h4><p>分为存储器总线与各种桥电路</p><hr><h3 id="3-5总线控制"><a href="#3-5总线控制" class="headerlink" title="3.5总线控制"></a>3.5总线控制</h3><p>如何完成通信过程，保证通信过程的准确性，这就是总线控制</p><h4 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>​主设备（模块）：对总线由控制权</p><p>​从设备（模块）：相应从主设备发来的总线命令<strong>（有些设备既可以作为主设备也可以作为从设备）</strong></p><p>​总线判优控制：</p><p>​集中式（总线控制部件集中在一起）：</p><h6 id="链式查询方式："><a href="#链式查询方式：" class="headerlink" title="链式查询方式："></a>链式查询方式：</h6><p>​<img src="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/chainSearch.png" class=""></p><p>​数据线：用于信息交换过程数据的传输</p><p>​地址线：主设备与从设备进行数据传输要通过地址总线</p><p>​BR：所有线通过这条发送总线占用请求</p><p>​BS：某个设备占用了总线通过这条线告诉其他部件总线忙</p><p>​BG： 总线授权线</p><p>​<strong>注意：有一条总线出现故障，后面的电路均无法使用总线</strong></p><h6 id="计时器定时查询方式："><a href="#计时器定时查询方式：" class="headerlink" title="计时器定时查询方式："></a>计时器定时查询方式：</h6><p>​<img src="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/countSearch.png" class=""></p><p>​通过BR发送总线占用请求，总线控制部件收到请求后，通过<strong>设备地址</strong>向外传输响应。再通过计数器向IO接口进行查询是否提出了总线占用请求。最后通过BS进行应答。</p><p>​这种方式优先级确定非常灵活。</p><h6 id="独立请求方式："><a href="#独立请求方式：" class="headerlink" title="独立请求方式："></a>独立请求方式：</h6><p>​<img src="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/SingleQuestion.png" class=""></p><p>​在总线控制部件中有排队器进行优先级控制</p><p>​分布式：</p><p>​</p><h4 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h4><p>​目的：解决通信双方协同配合问题</p><h5 id="总线传输周期"><a href="#总线传输周期" class="headerlink" title="总线传输周期"></a>总线传输周期</h5><p>​申请分配阶段：主模块申请，总线仲裁决定</p><p>​寻址阶段：主模块向从模块给出地址和命令</p><p>​传数阶段：主模块和从模块交换数据</p><p>​结束阶段：主模块撤销有关信息</p><h5 id="总线通信的四种方式"><a href="#总线通信的四种方式" class="headerlink" title="总线通信的四种方式"></a>总线通信的四种方式</h5><p>​同步通信：由统一时标控制数据传送</p><p>​异步通信：采用应答方式，没有公告时钟标准</p><p>​半同步通信：同步、异步结合</p><p>​同步： 发送方用系统时钟前沿发信号</p><p>​接收方用系统时钟后延判断、识别</p><p>​异步：允许不同速度的模块和谐工作</p><p>​增加一条“等待”响应信号</p><p>​上述三种通信的共同点：</p><p>​一个总线传输周期（以输入数据为例）</p><ul><li>​主模块发地址、命令   占用总线</li><li>​     从模块准备数据    不占用总线（此时总线空闲，对总线资源是一种浪费）</li><li>​     从模块向主模块发数据  占用总线</li></ul><p>​分离式通信：充分挖掘系统总线每个瞬间的最大效能</p><p>​一个总线传输周期</p><p>​子周期1    主模块申请占用总线，使用完后即放弃总线的使用权</p><p>​子周期2     从模块申请占用总线，将各种信息送至总线上</p><p>​分离式通信特点：</p><ol><li>​各模块有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲</li></ol><p><strong>说明：以上图片与内容均在中国大学MOOC刘教授（刘宏伟）的网课下的总结与摘录</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_运输层</title>
      <link href="/2022/04/15/yun-shu-ceng/"/>
      <url>/2022/04/15/yun-shu-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="5-1运输层概述"><a href="#5-1运输层概述" class="headerlink" title="5.1运输层概述"></a>5.1运输层概述</h3><p>​如何为运行在不同主机上的应用进程提供直接的通信服务使运输层的任务<br>​它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道<br>​因特网的运输层位应用层提供了两种不同的运输协议，即面向<strong>连接的TCP和无连接的UDP</strong></p><hr><h3 id="5-2运输层端口号、复用与分用的概念"><a href="#5-2运输层端口号、复用与分用的概念" class="headerlink" title="5.2运输层端口号、复用与分用的概念"></a>5.2运输层端口号、复用与分用的概念</h3><p>​运行在计算机上的进程使用进程标识符PID来标志<br>​因特网上不同操作系统又使用不同格式的进程标识符</p><h4 id="TCP-x2F-IP体系的运输层使用端口号来区分应用层的不同应用进程"><a href="#TCP-x2F-IP体系的运输层使用端口号来区分应用层的不同应用进程" class="headerlink" title="TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程"></a>TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程</h4><h5 id="端口号使用16比特表示，取值范围0-65535"><a href="#端口号使用16比特表示，取值范围0-65535" class="headerlink" title="端口号使用16比特表示，取值范围0~65535"></a>端口号使用16比特表示，取值范围0~65535</h5><p>​熟知端口号：0<del>1023，IANA把这些端口号派给了TCP&#x2F;IP体系中最重要的一些应用协议<br>​登记端口号：1024</del>49151，为没有熟知端口号的应用程序使用<br>​短暂端口号：49152~65535，留给客户进程选择暂时使用</p><h5 id="端口号只具有本地意义，不同计算机中的相同端口号使没有联系的"><a href="#端口号只具有本地意义，不同计算机中的相同端口号使没有联系的" class="headerlink" title="端口号只具有本地意义，不同计算机中的相同端口号使没有联系的"></a>端口号只具有本地意义，不同计算机中的相同端口号使没有联系的</h5><hr><h3 id="5-3UDP和TCP的对比"><a href="#5-3UDP和TCP的对比" class="headerlink" title="5.3UDP和TCP的对比"></a>5.3UDP和TCP的对比</h3><h4 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h4><p>​无连接的UDP<br>​UDP支持单播、多播以及广播<br>​UDP使面向应用报文<br>​提供不可靠传输，不使用流量控制和拥塞控制<br>​首部开销小，仅8字节</p><h4 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h4><p>​面向连接TCP<br>​TCP仅支持单播<br>​面向字节流<br>​提供可靠传输<br>​首部最少20字节，至多60字节</p><hr><h3 id="5-4TCP的流量控制"><a href="#5-4TCP的流量控制" class="headerlink" title="5.4TCP的流量控制"></a>5.4TCP的流量控制</h3><p>​流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收<br>​利用滑动窗口机制来实现TCP连接上对发送方的流量控制<br>​当发送窗口被调控为0且接收方发送的ACK帧丢失了，发送方抑制等待接收方非零窗口的通知，接收方也一直等待发送方发送的数据，这种状态就称为死锁<br>​发送方可启用持续计时器，当持续计时器超时发送零窗口探测报文，当接收到rwnd!&#x3D;0时就可打破死锁局面</p><hr><h3 id="5-5TCP的拥塞控制"><a href="#5-5TCP的拥塞控制" class="headerlink" title="5.5TCP的拥塞控制"></a>5.5TCP的拥塞控制</h3><p>​若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做拥塞<br>​若出现拥塞而不进行控制，整个网络的吞吐量将随输入符负荷的增大而下降</p><h4 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h4><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>​<strong>cwnd</strong>呈指数增长<br>​慢开始指一开始向网络注入的报文段少，并不是指<strong>拥塞窗口cwnd</strong>增长速度慢<br>​拥塞避免<br>​<strong>cwnd</strong>呈线性加1<br>​当启动重传计时器超时判断网络很可能出现了拥塞<br>​将ssthresh值更新为发生拥塞时swnd值的一半<br>​将cwnd值减少为1，并重新开始执行慢开始算法</p><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>​可以让发送方尽早知道发生了个别报文段的丢失<br>​就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传<br>​要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认<br>​即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认<br>​发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传</p><h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>​就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法<br>​发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半‘开始执行拥塞避免算法<br>​也有的快恢复是把快恢复时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3<br>​发送方维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化<br>​<strong>拥塞窗口cwnd的维护原则</strong>：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要网络出现拥塞，拥塞窗口就减少一些<br>​判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发送超时重传）<br>​发送方将拥塞窗口作为发送窗口swnd。即<strong>swnd &#x3D; cwnd</strong><br>​维护一个慢开始门限ssthresh状态变量<br>​当<strong>cwnd &lt; ssthresh**时，使用慢开始算法<br>​当**cwnd &gt; ssthresh</strong>时，停止使用慢开始算法而改用拥塞避免算法<br>​当<strong>cwnd &#x3D; ssthresh</strong>时，即可使用慢开始算法，也可使用拥塞避免算法</p><hr><h3 id="5-6TCP超时重传时间的选择"><a href="#5-6TCP超时重传时间的选择" class="headerlink" title="5.6TCP超时重传时间的选择"></a>5.6TCP超时重传时间的选择</h3><h4 id="加权平均往返时间RTTs"><a href="#加权平均往返时间RTTs" class="headerlink" title="加权平均往返时间RTTs"></a>加权平均往返时间RTTs</h4><p>$$<br>RTTs1 &#x3D; RTT1\\<br>新的RTTs &#x3D; (1 -α) * 旧的RTTs + α * 新的RTTs样本\\<br>0 &lt;&#x3D; α &lt; 1\\<br>已成为建议标准的RFC6298推荐的α值为0.125<br>$$</p><h4 id="RTT偏差的加权平均RTTD"><a href="#RTT偏差的加权平均RTTD" class="headerlink" title="RTT偏差的加权平均RTTD"></a>RTT偏差的加权平均RTTD</h4><p>$$<br>RTTD_1 &#x3D; RTT\frac{1}{2}\\<br>新的RTTD &#x3D; (1-β) × 旧的RTTD + β * |RTTs - 新的RTT样本 |\\</p><p>0 &lt;&#x3D; β &lt; 1\\<br>已成为建议标准的RFC6298推荐的β值为0.25<br>$$</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>$$<br>RTO &#x3D; RTTs +4 × RTTD<br>$$</p><h4 id="出现超时重传时，新RTO-x3D-2倍的旧RTO"><a href="#出现超时重传时，新RTO-x3D-2倍的旧RTO" class="headerlink" title="出现超时重传时，新RTO&#x3D;2倍的旧RTO"></a>出现超时重传时，新RTO&#x3D;2倍的旧RTO</h4><hr><h3 id="5-7TCP可靠传输的实现"><a href="#5-7TCP可靠传输的实现" class="headerlink" title="5.7TCP可靠传输的实现"></a>5.7TCP可靠传输的实现</h3><h4 id="TCP基于以字节为单位的滑动窗口来实现可靠传输"><a href="#TCP基于以字节为单位的滑动窗口来实现可靠传输" class="headerlink" title="TCP基于以字节为单位的滑动窗口来实现可靠传输"></a>TCP基于以字节为单位的滑动窗口来实现可靠传输</h4><h4 id="发送方的发送窗口并不总是和接收放的窗口一样大"><a href="#发送方的发送窗口并不总是和接收放的窗口一样大" class="headerlink" title="发送方的发送窗口并不总是和接收放的窗口一样大"></a>发送方的发送窗口并不总是和接收放的窗口一样大</h4><p>​网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的<br>​发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</p><h4 id="对于不按序到达的数据应如何处理，TCP并无明确规定"><a href="#对于不按序到达的数据应如何处理，TCP并无明确规定" class="headerlink" title="对于不按序到达的数据应如何处理，TCP并无明确规定"></a>对于不按序到达的数据应如何处理，TCP并无明确规定</h4><p>​TCP通常对不按序到达的数据先临时存放再接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</p><h4 id="TCP要求接收方必须有累计确认和捎带确认机制"><a href="#TCP要求接收方必须有累计确认和捎带确认机制" class="headerlink" title="TCP要求接收方必须有累计确认和捎带确认机制"></a>TCP要求接收方必须有累计确认和捎带确认机制</h4><p>​接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传</p><h4 id="TCP的通信是全双工通信"><a href="#TCP的通信是全双工通信" class="headerlink" title="TCP的通信是全双工通信"></a>TCP的通信是全双工通信</h4><hr><h3 id="5-8TCP的运输连接管理"><a href="#5-8TCP的运输连接管理" class="headerlink" title="5.8TCP的运输连接管理"></a>5.8TCP的运输连接管理</h3><h4 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h4><h5 id="TCP是面向连接的协议，它基于运输连接来传输TCP报文段"><a href="#TCP是面向连接的协议，它基于运输连接来传输TCP报文段" class="headerlink" title="TCP是面向连接的协议，它基于运输连接来传输TCP报文段"></a>TCP是面向连接的协议，它基于运输连接来传输TCP报文段</h5><h5 id="TCP运输连接有以下三个阶段"><a href="#TCP运输连接有以下三个阶段" class="headerlink" title="TCP运输连接有以下三个阶段"></a>TCP运输连接有以下三个阶段</h5><p>​建立TCP连接<br>​数据传送<br>​释放TCP连接</p><h5 id="TCP的连接建立要解决三个问题"><a href="#TCP的连接建立要解决三个问题" class="headerlink" title="TCP的连接建立要解决三个问题"></a>TCP的连接建立要解决三个问题</h5><p>​使TCP双方能够确知对方的存在<br>​使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）<br>​使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</p><h5 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h5><h6 id="TCP客户端发送同步位SYN-x3D-1-序号字段seq-x3D-x"><a href="#TCP客户端发送同步位SYN-x3D-1-序号字段seq-x3D-x" class="headerlink" title="TCP客户端发送同步位SYN&#x3D;1 序号字段seq &#x3D; x"></a>TCP客户端发送同步位SYN&#x3D;1 序号字段seq &#x3D; x</h6><p>​SYN&#x3D;1的数据段不能携带数据</p><h6 id="TCP服务器发送SYN-x3D-1和确认位ACK-x3D-1-序号字段seq-x3D-y-确认号字段ack-x3D-x-1"><a href="#TCP服务器发送SYN-x3D-1和确认位ACK-x3D-1-序号字段seq-x3D-y-确认号字段ack-x3D-x-1" class="headerlink" title="TCP服务器发送SYN&#x3D;1和确认位ACK&#x3D;1 序号字段seq &#x3D; y 确认号字段ack &#x3D; x +1"></a>TCP服务器发送SYN&#x3D;1和确认位ACK&#x3D;1 序号字段seq &#x3D; y 确认号字段ack &#x3D; x +1</h6><h6 id="TCP客户端发送确认位ACK-x3D-1-序号字段seq-x3D-x-1-ack-x3D-y-1"><a href="#TCP客户端发送确认位ACK-x3D-1-序号字段seq-x3D-x-1-ack-x3D-y-1" class="headerlink" title="TCP客户端发送确认位ACK&#x3D;1 序号字段seq &#x3D; x +1 ack &#x3D; y +1"></a>TCP客户端发送确认位ACK&#x3D;1 序号字段seq &#x3D; x +1 ack &#x3D; y +1</h6><h6 id="普通的确认报文段如果不懈怠数据，则不消耗序号"><a href="#普通的确认报文段如果不懈怠数据，则不消耗序号" class="headerlink" title="普通的确认报文段如果不懈怠数据，则不消耗序号"></a>普通的确认报文段如果不懈怠数据，则不消耗序号</h6><h5 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h5><h6 id="客户TCP向服务器TCP发送进程终止报文段，终止位FIN-x3D-1-ACK-x3D-1-seq-x3D-u-等于TCP客户进程之前已传送过的数据最后一个字节的序号-1-，ack-x3D-v-等于TCP客户进程之前已收到过的数据最后一个字节的序号-1"><a href="#客户TCP向服务器TCP发送进程终止报文段，终止位FIN-x3D-1-ACK-x3D-1-seq-x3D-u-等于TCP客户进程之前已传送过的数据最后一个字节的序号-1-，ack-x3D-v-等于TCP客户进程之前已收到过的数据最后一个字节的序号-1" class="headerlink" title="客户TCP向服务器TCP发送进程终止报文段，终止位FIN &#x3D; 1 , ACK &#x3D; 1 , seq &#x3D; u(等于TCP客户进程之前已传送过的数据最后一个字节的序号+1)，ack &#x3D; v(等于TCP客户进程之前已收到过的数据最后一个字节的序号+1)"></a>客户TCP向服务器TCP发送进程终止报文段，终止位FIN &#x3D; 1 , ACK &#x3D; 1 , seq &#x3D; u(等于TCP客户进程之前已传送过的数据最后一个字节的序号+1)，ack &#x3D; v(等于TCP客户进程之前已收到过的数据最后一个字节的序号+1)</h6><h6 id="服务器TCP向客户TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-v-ack-x3D-u-1"><a href="#服务器TCP向客户TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-v-ack-x3D-u-1" class="headerlink" title="服务器TCP向客户TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; v ,ack &#x3D; u+1"></a>服务器TCP向客户TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; v ,ack &#x3D; u+1</h6><h6 id="这时服务器TCP还可以向TCP客户发送报文段"><a href="#这时服务器TCP还可以向TCP客户发送报文段" class="headerlink" title="这时服务器TCP还可以向TCP客户发送报文段"></a>这时服务器TCP还可以向TCP客户发送报文段</h6><h6 id="服务器TCP向客户TCP发送TCP连续释放，该报文段FIN-x3D-1-ACK-x3D-1-seq-x3D-w-ack-x3D-u-1"><a href="#服务器TCP向客户TCP发送TCP连续释放，该报文段FIN-x3D-1-ACK-x3D-1-seq-x3D-w-ack-x3D-u-1" class="headerlink" title="服务器TCP向客户TCP发送TCP连续释放，该报文段FIN &#x3D; 1,ACK &#x3D; 1 , seq &#x3D; w ,ack &#x3D; u+1"></a>服务器TCP向客户TCP发送TCP连续释放，该报文段FIN &#x3D; 1,ACK &#x3D; 1 , seq &#x3D; w ,ack &#x3D; u+1</h6><h6 id="客户TCP向服务器TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-u-1-ack-x3D-w-1"><a href="#客户TCP向服务器TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-u-1-ack-x3D-w-1" class="headerlink" title="客户TCP向服务器TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; u+1 ,ack &#x3D; w+1"></a>客户TCP向服务器TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; u+1 ,ack &#x3D; w+1</h6><h6 id="TCP客户端进入时间等待要等待2MSL后才进入关闭"><a href="#TCP客户端进入时间等待要等待2MSL后才进入关闭" class="headerlink" title="TCP客户端进入时间等待要等待2MSL后才进入关闭"></a>TCP客户端进入时间等待要等待2MSL后才进入关闭</h6><p>​MSL使最大报文段寿命，RFC793建议位2分钟</p><h6 id="TCP服务器进程每收到TCP客户进程的数据，-就重新设置并启动保活计时器（2小时定时）"><a href="#TCP服务器进程每收到TCP客户进程的数据，-就重新设置并启动保活计时器（2小时定时）" class="headerlink" title="TCP服务器进程每收到TCP客户进程的数据， 就重新设置并启动保活计时器（2小时定时）"></a>TCP服务器进程每收到TCP客户进程的数据， 就重新设置并启动保活计时器（2小时定时）</h6><h6 id="若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接"><a href="#若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接" class="headerlink" title="若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接"></a>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接</h6><hr><h3 id="5-9TCP报文段首部格式"><a href="#5-9TCP报文段首部格式" class="headerlink" title="5.9TCP报文段首部格式"></a>5.9TCP报文段首部格式</h3><p>​为了实现可靠传输，TCP采用了面向字节流的方式</p><h4 id="固定首部（20字节）"><a href="#固定首部（20字节）" class="headerlink" title="固定首部（20字节）"></a>固定首部（20字节）</h4><h5 id="源端口（16字节）"><a href="#源端口（16字节）" class="headerlink" title="源端口（16字节）"></a>源端口（16字节）</h5><p>​用来标识发送该TCP报文段的应用进程</p><h5 id="目的端口（16字节）"><a href="#目的端口（16字节）" class="headerlink" title="目的端口（16字节）"></a>目的端口（16字节）</h5><p>​标识接收该TCP报文段的应用进程</p><h5 id="序号（32比特）"><a href="#序号（32比特）" class="headerlink" title="序号（32比特）"></a>序号（32比特）</h5><p>​指出本TCP报文段数据载荷的第一个字节的序号</p><h5 id="确认号（32比特）"><a href="#确认号（32比特）" class="headerlink" title="确认号（32比特）"></a>确认号（32比特）</h5><p>​指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认</p><h5 id="数据偏移（4比特，并以4字节为单位）"><a href="#数据偏移（4比特，并以4字节为单位）" class="headerlink" title="数据偏移（4比特，并以4字节为单位）"></a>数据偏移（4比特，并以4字节为单位）</h5><p>​指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远，这个字段实际是指出了TCP报文段的首部长度</p><h5 id="保留（6比特）保留今后使用，目前应置为0"><a href="#保留（6比特）保留今后使用，目前应置为0" class="headerlink" title="保留（6比特）保留今后使用，目前应置为0"></a>保留（6比特）保留今后使用，目前应置为0</h5><h5 id="ACK：取值位1时确认号字段才有效，0为无效"><a href="#ACK：取值位1时确认号字段才有效，0为无效" class="headerlink" title="ACK：取值位1时确认号字段才有效，0为无效"></a>ACK：取值位1时确认号字段才有效，0为无效</h5><h5 id="窗口（16比特，以字节为单位）"><a href="#窗口（16比特，以字节为单位）" class="headerlink" title="窗口（16比特，以字节为单位）"></a>窗口（16比特，以字节为单位）</h5><p>​指出发送本报文段的一方的接收窗口</p><h5 id="校验和（16比特）"><a href="#校验和（16比特）" class="headerlink" title="校验和（16比特）"></a>校验和（16比特）</h5><p>​检查范围包括TCP报文段的首部和数据载荷两部分</p><h5 id="同步标志位SYN：在TCP连接建立时同步序号"><a href="#同步标志位SYN：在TCP连接建立时同步序号" class="headerlink" title="同步标志位SYN：在TCP连接建立时同步序号"></a>同步标志位SYN：在TCP连接建立时同步序号</h5><h5 id="终止标志位FIN：用来释放TCP连接"><a href="#终止标志位FIN：用来释放TCP连接" class="headerlink" title="终止标志位FIN：用来释放TCP连接"></a>终止标志位FIN：用来释放TCP连接</h5><h5 id="复位标志位RST-用来复位TCP连接，当RST-x3D-1时，表明TCP连接出现了异常，必须释放连接"><a href="#复位标志位RST-用来复位TCP连接，当RST-x3D-1时，表明TCP连接出现了异常，必须释放连接" class="headerlink" title="复位标志位RST:用来复位TCP连接，当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接"></a>复位标志位RST:用来复位TCP连接，当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接</h5><h5 id="推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付"><a href="#推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付" class="headerlink" title="推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付"></a>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付</h5><h5 id="进击标志位URG：取值为1时紧急指针字段有效，0为无效"><a href="#进击标志位URG：取值为1时紧急指针字段有效，0为无效" class="headerlink" title="进击标志位URG：取值为1时紧急指针字段有效，0为无效"></a>进击标志位URG：取值为1时紧急指针字段有效，0为无效</h5><h5 id="紧急指针（16比特，以字节为单位）"><a href="#紧急指针（16比特，以字节为单位）" class="headerlink" title="紧急指针（16比特，以字节为单位）"></a>紧急指针（16比特，以字节为单位）</h5><h4 id="扩展首部（最大40字节）"><a href="#扩展首部（最大40字节）" class="headerlink" title="扩展首部（最大40字节）"></a>扩展首部（最大40字节）</h4><h5 id="选项（长度可变）"><a href="#选项（长度可变）" class="headerlink" title="选项（长度可变）"></a>选项（长度可变）</h5><p>​最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度</p><h5 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h5><p>​用来确保报文段首部能被4整除</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 运输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueRouter</title>
      <link href="/2022/04/14/vueroute/"/>
      <url>/2022/04/14/vueroute/</url>
      
        <content type="html"><![CDATA[<h4 id="路由的基本概念"><a href="#路由的基本概念" class="headerlink" title="路由的基本概念"></a>路由的基本概念</h4><p><strong>2022年2月7日以后，<code>vue-router</code>的默认版本，为Vue3专属的4版本</strong></p><p><code>Vue</code>的一个插件库，专门来实现SPA应用</p><h5 id="路由就是一组key-value的对应关系"><a href="#路由就是一组key-value的对应关系" class="headerlink" title="路由就是一组key-value的对应关系"></a>路由就是一组key-value的对应关系</h5><p><code>key</code>为路径，<code>value</code>肯使<code>function</code>或<code>component</code></p><p><code>route</code>规则: <code>/example</code> &#x3D;&gt; 例子组件</p><h4 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h4><p>先创建两个组件</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--组件1--&gt;&lt;template&gt;&lt;h2&gt;        我是About内容    &lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;      name:&#39;About&#39;  &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--组件2--&gt;&lt;template&gt;&lt;h2&gt;        我是Home内容    &lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;      name:&#39;Home&#39;  &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//入口文件main.js</span><span class="token comment">//引入Vue</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment">//引入App</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token comment">//引入VueRouter</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入路由器</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token literal-property property">router</span><span class="token operator">:</span>router<span class="token punctuation">,</span>  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>新建路由器文件</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'../components/Home'</span><span class="token comment">//创建一个路由器</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>Home        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>在<code>App</code>入口文件中新建样式引用组件</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!--原始html中用a标签实现页面的跳转--&gt;&lt;!-- &lt;a href&#x3D;&quot;.&#x2F;about.html&quot;&gt;About&lt;&#x2F;a&gt; --&gt;&lt;!-- &lt;a href&#x3D;&quot;.&#x2F;home.html&quot;&gt;Home&lt;&#x2F;a&gt; --&gt;&lt;!--原始html中用a标签实现页面的跳转 active-class是激活时候的样式--&gt;&lt;router-link to&#x3D;&quot;&#x2F;about&quot; active-class&#x3D;&quot;&quot;&gt;About&lt;&#x2F;router-link&gt;&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;Home&lt;&#x2F;router-link&gt;&lt;!--router-view--&gt;&lt;router-view&gt;&lt;&#x2F;router-view&gt;&lt;&#x2F;template&gt;</code></pre><p>路由的基本功能就能实现了。</p><h4 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h4><p>以上方页面为基准，修改<code>index.js</code>路由文件和新建两个子级路由。</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--Message页面--&gt;&lt;template&gt;&lt;div&gt;        &lt;ul&gt;            &lt;li&gt;消息&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        name:&#39;Message&#39;    &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--News页面--&gt;&lt;template&gt;&lt;div&gt;        &lt;ul&gt;            &lt;li&gt;新闻&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        name:&#39;News&#39;    &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'../components/Home'</span><span class="token keyword">import</span> News <span class="token keyword">from</span> <span class="token string">'../components/News'</span><span class="token keyword">import</span> Message <span class="token keyword">from</span> <span class="token string">'../components/Message'</span><span class="token comment">//创建一个路由器</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>Home<span class="token punctuation">,</span>            <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span> <span class="token comment">//子路由</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'news'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>News                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>Message                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>再将需要调用的home页面中的<code>a</code>标签进行修改为<code>router-link</code>。并用<code>router-view</code>进行子路由的显示。</p><p><strong><code>router-link</code>中的<code>to</code>路径要为“&#x2F;一级路由&#x2F;二级路由&#x2F;….”</strong></p><h4 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h4><h5 id="以query进行传参"><a href="#以query进行传参" class="headerlink" title="以query进行传参"></a>以<code>query</code>进行传参</h5><p>把上方的写死的数据存在<code>data</code>中来进行传参。</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--Message页面--&gt;&lt;template&gt;&lt;div&gt;        &lt;ul&gt;            &lt;li v-for&#x3D;&quot;m in massageList&quot; :key&#x3D;&quot;m.id&quot;&gt;               &lt;!--传参以&#39;?&#39;进行分割,to的字符串写法--&gt;               &lt;router-link :to&#x3D;&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;&#123;m.id&#125;&amp;title&#x3D;&#123;m.title&#125;&#96;&gt;&#123;&#123;m.title&#125;&#125;&lt;&#x2F;router-link&gt;                &lt;!--传参以&#39;?&#39;进行分割,to的对象写法--&gt;               &lt;router-link :to&#x3D;&quot;&#123;                  path:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,                  query:&#123;                    id:m.id,                    title:m.title                  &#125;                &#125;&quot;&gt;                   &#123;&#123;m.title&#125;&#125;       &lt;&#x2F;router-link&gt;    &lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;        &lt;!--展示detail页面--&gt;        &lt;router-view&gt;&lt;&#x2F;router-view&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        name:&#39;Message&#39;,        data () &#123;            return &#123;                massageList:[                    &#123;id:&#39;001&#39;,title:&#39;消息1&#39;&#125;,                    &#123;id:&#39;002&#39;,title:&#39;消息2&#39;&#125;,                    &#123;id:&#39;003&#39;,title:&#39;消息3&#39;&#125;                ]            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--用来接收传递过来数据的Detail页面--&gt;&lt;template&gt;&lt;ul&gt;        &lt;li&gt;消息编号：&#123;&#123;$route.query.id&#125;&#125;&lt;&#x2F;li&gt;        &lt;li&gt;消息标题：&#123;&#123;$route.query.id&#125;&#125;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default&#123;      name:&#39;Detail&#39;  &#125;&lt;&#x2F;script&gt;</code></pre><p>再对路由配置信息页面进行修改</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'../components/Home'</span><span class="token keyword">import</span> News <span class="token keyword">from</span> <span class="token string">'../components/News'</span><span class="token keyword">import</span> Message <span class="token keyword">from</span> <span class="token string">'../components/Message'</span><span class="token keyword">import</span> Detail <span class="token keyword">from</span> <span class="token string">'../components/Detail'</span><span class="token comment">//创建一个路由器</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>Home<span class="token punctuation">,</span>            <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span> <span class="token comment">//子路由</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'news'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>News                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>Message<span class="token punctuation">,</span>                    <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span>                        <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'detail'</span><span class="token punctuation">,</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>Detail                <span class="token punctuation">&#125;</span>                    <span class="token punctuation">]</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h5 id="以params进行传参"><a href="#以params进行传参" class="headerlink" title="以params进行传参"></a>以<code>params</code>进行传参</h5><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--传参格式 &#39;路由&#x2F;参数&#x2F;参数&#x2F;...&#39;--&gt;&lt;router-link :to&#x3D;&quot;&#x2F;detail&#x2F;66&#x2F;消息&quot;&gt;&lt;&#x2F;router-link&gt;</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//路由的index.js</span><span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'detail/:id/:title'</span></code></pre><p>在页面使用对象方法传参配置时候不能使用<code>path</code>作为路径跳转必须舒勇<code>name</code>形式。剩下部分与<code>query</code>基本相同。</p><h4 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的<code>props</code>配置</h4><p>传参的时候以<code>query</code>方式进行传参</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//路由的index.js</span><span class="token literal-property property">component</span><span class="token operator">:</span>Detail<span class="token punctuation">,</span><span class="token comment">//props第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件</span><span class="token comment">//用的比较少，传递的为死数据</span><span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">b</span><span class="token operator">:</span><span class="token string">'helloWorld'</span><span class="token punctuation">&#125;</span><span class="token comment">//props第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件</span><span class="token literal-property property">props</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token comment">//props第三种写法，值为函数</span><span class="token function">props</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span><span class="token literal-property property">query</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>id<span class="token punctuation">,</span>title<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//直接用解构来获取$router中query参数</span>    <span class="token keyword">return</span><span class="token punctuation">&#123;</span><span class="token literal-property property">id</span><span class="token operator">:</span><span class="token string">'id'</span><span class="token punctuation">,</span><span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'title'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在<code>Detail</code>组件中接收</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;ul&gt;        &lt;!--&lt;li&gt;&#123;&#123;a&#125;&#125;&lt;&#x2F;li&gt;--&gt;        &lt;!--&lt;li&gt;&#123;&#123;b&#125;&#125;&lt;&#x2F;li&gt;--&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default&#123;        name:&#39;Detail&#39;,        &#x2F;&#x2F;id和title由上方Message组件传递        &#x2F;&#x2F;第一种方式接收        props:[&#39;a&#39;,&#39;b&#39;],        &#x2F;&#x2F;第二种方式接收        computed:&#123;            id()&#123;                return this.$route.query.id            &#125;,            title()&#123;                return this.$route.query.title            &#125;        &#125;        &#x2F;&#x2F;第三种方式接收        props:[&#39;id&#39;,&#39;title&#39;]        ...&#x2F;&#x2F;方便演示就不显示其他数据了    &#125;&lt;&#x2F;script&gt;</code></pre><h4 id="浏览器历史记录"><a href="#浏览器历史记录" class="headerlink" title="浏览器历史记录"></a>浏览器历史记录</h4><p>​浏览器的结构为栈形式。</p><p>​浏览器默认保存历史记录的方式为<code>push</code>，即压栈。</p><p>​<code>router-link</code>默认开启的为<code>push</code>模式，可以在<code>router-link</code>中添加<code>replace</code>改变浏览器的保存历史记录模式。（只对使用的连接起作用）</p><h4 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h4><p><code>routuer-link</code>在页面中默认转换为<code>a</code>标签，要想让按钮等能触发点击的事件进行页面跳转，就得使用编程式路由导航。</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--前面写的Message页面，其他就不再重复写了--&gt;&lt;template&gt;&lt;button @click&#x3D;&quot;pushShow&quot;&gt;        跳转到Home页面    &lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;        name:&#39;Message&#39;,        methods: &#123;            pushShow()&#123;                &#x2F;&#x2F;push为默认的方式，可更换为replace                 this.$router.push(&#123;                    path:&#39;&#x2F;home&#39;,                    query:&#123;                        id:this.$store.query.id,                        title:this.$store.query.title                    &#125;                &#125;)            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h4 id="两个新生命钩子"><a href="#两个新生命钩子" class="headerlink" title="两个新生命钩子"></a>两个新生命钩子</h4><p>当路由被缓存并在挂载前设定了<code>setInterval</code>等方法。因为组件被路由缓存了并不会触发销毁流程但页面又没有进行显示，此时会浪费浏览器资源就需要用新的生命钩子来对方法进行清除。</p><h5 id="activated-激活"><a href="#activated-激活" class="headerlink" title="activated(激活)"></a>activated(激活)</h5><p>当路由被激活时该钩子被调用</p><h5 id="deactivated-失活"><a href="#deactivated-失活" class="headerlink" title="deactivated(失活)"></a>deactivated(失活)</h5><p>当路由失活时候该钩子被调用</p><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>路由守卫用来设置权限</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token operator">...</span><span class="token comment">//创建一个路由器</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About<span class="token punctuation">,</span>            <span class="token comment">//用meta来判断是否需要权限校验，meta可以创建路由独有的信息</span>            <span class="token literal-property property">meta</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token literal-property property">isAuth</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token comment">//独享路由守卫  与全局路由守卫功能相同</span>            <span class="token function">beforeEnter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">...</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//全局前置路由守卫  初始化的时候被调用、每次路由切换之前调用</span>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//to表示要跳转到的路由页面，from表示从哪个路由开始跳转的</span>    <span class="token comment">//next表示可以放行，可以跳转路由页面</span>    <span class="token comment">//可以通过逻辑判断来让用户是否可以跳转到目标页面</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>isAuth<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//全局后置路由守卫  初始化的时候被调用、每次路由切换之后被调用</span>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span><span class="token keyword">from</span></span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//to表示要跳转到的路由页面，from表示从哪个路由开始跳转的</span>    <span class="token comment">//next表示可以放行，可以跳转路由页面</span>    <span class="token comment">//能进入后置守卫表示能成功进入页面</span>    <span class="token comment">//可以实现点击后页面标题的切换等功能</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> router</code></pre><p>组件内路由守卫</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;...&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        ...,        &#x2F;&#x2F;通过路由规则，进入该组件时被调用        beforeRouteEnter(to,from,next)&#123;            &#x2F;&#x2F;写的逻辑判断由组件独有            next()        &#125;,        &#x2F;&#x2F;通过路由规则，离开该组件时被调用        beforeRouteLeave(to,from,next)&#123;            next()        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h4 id="history模式与hash模式"><a href="#history模式与hash模式" class="headerlink" title="history模式与hash模式"></a><code>history</code>模式与<code>hash</code>模式</h4><p>使用路由时地址栏会新增<code>#</code>，称为<code>hash</code>，不会随着http请求发给服务器。默认开启的<code>hash</code>模式。</p><p>改变路由模式：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在路由配置中修改</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token comment">//改为history模式，history没有#显示</span>    <span class="token literal-property property">mode</span><span class="token operator">:</span><span class="token string">'history'</span><span class="token punctuation">,</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p><code>history</code>模式的兼容比<code>hash</code>模式差</p><h4 id="路由的几个注意事项"><a href="#路由的几个注意事项" class="headerlink" title="路由的几个注意事项"></a>路由的几个注意事项</h4><p>1.未被路由调用的页面会被销毁而不是隐藏</p><p>2.使用路由的页面会增加路由规则，<code>$route</code>和<code>$router</code>。<code>$route</code>存放自己的路由信息，每个页面均不相同，<code>$router</code>相同</p><p>3.路由组件通常存放在<code>pages</code>文件夹</p><p>4.可以通过<code>keep-alive</code>对路由组件进行缓存不会进行销毁，<code>keep-alive</code>放在一级路由中</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!--include来记录要缓存的组件(里面填组件名)，其他的则不缓存。不写则都缓存--&gt;&lt;!--缓存多个写法： :include&#x3D;&quot;[&#39;第一个组件名&#39;,&#39;第二个组件名&#39;]&quot;--&gt;&lt;keep-alive include&#x3D;&quot;&quot;&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;    &lt;&#x2F;keep-alive&gt;&lt;&#x2F;template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> VueRouter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-计算机概论</title>
      <link href="/2022/04/14/ji-suan-ji-gai-lun/"/>
      <url>/2022/04/14/ji-suan-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机的基本构成"><a href="#计算机的基本构成" class="headerlink" title="计算机的基本构成"></a>计算机的基本构成</h3><h5 id="计算机的功能部件"><a href="#计算机的功能部件" class="headerlink" title="计算机的功能部件"></a>计算机的功能部件</h5><ol><li>输入设备：将信息转换成机器能识别的形式。</li><li>存储器：存放数据和程序。</li><li>运算器：进行算数运算和逻辑运算。</li><li>输出设备：将结果转换成人们熟悉的形式。</li><li>控制器：来指挥程序运行。</li></ol><h4 id="冯诺伊曼基本思想"><a href="#冯诺伊曼基本思想" class="headerlink" title="冯诺伊曼基本思想"></a>冯诺伊曼基本思想</h4><p>冯诺依曼机的特点：</p><ol><li>采用“存储程序的”工作方式。</li><li>计算机硬件系统由运算器、存储器、控制器、输入和输出设备组成。</li><li>指令和数据以同等地位存储在存储器中，计算机能区别出它们。</li><li>指令和数据均用二进制代码表示。</li></ol><p>冯诺伊曼机的基本工作方式是以<strong>控制流驱动方式</strong>，以运算器为中心，且是单处理器。</p><p><strong>“存储程序”的思想是</strong>：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无需操作人员的干预。</p><p><img src="https://img-blog.csdnimg.cn/7e30ce64a1494b56b7bac12a626c9ceb.png" alt="1-1"></p><p>图1-1就是标准的冯诺依曼机，实线表示数据线，虚线表示控制线和反馈线。</p><p>冯诺依曼计算机是以运算器为中心，任何计算都得经过运算器，会导致效率过低，从而有了现代计算机的结构，如图1-2。</p><p><img src="https://img-blog.csdnimg.cn/8f1ceee94a964e74a75fe42d6a7a24e8.png" alt="1-2"></p><p>现代计算机以存储器为中心，当运算完成可以直接从存储器中取址来完成所想要的操作，而现在所谓的CPU就是运算器和控制器的集成部件。</p><h3 id="计算机各个部件的工作原理"><a href="#计算机各个部件的工作原理" class="headerlink" title="计算机各个部件的工作原理"></a>计算机各个部件的工作原理</h3><h4 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h4><p><img src="https://img-blog.csdnimg.cn/5bcf754b23644985933bb8b312bbc995.png" alt="1-3"></p><p>主存储器以存储单元的地址进行存取。主存储器的最基本组成如图1-3所示，地址寄存器（MAR）存放访存地址。数据寄存器（MDR）用于暂存要从存储器中读或写的数据信息。</p><p>主存储器中存储体由多个存储单元（每个<strong>存储单元</strong>存放一串二进制代码）组成。存储单元存储的一串二进制代码称为<strong>存储字</strong>，而存储字的位数称为<strong>存储字长</strong>，存储字长可以是1B(8bit)或是1B的偶数倍。</p><p><strong>MAR位数反映存储单元的个数，MDR的位数是要等于存储子长的。</strong></p><p>例：</p><p>MAR&#x3D;4位 -&gt; 总共有$2^4$个存储单元</p><p>MDR&#x3D;16位 -&gt; 每个存储单元可存放16bit。</p><p><strong>注：1字节（byte）&#x3D;1B &#x3D; 8bit，1字（word）&#x3D; 16bit</strong></p><h4 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h4><p><img src="https://img-blog.csdnimg.cn/56b0a84f6958407ab386133b90c42c7c.png" alt="1-4"></p><p>运算器主要用于算计运算（如：加减乘除）、逻辑运算（如：与或非）。</p><p>ACC（Accumulator）：累加器，用于存放操作数，或运算结果。</p><p>MQ（Multiple-Quotient Register）： 乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。</p><p>X： 通用的操作数寄存器，用于存放操作数。</p><p>ALU（Arithmetic and Logic Unit）：算数逻辑单元，实现算数运算、逻辑运算。</p><h4 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h4><p><img src="https://img-blog.csdnimg.cn/16d3b63cbcfe44fd9b7a7e75561df859.png" alt="1-5"></p><p>CU（Control Unit）：控制单元，分析指令，给出控制信号。</p><p>IR（Instruction Register）：指令寄存器，存放当前执行的指令。</p><p>PC（Program Counter）：程序计数器，存放下一条指令地址，有自动加1功能。</p><p>完成一条指令的过程：通过PC进行取指令，用IR分析指令，最后用CU执行指令。</p><h4 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h4><p>假设有这么一段代码</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    y<span class="token operator">-</span>a<span class="token operator">*</span>b<span class="token operator">+</span>c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>编译后装入主存：</p><p><img src="https://img-blog.csdnimg.cn/6fd2f29ef2c24a4da481c33b5b61a52a.png" alt="1-6"></p><p>a&#x3D;2的2b(16bit)二进制形式<code>0000000000000010</code>,其他同理。</p><p>若计算机要执行上方代码，会进行以下工作：</p><ol><li><p>此时(PC)-&gt;0，PC指向0地址，PC会通过<strong>地址总线</strong>来获取MAR种主存地址为0的指令，控制器会通过<strong>控制总线</strong>来告诉主存储器要进行读操作。</p></li><li><p>MAR会根据主存地址信息去存储体种找到对应指令，然后存储体会将相应二进制放到MDR中，此时<strong>M(MAR)-&gt;MDR，(MDR)&#x3D; ，(MAR)&#x3D;0</strong>（M(MAR)表示将地址寄存器中的内容通过存储体放到数据寄存器中）。</p></li><li><p>MDR中已经存放了主存地址0的指令信息，此时需要再通过一条数据总线来将信息存放到IR内，(MDR)-&gt;IR，导致<strong>（IR）&#x3D; 000001 0000000101</strong></p></li><li><p>然后前6个比特，IR再送到CU控制单元中，CU会分析当前操作码的信息，此时读取到的使取数指令，会控制IR来读取a，导致(MAR)&#x3D;5。</p></li><li><p>MAR会通过存储体去MDR中读取a，导致(MDR)&#x3D;000000000000010&#x3D;2。</p></li><li><p>然后MDR中的数据会传送到ACC中，然后就完成了“取数”指令。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/a7108f35b7204c67866b9434dadfdfff.png" alt="1-7"></p><p>因为PC有自动+1功能，就会自动进行下一条功能。</p><h4 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h4><p>计算机软件中三个级别的语言，分别为：</p><ol><li><p>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。</p></li><li><p>汇编语言。用英文单词或缩写来代替二进制的指令代码。</p></li><li><p>高级语言。如C、C++、Java等，通常高级语言需要通过编译程序编译成汇编语言，然后经过汇编得到机器语言程序，或直接由高级语言翻译成机器语言程序。</p><p>翻译程序有以下三类：</p><ol><li>汇编器：通汇编语言再翻译成机器语言。</li><li>解释器：将源程序<strong>逐句翻译</strong>成机器指令并<strong>立即执行</strong>。</li><li>编译器：运行后<strong>一次性全部翻译</strong>成机器语言程序。</li></ol></li></ol><p>由于软件和硬件逻辑功能具有等价性（有些功能既可以使用软件实现，也可以使用硬件实现），就产生了</p><h4 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h4><p>计算机通过多级层次结构来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。</p><p><img src="https://img-blog.csdnimg.cn/cd5fa81a80bd42faa36e60fd3b5149c2.png" alt="1-8"></p><p>计算机层次结构暂无统一的标准，但可以分层图1-8所示的层次结构。</p><p>第1级微程序机器层，它由机器硬件直接执行微指令。</p><p>第2级传统机器语言层，由01代码组成，由微程序解释机器指令系统。</p><p>第3级系统操作层，由操作系统程序实现，通过操作系统来对硬件进行操作。</p><p>第4级汇编语言层，这一层由汇编语言支持和执行，为用户提供提供一种符号化的语言，借此可编写汇编语言源程序。</p><p>第5级高级语言层，它是面向用户的，该层由各种高级语言编译程序支持和执行。</p><p><strong>指令集体系结构（ISA）：</strong>软件和硬件之间的界面，设计计算机的系统的ISA，就是定义一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么。</p><h3 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h3><h4 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h4><p>字长是指计算机进行一次整数运算所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。计算机字长通常选定为字节（8位）的整数倍。</p><ul><li><strong>数据字长</strong>：是数据总线一次能并行传送信息的位数。</li><li><strong>存储字长</strong>：一个存储单元中的<strong>二进制代码的位数</strong>，存储字长等于MDR的位数。</li><li><strong>机器字长</strong>：即计算机的位数，计算机一次能处理的二进制的长度。</li></ul><h4 id="数据通路带宽"><a href="#数据通路带宽" class="headerlink" title="数据通路带宽"></a>数据通路带宽</h4><p>数据通路带宽是指<strong>数据总线一次所能并行传送信息的位数</strong>。</p><h4 id="主存容量"><a href="#主存容量" class="headerlink" title="主存容量"></a>主存容量</h4><p>主存容量是指<strong>主存储器所能存储信息的最大容量</strong>，通常以字节来衡量。</p><p>由于主存储器中MAR（存储地址寄存器）位数反映<strong>存储单元的个数</strong>（最多支持多少个），MDR（存储数据寄存器）位数等于<strong>存储字长</strong>等于<strong>每个存储单元的大小</strong>。</p><p>**总容量&#x3D;存储单元个数$\times$存储字长 **（单位为bit）。</p><h4 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h4><ol><li><p>吞吐量和响应时间。</p><ul><li>吞吐量：指系统再单位时间内处理请求的数量。<strong>系统吞吐量主要取决于主存的存取周期</strong>。</li><li>响应时间：指用户从计算机发送一个请求，到<strong>系统对该请求做出响应并获得所需结果的等待时间</strong>。</li></ul></li><li><p>主频和CPU时钟周期。</p><ul><li><p>CPU时钟周期。通常为节拍脉冲或T周期，即主频的倒数，是<strong>CPU的最小时间单位</strong>，执行指令的每个动作至少需要1个时钟周期。</p><p><strong>CPU时钟周期&#x3D;$\frac{1}{主频}$</strong></p></li><li><p>主频（CPU时钟频率）。是<strong>衡量机器速度的重要参数</strong>。主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。</p></li></ul><p><strong>注：CPU时钟周期&#x3D;1&#x2F;主频，主频通常以Hz（赫兹）为单位，1Hz表示每秒1次。</strong></p></li><li><p>CPI（Cycle Per Instruction）：即<strong>执行一条指令所需的时钟周期数</strong>。</p></li><li><p>CPU执行时间：指运行一个程序所花费的时间。</p><p><strong>CPU执行时间&#x3D;CPU时钟周期数&#x2F;主频&#x3D;（指令条数$\times$CPI）&#x2F;主频</strong></p><p>CPU的性能主要取决于<strong>三个要素</strong>：</p><ol><li>主频</li><li>每条指令执行所用的时钟周期数（CPI）</li><li>指令条数</li></ol></li><li><p>MIPS（Million Instructions Per Second），即每秒执行多少百万条指令。</p><p><strong>MIPS&#x3D;指令条数&#x2F;(执行时间$\times 10^6$)&#x3D;主频&#x2F;(CPI$\times 10^6$)</strong></p></li></ol><h4 id="基准程序"><a href="#基准程序" class="headerlink" title="基准程序"></a>基准程序</h4><p>基准程序是专门用来进行性能评价的一组程序。（例如跑分软件）</p><h4 id="其他专业术语"><a href="#其他专业术语" class="headerlink" title="其他专业术语"></a>其他专业术语</h4><ol><li>系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。</li><li>兼容：指软件或硬件的通用性。</li><li>软件可移植性：指把使用再某个系列计算机中的软件直接或进行很少修改就能运行在另一个计算机的可能性。</li><li>固件：将程序固化在ROM中组成的部件称为固件。</li></ol><h4 id="常用数量单位"><a href="#常用数量单位" class="headerlink" title="常用数量单位"></a>常用数量单位</h4><h5 id="描述内存容量、文件大小时："><a href="#描述内存容量、文件大小时：" class="headerlink" title="描述内存容量、文件大小时："></a><strong>描述内存容量、文件大小时：</strong></h5><p>$1KB&#x3D;2^{10}B&#x3D;1024B,1MB&#x3D;2^{20}B,1GB&#x3D;2^{30}B, 1TB&#x3D;2^{40}B$</p><h5 id="描述频率、速率时："><a href="#描述频率、速率时：" class="headerlink" title="描述频率、速率时："></a><strong>描述频率、速率时：</strong></h5><p><strong>大小以乘$10^3$递增</strong></p><p>$K&#x3D;10^3,M&#x3D;10^6…$</p><p>K-&gt;M-&gt;G-&gt;T-&gt;P-&gt;F-&gt;Z</p><h3 id="常见问题与易混淆点"><a href="#常见问题与易混淆点" class="headerlink" title="常见问题与易混淆点"></a>常见问题与易混淆点</h3><h4 id="翻译程序、解释程序、汇编程序、编译程序的区别和联系"><a href="#翻译程序、解释程序、汇编程序、编译程序的区别和联系" class="headerlink" title="翻译程序、解释程序、汇编程序、编译程序的区别和联系"></a>翻译程序、解释程序、汇编程序、编译程序的区别和联系</h4><p>翻译程序有两种：</p><p>​一种是<strong>编译程序</strong>，将语言源程序<strong>一次性全翻译</strong>成目标程序。</p><p>​另一种是<strong>解释程序</strong>，将语言源程序<strong>逐句翻译</strong>成对应的机器目标代码，直至所有语句全部被翻译并执行完。</p><p><strong>汇编程序</strong>也是一种语言翻译程序，它把<strong>汇编语言源程序翻译为机器语言程序</strong>。</p><h4 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h4><p>在计算机领域种，所谓用户无法”看“到的某个事物或属性，称为”透明“。</p><p>例如，<strong>对用高级语言程序员来说</strong>，浮点数格式。乘法指令等这些指令的格式和数据如何运行等都是<strong>透明</strong>的；</p><p><strong>对于机器语言或汇编语言程序员来说</strong>，指令的格式、机器结构、数据格式等<strong>都不是透明的</strong>。</p><p><strong>在CPU中</strong>，IR、MAR和MDR对各类程序员都是<strong>透明</strong>的。</p><h4 id="字、字长、机器字长、指令字长、存储字长的区别和联系"><a href="#字、字长、机器字长、指令字长、存储字长的区别和联系" class="headerlink" title="字、字长、机器字长、指令字长、存储字长的区别和联系"></a>字、字长、机器字长、指令字长、存储字长的区别和联系</h4><p>通常说”某16位或32位机器“中，16、32指的是字长，<strong>也称机器字长</strong>。</p><p>所谓<strong>字长</strong>，通常是指CPU内部用于整数运算的<strong>数据通路的宽度</strong>，反映了计算机处理信息的能力。</p><p><strong>指令字长</strong>一般取<strong>存储字长</strong>的整数倍，若指令字长等于存储字长的2倍，则需要2访存周期来取出一条指令；</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_网络层</title>
      <link href="/2022/04/14/wang-luo-ceng/"/>
      <url>/2022/04/14/wang-luo-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="4-1网络层概述"><a href="#4-1网络层概述" class="headerlink" title="4.1网络层概述"></a>4.1网络层概述</h3><h4 id="网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输"><a href="#网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输" class="headerlink" title="网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输"></a>网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输</h4><h4 id="实现网络层任务，需要解决的问题"><a href="#实现网络层任务，需要解决的问题" class="headerlink" title="实现网络层任务，需要解决的问题"></a>实现网络层任务，需要解决的问题</h4><p>​网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）<br>​网络层寻址问题<br>​路由选择问题</p><h4 id="因特网是目前全世界用户最多的互联网，它使用TCP-x2F-IP协议栈"><a href="#因特网是目前全世界用户最多的互联网，它使用TCP-x2F-IP协议栈" class="headerlink" title="因特网是目前全世界用户最多的互联网，它使用TCP&#x2F;IP协议栈"></a>因特网是目前全世界用户最多的互联网，它使用TCP&#x2F;IP协议栈</h4><p>​由于TCP&#x2F;IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP&#x2F;IP协议栈中网络层常称为网际层</p><hr><h3 id="4-2网络层提供的两种服务"><a href="#4-2网络层提供的两种服务" class="headerlink" title="4.2网络层提供的两种服务"></a>4.2网络层提供的两种服务</h3><h4 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h4><p>​可靠通信由网络来保证<br>​必须建立网络层的连接—虚电路VC(Virtual Circuit)<br>​通信双方沿着已建立的虚电路发送分组<br>​分组的首部只需携带一条虚电路的编号<br>​通信结束后，需要释放之前所建立的虚电路</p><h4 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h4><p>​可靠通信由用户主机来保证<br>​不需要建立网络层连接<br>​每个分组可走不同路径<br>​每个分组首部必须携带目的主机的完整地址<br>​分组可能误码、丢失、重复和失序<br>​由于网络本身不提供端到端的可靠传输服务，造价成本相对低廉<br>​因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心</p><hr><h3 id="4-3-1IPv4地址概述"><a href="#4-3-1IPv4地址概述" class="headerlink" title="4.3.1IPv4地址概述"></a>4.3.1IPv4地址概述</h3><h4 id="是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符"><a href="#是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符" class="headerlink" title="是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符"></a>是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符</h4><h4 id="编址方法经历了三个历史阶段"><a href="#编址方法经历了三个历史阶段" class="headerlink" title="编址方法经历了三个历史阶段"></a>编址方法经历了三个历史阶段</h4><p>​分类编址（1981）<br>​划分子网（1985）<br>​无分类编址（1993）</p><h4 id="采用点分十进制表示方法"><a href="#采用点分十进制表示方法" class="headerlink" title="采用点分十进制表示方法"></a>采用点分十进制表示方法</h4><hr><h3 id="4-3-2分类编址的IPv4地址"><a href="#4-3-2分类编址的IPv4地址" class="headerlink" title="4.3.2分类编址的IPv4地址"></a>4.3.2分类编址的IPv4地址</h3><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h4><h5 id="网络号"><a href="#网络号" class="headerlink" title="网络号"></a>网络号</h5><p>​8位（最高位固定为0）</p><h5 id="主机号"><a href="#主机号" class="headerlink" title="主机号"></a>主机号</h5><p>​24位</p><h5 id="最小网络号0，保留不指派"><a href="#最小网络号0，保留不指派" class="headerlink" title="最小网络号0，保留不指派"></a>最小网络号0，保留不指派</h5><h5 id="第一个可指派的网络号为1，网络地址为1-0-0-0"><a href="#第一个可指派的网络号为1，网络地址为1-0-0-0" class="headerlink" title="第一个可指派的网络号为1，网络地址为1.0.0.0"></a>第一个可指派的网络号为1，网络地址为1.0.0.0</h5><h5 id="最大网络号127，作为本地环回测试地址，不指派"><a href="#最大网络号127，作为本地环回测试地址，不指派" class="headerlink" title="最大网络号127，作为本地环回测试地址，不指派"></a>最大网络号127，作为本地环回测试地址，不指派</h5><p>​最小本地环回测试地址为127.0.0.1<br>​最大本地环回测试地址为127.255.255.254</p><h5 id="最后一个可指派的网络号为126，网络地址为126-0-0-0"><a href="#最后一个可指派的网络号为126，网络地址为126-0-0-0" class="headerlink" title="最后一个可指派的网络号为126，网络地址为126.0.0.0"></a>最后一个可指派的网络号为126，网络地址为126.0.0.0</h5><p>​<br>$$<br>可指派的网络数量为2^{8-1}-2 &#x3D; 126(除去最小网络号和最大网络号)\\</p><pre><code>    可分配的IP数量为2^&#123;24&#125; - 2 =16777214(除去全0网络地址和全1广播地址)        </code></pre><p>$$</p><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h4><h5 id="网络号-1"><a href="#网络号-1" class="headerlink" title="网络号"></a>网络号</h5><p>​16位（最高位固定为10）</p><h5 id="主机号-1"><a href="#主机号-1" class="headerlink" title="主机号"></a>主机号</h5><p>​16位</p><h5 id="最小网络号也是第一个可指派的网络号128-0，网络地址128-0-0-0"><a href="#最小网络号也是第一个可指派的网络号128-0，网络地址128-0-0-0" class="headerlink" title="最小网络号也是第一个可指派的网络号128.0，网络地址128.0.0.0"></a>最小网络号也是第一个可指派的网络号128.0，网络地址128.0.0.0</h5><h5 id="最大网络号也是最后一个可指派的网络号191-255，网络地址191-255-0-0"><a href="#最大网络号也是最后一个可指派的网络号191-255，网络地址191-255-0-0" class="headerlink" title="最大网络号也是最后一个可指派的网络号191.255，网络地址191.255.0.0"></a>最大网络号也是最后一个可指派的网络号191.255，网络地址191.255.0.0</h5><p>​<br>$$<br>可指派的网络数量为2^{16-2}&#x3D; 16384\\<br>        可分配的IP数量为2^{16} - 2 &#x3D;65534(除去全0网络地址和全1广播地址)</p><p>$$<br>​根据2002年9月发表的RFC 3330文档，128.0可以分配</p><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h4><h5 id="网络号-2"><a href="#网络号-2" class="headerlink" title="网络号"></a>网络号</h5><p>​24位（最高位固定为110）</p><h5 id="主机号-2"><a href="#主机号-2" class="headerlink" title="主机号"></a>主机号</h5><p>​8位</p><h5 id="最小网络号也是第一个可指派的网络号192-0-0，网络地址192-0-0-0"><a href="#最小网络号也是第一个可指派的网络号192-0-0，网络地址192-0-0-0" class="headerlink" title="最小网络号也是第一个可指派的网络号192.0.0，网络地址192.0.0.0"></a>最小网络号也是第一个可指派的网络号192.0.0，网络地址192.0.0.0</h5><h5 id="最大网络号也是最后一个可指派的网络号223-255-255，网络地址223-255-255-0"><a href="#最大网络号也是最后一个可指派的网络号223-255-255，网络地址223-255-255-0" class="headerlink" title="最大网络号也是最后一个可指派的网络号223.255.255，网络地址223.255.255.0"></a>最大网络号也是最后一个可指派的网络号223.255.255，网络地址223.255.255.0</h5><p>​<br>$$<br>可指派的网络数量为2^{24-3}&#x3D; 2097152\\<br>        可分配的IP数量为2^8 - 2 &#x3D; 254(除去全0网络地址和全1广播地址)</p><p>$$<br>​根据2002年9月发表的RFC 3330文档，192.0.0可以分配</p><h4 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h4><h5 id="多播地址"><a href="#多播地址" class="headerlink" title="多播地址"></a>多播地址</h5><p>​最高位固定1110</p><h4 id="E类地址"><a href="#E类地址" class="headerlink" title="E类地址"></a>E类地址</h4><h5 id="保留为今后使用"><a href="#保留为今后使用" class="headerlink" title="保留为今后使用"></a>保留为今后使用</h5><p>​最高位固定1111</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>​只有A类、B类和C类地址可分配给网络中的主机或路由器的各接口<br>​主机号为“全0”的地址是网络地址，不能分配<br>​主机号为“全1”的地址是广播地址，不能分配</p><h4 id="一般不使用的特殊IP地址"><a href="#一般不使用的特殊IP地址" class="headerlink" title="一般不使用的特殊IP地址"></a>一般不使用的特殊IP地址</h4><p>​地址0.0.0.0是一个特殊的IPv4地址，只能作为源地址使用，表示“在本网络上的本主机”，封装由DHCP Discovery报文的IP分组的源地址使用0.0.0.0<br>​以127开头且后面三个字节非“全0”或“全1”的IP地址是一类特殊的IPv4地址，既可以作为源地址使用，也可以作为目的地址使用，用于本地软件环回测试<br>​地址255.255.255.255只能作为目的地址使用，表示“只在本网络上进行广播”（路由器均不转发）</p><hr><h3 id="4-3-3划分子网的IPv4地址"><a href="#4-3-3划分子网的IPv4地址" class="headerlink" title="4.3.3划分子网的IPv4地址"></a>4.3.3划分子网的IPv4地址</h3><h4 id="为新增网络申请新的网络号回带来弊端"><a href="#为新增网络申请新的网络号回带来弊端" class="headerlink" title="为新增网络申请新的网络号回带来弊端"></a>为新增网络申请新的网络号回带来弊端</h4><p>​需要等待时间和花费更多的费用<br>​会增加其他路由器中路由表记录的数量<br>​浪费原有网络中剩余的大量IP地址</p><h4 id="32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号"><a href="#32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号" class="headerlink" title="32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号"></a>32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号</h4><p>​用连续的比特1来对应网络号和子网号<br>​用连续的比特0来对应主机号<br>​将划分子网的IPv4与其对应的子网掩码进行逻辑与运算就可以得到IPv4地址所在的子网的网络地址<br>​结果网络号和子网号被保留，主机号被清零</p><h4 id="默认的子网掩码是指在未划分子网的情况下使用的子网掩码"><a href="#默认的子网掩码是指在未划分子网的情况下使用的子网掩码" class="headerlink" title="默认的子网掩码是指在未划分子网的情况下使用的子网掩码"></a>默认的子网掩码是指在未划分子网的情况下使用的子网掩码</h4><h5 id="A类地址默认子网掩码"><a href="#A类地址默认子网掩码" class="headerlink" title="A类地址默认子网掩码"></a>A类地址默认子网掩码</h5><p>​255.0.0.0</p><h5 id="B类地址默认子网掩码"><a href="#B类地址默认子网掩码" class="headerlink" title="B类地址默认子网掩码"></a>B类地址默认子网掩码</h5><p>​255.255.0.0</p><h5 id="C类地址默认子网掩码"><a href="#C类地址默认子网掩码" class="headerlink" title="C类地址默认子网掩码"></a>C类地址默认子网掩码</h5><p>​255.255.255.0</p><hr><h3 id="4-3-4无分类编址的IPv4地址"><a href="#4-3-4无分类编址的IPv4地址" class="headerlink" title="4.3.4无分类编址的IPv4地址"></a>4.3.4无分类编址的IPv4地址</h3><h4 id="提出采用无分类编址来解决IP地址紧张的问题"><a href="#提出采用无分类编址来解决IP地址紧张的问题" class="headerlink" title="提出采用无分类编址来解决IP地址紧张的问题"></a>提出采用无分类编址来解决IP地址紧张的问题</h4><h4 id="1993年，IETF发布了无分类域间路由选择CIDR-Classless-Inter-Domain-Routing"><a href="#1993年，IETF发布了无分类域间路由选择CIDR-Classless-Inter-Domain-Routing" class="headerlink" title="1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-Domain Routing)"></a>1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-Domain Routing)</h4><h5 id="消除了传统A类、B类、C类地址，以及划分子网概念"><a href="#消除了传统A类、B类、C类地址，以及划分子网概念" class="headerlink" title="消除了传统A类、B类、C类地址，以及划分子网概念"></a>消除了传统A类、B类、C类地址，以及划分子网概念</h5><h5 id="可以更有效的分配地址空间"><a href="#可以更有效的分配地址空间" class="headerlink" title="可以更有效的分配地址空间"></a>可以更有效的分配地址空间</h5><h5 id="使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量"><a href="#使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量" class="headerlink" title="使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量"></a>使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量</h5><h5 id="是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128-14-35-7-x2F-20）"><a href="#是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128-14-35-7-x2F-20）" class="headerlink" title="是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128.14.35.7&#x2F;20）"></a>是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128.14.35.7&#x2F;20）</h5><h5 id="只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节"><a href="#只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节" class="headerlink" title="只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节"></a>只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节</h5><p>​地址块的最小地址<br>​地址块的最大地址<br>​地址块的地址数量<br>​地址块的聚合某类网络数量<br>​地址掩码（子网掩码）</p><h4 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h4><p>​网络前缀越长、地址块越小，路由越具体<br>​若路由器查表转发分组时发现由多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配</p><hr><h3 id="4-3-5IPv4地址的应用规划"><a href="#4-3-5IPv4地址的应用规划" class="headerlink" title="4.3.5IPv4地址的应用规划"></a>4.3.5IPv4地址的应用规划</h3><h4 id="定长的子网掩码FLSM"><a href="#定长的子网掩码FLSM" class="headerlink" title="定长的子网掩码FLSM"></a>定长的子网掩码FLSM</h4><p>​使用同一个子网掩码来划分子网<br>​子网划分方式不灵活：只能划分除2^n个子网（n是从主机号部分借用的用来作为子网号的比特数量）<br>​每个子网所分配的IP地址数量相同，容易造成IP地址浪费</p><h4 id="变长的子网掩码VLSM"><a href="#变长的子网掩码VLSM" class="headerlink" title="变长的子网掩码VLSM"></a>变长的子网掩码VLSM</h4><p>​使用不同的子网掩码来划分子网<br>​子网划分方式灵活：可以按需分配<br>​每个子网所分配的IP数量可以不同，尽可能减少对IP地址的浪费</p><hr><h3 id="4-4IP地址数据报的发送和转发过程"><a href="#4-4IP地址数据报的发送和转发过程" class="headerlink" title="4.4IP地址数据报的发送和转发过程"></a>4.4IP地址数据报的发送和转发过程</h3><h4 id="主机发送IP数据报"><a href="#主机发送IP数据报" class="headerlink" title="主机发送IP数据报"></a>主机发送IP数据报</h4><h5 id="判断目的主机是否与自己在同一个网络"><a href="#判断目的主机是否与自己在同一个网络" class="headerlink" title="判断目的主机是否与自己在同一个网络"></a>判断目的主机是否与自己在同一个网络</h5><p>​同一个网络属于直接交付<br>​不同网络属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发</p><h4 id="路由器转发IP数据报"><a href="#路由器转发IP数据报" class="headerlink" title="路由器转发IP数据报"></a>路由器转发IP数据报</h4><p>​检查IP数据报首付是否出错<br>​根据IP数据报的目的地址在路由表中查找匹配的条目</p><hr><h3 id="4-5静态路由配置及其可能产生的路由环路问题"><a href="#4-5静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5静态路由配置及其可能产生的路由环路问题"></a>4.5静态路由配置及其可能产生的路由环路问题</h3><h4 id="静态路由指人工配置的路由表"><a href="#静态路由指人工配置的路由表" class="headerlink" title="静态路由指人工配置的路由表"></a>静态路由指人工配置的路由表</h4><p>​这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）变化</p><h4 id="可能导致出现路由环路"><a href="#可能导致出现路由环路" class="headerlink" title="可能导致出现路由环路"></a>可能导致出现路由环路</h4><p>​配置错误<br>​聚合了不存在的网络<br>​网络故障</p><h4 id="路由条目的类型"><a href="#路由条目的类型" class="headerlink" title="路由条目的类型"></a>路由条目的类型</h4><p>​直连网络<br>​静态路由（人工配置）<br>​动态路由（路由选择协议）</p><h4 id="特殊的静态路由条目"><a href="#特殊的静态路由条目" class="headerlink" title="特殊的静态路由条目"></a>特殊的静态路由条目</h4><p>​默认路由（目的网络为0.0.0.0，地址掩码为0.0.0.0）<br>​特定主机路由（目的网络为特定主机的IP地址，地址掩码为255.255.255.255）<br>​黑洞路由（下一跳为null0）</p><hr><h3 id="4-6-1路由选择协议概述"><a href="#4-6-1路由选择协议概述" class="headerlink" title="4.6.1路由选择协议概述"></a>4.6.1路由选择协议概述</h3><h4 id="静态路由选择"><a href="#静态路由选择" class="headerlink" title="静态路由选择"></a>静态路由选择</h4><p>​由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由<br>​人工配置方式简单、开销小，但不能及时适应网络状态（流量、拓扑）的变化<br>​一般只在小规模中采用</p><h4 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h4><p>​路由器通过路由选择协议自动获取路由信息<br>​能比较好地适应网络状态的变化<br>​适用于大规模网络</p><h4 id="因特网所采用的路由选择协议的主要特点"><a href="#因特网所采用的路由选择协议的主要特点" class="headerlink" title="因特网所采用的路由选择协议的主要特点"></a>因特网所采用的路由选择协议的主要特点</h4><h5 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h5><p>​动态路由选择，能较好的适应网络状态的变化</p><h5 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h5><p>​路由器之间交换路由信息</p><h5 id="分层次"><a href="#分层次" class="headerlink" title="分层次"></a>分层次</h5><p>​将整个因特网划分为许多较小的自治系统AS（Automous System）</p><h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><h5 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h5><h6 id="基于距离向量"><a href="#基于距离向量" class="headerlink" title="基于距离向量"></a>基于距离向量</h6><p>​路由信息协议RIP<br>​内部网关路由协议IGRP</p><h6 id="增强型内部网关路由协议EIGRP"><a href="#增强型内部网关路由协议EIGRP" class="headerlink" title="增强型内部网关路由协议EIGRP"></a>增强型内部网关路由协议EIGRP</h6><h6 id="基于链路状态"><a href="#基于链路状态" class="headerlink" title="基于链路状态"></a>基于链路状态</h6><p>​开放式最短路径优先OSPF<br>​中间系统到中级系统IS-IS</p><h5 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h5><p>​边界网关协议BGP</p><hr><h3 id="4-6-2路由信息协议RIP的基本工作原理"><a href="#4-6-2路由信息协议RIP的基本工作原理" class="headerlink" title="4.6.2路由信息协议RIP的基本工作原理"></a>4.6.2路由信息协议RIP的基本工作原理</h3><h4 id="RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”"><a href="#RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”" class="headerlink" title="RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”"></a>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”</h4><h4 id="RIP使用跳数作为度量来衡量到达目的网络的距离"><a href="#RIP使用跳数作为度量来衡量到达目的网络的距离" class="headerlink" title="RIP使用跳数作为度量来衡量到达目的网络的距离"></a>RIP使用跳数作为度量来衡量到达目的网络的距离</h4><p>​路由器到直连网络的距离定义为1<br>​路由器到非直连网络的距离定义为所经过的路由器加1<br>​允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。因此RIP只适用于小型互联网</p><h4 id="RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由"><a href="#RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由" class="headerlink" title="RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由"></a>RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由</h4><h4 id="当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡"><a href="#当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡" class="headerlink" title="当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡"></a>当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡</h4><h4 id="RIP包含三个要点"><a href="#RIP包含三个要点" class="headerlink" title="RIP包含三个要点"></a>RIP包含三个要点</h4><h5 id="和谁交换信息"><a href="#和谁交换信息" class="headerlink" title="和谁交换信息"></a>和谁交换信息</h5><p>​仅和相邻路由器交换信息</p><h5 id="交换什么信息"><a href="#交换什么信息" class="headerlink" title="交换什么信息"></a>交换什么信息</h5><p>​自己的路由表</p><h5 id="何时交换信息"><a href="#何时交换信息" class="headerlink" title="何时交换信息"></a>何时交换信息</h5><p>​周期性交换（例如每30秒）</p><h4 id="路由器刚开始工作时，只知道自己到直连网络的距离为1"><a href="#路由器刚开始工作时，只知道自己到直连网络的距离为1" class="headerlink" title="路由器刚开始工作时，只知道自己到直连网络的距离为1"></a>路由器刚开始工作时，只知道自己到直连网络的距离为1</h4><p>​每个路由器仅和相邻路由器周期性地交换并更新路由信息<br>​若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛</p><h4 id="RIP存在“坏消息传播得慢”问题"><a href="#RIP存在“坏消息传播得慢”问题" class="headerlink" title="RIP存在“坏消息传播得慢”问题"></a>RIP存在“坏消息传播得慢”问题</h4><p>​又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害</p><h5 id="限制最大路径距离为15（16表示不可达）"><a href="#限制最大路径距离为15（16表示不可达）" class="headerlink" title="限制最大路径距离为15（16表示不可达）"></a>限制最大路径距离为15（16表示不可达）</h5><h5 id="当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送"><a href="#当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送" class="headerlink" title="当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送"></a>当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送</h5><h5 id="让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）"><a href="#让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）" class="headerlink" title="让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）"></a>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）</h5><hr><h3 id="4-6-3开放最短路径优先OSPF的基本工作原理"><a href="#4-6-3开放最短路径优先OSPF的基本工作原理" class="headerlink" title="4.6.3开放最短路径优先OSPF的基本工作原理"></a>4.6.3开放最短路径优先OSPF的基本工作原理</h3><p>​OSPF是基于链路状态</p><p>​采用SPF算法计算路由，从算法上保证了不会产生路由环路<br>​不限制网络规模，更新效率高，收敛速度快</p><h4 id="链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”"><a href="#链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”" class="headerlink" title="链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”"></a>链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”</h4><p>​“代价”用来表示费用、距离、时延、带宽，等等。</p><p>​思科路由器OSPF计算代价的方法：100Mbps &#x2F; 链路带宽</p><h4 id="OSPF相邻路由器之间通过交互问候分组-Hello-，建立和维护邻居关系"><a href="#OSPF相邻路由器之间通过交互问候分组-Hello-，建立和维护邻居关系" class="headerlink" title="OSPF相邻路由器之间通过交互问候分组(Hello)，建立和维护邻居关系"></a>OSPF相邻路由器之间通过交互问候分组(Hello)，建立和维护邻居关系</h4><p>​Hello分组封装再IP数据报中</p><h4 id="使用OSPF的每个路由器会产生链路状态通告LSA"><a href="#使用OSPF的每个路由器会产生链路状态通告LSA" class="headerlink" title="使用OSPF的每个路由器会产生链路状态通告LSA"></a>使用OSPF的每个路由器会产生链路状态通告LSA</h4><p>​直连网络的链路状态信息<br>​邻居路由器的链路状态信息<br>​LSA被封装再链路状态更新分组LSU中，采用洪泛法发送<br>​使用OSPF的每一个路由器都有一个链路状态数据库LSDB，用于存储LSA<br>​通过各路由器洪泛发送封装又自己的LSA的LSU分组，各路由器的LSDB最终达到一致<br>​使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表</p><h4 id="OSPF有五种分组类型"><a href="#OSPF有五种分组类型" class="headerlink" title="OSPF有五种分组类型"></a>OSPF有五种分组类型</h4><p>​问候（Hello）分组<br>​数据库描述（Database Description）分组<br>​链路状态请求（Link State Request）分组<br>​链路状态更新（Link State Update）分组<br>​链路状态确认（Link State Acknowledgment）分组</p><h4 id="OSPF在多点接入网络中路由器邻居关系的建立"><a href="#OSPF在多点接入网络中路由器邻居关系的建立" class="headerlink" title="OSPF在多点接入网络中路由器邻居关系的建立"></a>OSPF在多点接入网络中路由器邻居关系的建立</h4><p>​选举指定路由器DR和备用的指定路由器BDR<br>​所有的非DR&#x2F;BDR只与DR&#x2F;BDR建立邻居关系<br>​非DR&#x2F;BDR之间通过DR&#x2F;BDR交换信息</p><hr><h3 id="4-6-4边界网关协议BGP的基本工作原理"><a href="#4-6-4边界网关协议BGP的基本工作原理" class="headerlink" title="4.6.4边界网关协议BGP的基本工作原理"></a>4.6.4边界网关协议BGP的基本工作原理</h3><p>​BGP只是力求寻找一条能够到达目的网络且比较好的路由，并非寻找一条最佳路由<br>​配置BGP时，每个自治系统的管理员至少选择一个路由器作为该自治系统的“BGP发言人”</p><h4 id="不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接"><a href="#不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接" class="headerlink" title="不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接"></a>不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接</h4><p>​TCP连接上交换BGP报文以建立BGP会话<br>​利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）<br>​BGP发言人除了运行BGP外，还必须运行自己的自治系统所使用的内部网关协议IGP，例如OSPF或RIP<br>​RGP发言人交换网络可达性的信息<br>​当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通路</p><h4 id="BGP-4有四种报文"><a href="#BGP-4有四种报文" class="headerlink" title="BGP-4有四种报文"></a>BGP-4有四种报文</h4><p>​OPEN报文<br>​UPDATE报文<br>​KEEPLIVE报文<br>​NOTIFICATION报文</p><hr><h3 id="4-7IPv4数据报的首部格式"><a href="#4-7IPv4数据报的首部格式" class="headerlink" title="4.7IPv4数据报的首部格式"></a>4.7IPv4数据报的首部格式</h3><h4 id="固定部分（20字节）"><a href="#固定部分（20字节）" class="headerlink" title="固定部分（20字节）"></a>固定部分（20字节）</h4><p>​版本<br>​首部长度<br>​区分服务<br>​总长度<br>​标识<br>​标志<br>​片偏移<br>​帧的数据载荷长度受限于最大传输单元MTU<br>​以太网规定MTU值为1500字节<br>​生存时间TTL<br>​协议<br>​首部校验和<br>​源IP地址和目的IP地址<br>​这三个字段共用于IP数据报分片</p><h4 id="可变部分（40字节）"><a href="#可变部分（40字节）" class="headerlink" title="可变部分（40字节）"></a>可变部分（40字节）</h4><h5 id="可选字段（长度可变）"><a href="#可选字段（长度可变）" class="headerlink" title="可选字段（长度可变）"></a>可选字段（长度可变）</h5><p>​长度从1个字节到40字节不等，用来支持排错、测量及安全等措施<br>​可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用</p><h5 id="填充字段"><a href="#填充字段" class="headerlink" title="填充字段"></a>填充字段</h5><p>​确保首部长度为4字节的整数倍，使用全0填充<br>​</p><hr><h3 id="4-8网际控制报文协议ICMP"><a href="#4-8网际控制报文协议ICMP" class="headerlink" title="4.8网际控制报文协议ICMP"></a>4.8网际控制报文协议ICMP</h3><p>​主机或路由器使用ICMP来发送差错报告报文和询问报文<br>​ICMP报文被封装在IP数据报中发送</p><h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h4><h5 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h5><p>​当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</p><h5 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h5><p>​当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</p><h5 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h5><p>​当TTL值为0时，除丢弃该IP数据报外，还要向源点发送时间超过报文</p><h5 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h5><p>​当首部出现误码，就向源点发送参数问题报文</p><h5 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h5><p>​让主机知道下次应将数据发送给通过更好的路由</p><h5 id="不应发送ICMP差错报告报文的情况"><a href="#不应发送ICMP差错报告报文的情况" class="headerlink" title="不应发送ICMP差错报告报文的情况"></a>不应发送ICMP差错报告报文的情况</h5><p>​对ICMP报文不再发送ICMP<br>​对第一个分片的数据报片的所有后续数据报片不发送<br>​对具有多播地址的数据报不发送<br>​对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送</p><h4 id="常用的ICMP询问报文"><a href="#常用的ICMP询问报文" class="headerlink" title="常用的ICMP询问报文"></a>常用的ICMP询问报文</h4><h5 id="回送请求和回答"><a href="#回送请求和回答" class="headerlink" title="回送请求和回答"></a>回送请求和回答</h5><p>​用来测试目的站是否可达</p><h5 id="时间戳请求和回答"><a href="#时间戳请求和回答" class="headerlink" title="时间戳请求和回答"></a>时间戳请求和回答</h5><p>​用来进行时钟同步和测量时间</p><hr><h3 id="4-9虚拟专用网VPN与网络地址转换NAT"><a href="#4-9虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9虚拟专用网VPN与网络地址转换NAT"></a>4.9虚拟专用网VPN与网络地址转换NAT</h3><p>​利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网</p><h4 id="各主机所分配的地址应该是本机构可自由分配的专用地址"><a href="#各主机所分配的地址应该是本机构可自由分配的专用地址" class="headerlink" title="各主机所分配的地址应该是本机构可自由分配的专用地址"></a>各主机所分配的地址应该是本机构可自由分配的专用地址</h4><h5 id="专用（私有）地址："><a href="#专用（私有）地址：" class="headerlink" title="专用（私有）地址："></a>专用（私有）地址：</h5><p>​10.0.0.0<del>10.255.255.255（10&#x2F;8地址块）<br>​172.16.0.0</del>172.31.255.255（172.16&#x2F;12地址块）<br>​192.168.0.0~192.168.255.255（192.168&#x2F;16地址块）<br>​同一机构内不同部分的内部网络所构成的虚拟专用网VPN又成为内联网VPN<br>​有时一个机构的VPN需要某些外部机构参加进来，这样的VPN就成为外联网VPN<br>​在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种vpn成为远程接入VPN</p><h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>​NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源<br>​该转换方法存在一个问题：如果NAT路由器具有N各地址IP地址，那么至多只能有n个内网主机能够同时和因特网上的主机通信<br>​用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP一起进行转换的技术叫做网络地址与端口号转换NAPT</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑合集</title>
      <link href="/2022/04/13/cai-keng-he-ji/"/>
      <url>/2022/04/13/cai-keng-he-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="Blog优化相关"><a href="#Blog优化相关" class="headerlink" title="Blog优化相关"></a>Blog优化相关</h3><p>在第一次使用代码块时候发现样式重叠且代码块奇丑无比，马上去网上参考了<a href="http://luckyzmj.cn/posts/1b9a9e28.html">LuckySec</a>的代码优化的文章，在根据他的步骤一步一步下来，发现代码块样式并没有改变，又去修改<code>hexo</code>根目录的<code>_config.yml</code>，将自带的highlight改为false，prismjs改为true，并取消了行标显示，发现样式仍然没有太大改变，经过一段时间的琢磨，才发现需要用<code>hexo clean &amp;&amp; hexo g</code>才能使样式生效。简直了，<strong>每次修改样式必须得重新清理和编译才行，直接在本地运行会有不生效的可能</strong></p><h4 id="使用csdn的图片部署后无法显示问题"><a href="#使用csdn的图片部署后无法显示问题" class="headerlink" title="使用csdn的图片部署后无法显示问题"></a>使用<code>csdn</code>的图片部署后无法显示问题</h4><p>需要添加这一句在文章最上方后即可解决不受后无法显示问题。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>referrer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no-referrer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h3 id="项目实战相关"><a href="#项目实战相关" class="headerlink" title="项目实战相关"></a>项目实战相关</h3><p>在做项目不应该先考虑后续的优化问题，应该先让功能实现再考虑后续的优化问题，不然几个小时都没什么成果。</p><h3 id="Flutter学习相关"><a href="#Flutter学习相关" class="headerlink" title="Flutter学习相关"></a>Flutter学习相关</h3><h4 id="Dio请求发送"><a href="#Dio请求发送" class="headerlink" title="Dio请求发送"></a>Dio请求发送</h4><p>在使用<code>Dio</code>请求发送时候，想在本地写个接口来直接开本地端口调用，却发现使用不了会报异常。</p><p>目前发送使用的是我用<code>node.js</code>写的一个本地接口，开的端口号为3001。</p><p><img src="https://img-blog.csdnimg.cn/d1644f7fc7b0450884e0560ceab34a23.png" alt="send"></p><p>下面这张是我发了请求报的异常。</p><p><img src="https://img-blog.csdnimg.cn/5d54a780ae5541b2abc0cd04aa749dfe.png" alt="exception"></p><p>发现端口号进行了改变，我尝试去使用网络上的接口来发送，发现没有问题。经过一系列排查，结果是因为<code>Dio</code>无法识别主机循环地址，即<code>127.0.0.1</code>，我就通过<code>bash</code>窗口来使用<code>ipconfig</code>命令来查询我所连接的宽带的<code>IPv4</code>地址来作为<code>hostname</code>。</p><p><img src="https://img-blog.csdnimg.cn/6fb0d0c4673346bfaf8e34d873b561b7.png" alt="ip"></p><p>然后重新发送请求。</p><p><img src="https://img-blog.csdnimg.cn/8fac2bd10cfb4784b161562d22c32dac.png" alt="get"></p><p>成功拿到了响应的信息！</p><h3 id="C语言学习相关"><a href="#C语言学习相关" class="headerlink" title="C语言学习相关"></a>C语言学习相关</h3><h4 id="vscode跨文件访问函数"><a href="#vscode跨文件访问函数" class="headerlink" title="vscode跨文件访问函数"></a><code>vscode</code>跨文件访问函数</h4><p>在<code>vscode</code>想使用<code>C/C++ Runner</code>来进行<code>debug</code>的时候发现运行会报错。</p><p><img src="https://img-blog.csdnimg.cn/49e2eb891ea4469cbf0c9bb3e2254b75.png" alt="error"></p><p>因为在<code>main.c</code>函数中我引入了<code>contact.c</code>中的一个函数<code>InitContact()</code>，当我注释掉后可以正常的运行。</p><p><img src="https://img-blog.csdnimg.cn/7b5e0bff34e246cd9bd30f6757877628.png" alt="access"></p><p>这里成功的进入了<code>debug</code>并且没有任何报错。</p><p>通过这段分析就可以明白很显然是在引入外部函数的时候出了问题，但实际上我在上方早已引入了<code>#include &quot;./header/contact.h&quot;</code>，并且<code>struct Contact</code>这个外部结构体正常运行，说明我的头文件内部并没有任何问题，那问题很显然就是在<code>contact.c</code>中。</p><p><img src="https://img-blog.csdnimg.cn/1bb5888498804d99956188519642b0c3.png" alt="head"></p><p><img src="https://img-blog.csdnimg.cn/433154e477c04d21b45ceb05be110381.png" alt="contact"></p><p>经过一系列的摸索后，发现是在<code>tasks.json</code>文件中他并没有引入我的<code>contact.c</code>文件，所以编译器未能找到这函数导致了报错，那解决方法就很简单了，只需要在<code>args</code>中添加上就好了。</p><p><img src="https://img-blog.csdnimg.cn/df445411a09e44f98c5895c476044142.png" alt="add_path"></p><p>重新运行，发现完美解决问题！</p><p><img src="https://img-blog.csdnimg.cn/263613dbf0ba4b0d851a87e6997b551f.png" alt="success"></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_数据链路层</title>
      <link href="/2022/04/13/shu-ju-lian-lu-ceng/"/>
      <url>/2022/04/13/shu-ju-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="3-1数据链路层概述"><a href="#3-1数据链路层概述" class="headerlink" title="3.1数据链路层概述"></a>3.1数据链路层概述</h3><h4 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h4><p>​就是从一个结点道相邻结点的一段物理线路，而中间没有任何其他的交换结点</p><h4 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h4><p>​是指把实现通信协议的硬件和软件加道链路上，就构成了数据链路</p><h4 id="数据链路层以帧为单位传输和处理数据"><a href="#数据链路层以帧为单位传输和处理数据" class="headerlink" title="数据链路层以帧为单位传输和处理数据"></a>数据链路层以帧为单位传输和处理数据</h4><h4 id="数据链路层的三个重要问题"><a href="#数据链路层的三个重要问题" class="headerlink" title="数据链路层的三个重要问题"></a>数据链路层的三个重要问题</h4><p>​封装成帧<br>​差错检测<br>​可靠传输</p><hr><h3 id="3-2封装成帧"><a href="#3-2封装成帧" class="headerlink" title="3.2封装成帧"></a>3.2封装成帧</h3><h4 id="封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧"><a href="#封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧" class="headerlink" title="封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧"></a>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</h4><p>​帧头和帧尾中包含有重要的控制信息<br>​帧头和帧尾的作用之一就是帧定界</p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>​指数据链路层对上层交付的传输数据中没有任何限制，就好像数据链层不存在一样<br>​面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输<br>​面向比特的物理链路使用比特填充的方法实现透明传输</p><h4 id="为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些"><a href="#为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些" class="headerlink" title="为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些"></a>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些</h4><h4 id="考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU"><a href="#考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU" class="headerlink" title="考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU"></a>考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU</h4><hr><h3 id="3-3差错检测"><a href="#3-3差错检测" class="headerlink" title="3.3差错检测"></a>3.3差错检测</h3><h4 id="实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1-这称为比特差错"><a href="#实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1-这称为比特差错" class="headerlink" title="实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1.这称为比特差错"></a>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1.这称为比特差错</h4><h4 id="在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit-Error-Rate）"><a href="#在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit-Error-Rate）" class="headerlink" title="在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit Error Rate）"></a>在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit Error Rate）</h4><h4 id="使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一"><a href="#使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一" class="headerlink" title="使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一"></a>使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一</h4><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>​在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的检验位在内）中“1”的个数为奇数或偶数</p><p>​如果有奇数个位发送无码，则奇偶性发生变化，可以检查出误码<br>​如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码（漏检）</p><h4 id="循环冗余校验CRC（Cyclic-Redundancy-Check）"><a href="#循环冗余校验CRC（Cyclic-Redundancy-Check）" class="headerlink" title="循环冗余校验CRC（Cyclic Redundancy Check）"></a>循环冗余校验CRC（Cyclic Redundancy Check）</h4><p>​收发双方约定好一个生成多项式G（x）<br>​发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加道待传输数据的后面一起传输<br>​接收方通过生成多项式来计算收到的数据是否产生了误码</p><h4 id="检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误"><a href="#检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误" class="headerlink" title="检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误"></a>检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误</h4><h4 id="要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用"><a href="#要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用" class="headerlink" title="要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用"></a>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用</h4><hr><h3 id="3-4-1可靠传输的基本概念"><a href="#3-4-1可靠传输的基本概念" class="headerlink" title="3.4.1可靠传输的基本概念"></a>3.4.1可靠传输的基本概念</h3><p>​无线链路易受干扰，误码率较高，因此要求数据链路层必须向上提供可靠传输服务<br>​有线链路的误码率比较低，并不要求数据链路层向上提供可靠传输服务<br>​传输差错还包括分组丢失、分组失序以及分组重复</p><h3 id="3-4-2停止-等待协议SW"><a href="#3-4-2停止-等待协议SW" class="headerlink" title="3.4.2停止-等待协议SW"></a>3.4.2停止-等待协议SW</h3><p>​为解决接收方收不到数据分组，不发送ACK或NAK问题，可以启动一个超时计时器。一般将重传时间选为略大于“从发送方道接收方的平均往返时间”<br>​为避免分组重复这种传输错误，必须给每个分组带上序号<br>​数据链路层一般不会出现ACK分组迟到情况，因此在数据链路层可以不用给ACK分组编号</p><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>$$<br>    信道利用率U &#x3D; TD&#x2F;TD + RTT + TA\\<br>    TD （发送方发送分组的发送时延）\\<br>    RTT（收发双方的往返时间）\\<br>    TA（接收方发送确认分组所消耗的发送时延）\\<br>$$</p><h3 id="3-4-3回退N帧协议"><a href="#3-4-3回退N帧协议" class="headerlink" title="3.4.3回退N帧协议"></a>3.4.3回退N帧协议</h3><h4 id="发送窗口的尺寸WT的取值"><a href="#发送窗口的尺寸WT的取值" class="headerlink" title="发送窗口的尺寸WT的取值"></a>发送窗口的尺寸WT的取值</h4><p>​1&lt;WT&lt;&#x3D;2^n- 1 </p><h4 id="接收窗口的尺寸WR的取值"><a href="#接收窗口的尺寸WR的取值" class="headerlink" title="接收窗口的尺寸WR的取值"></a>接收窗口的尺寸WR的取值</h4><p>​WR&#x3D;1</p><h4 id="接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认"><a href="#接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认" class="headerlink" title="接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认"></a>接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认</h4><h3 id="3-4-4选择重传协议SR"><a href="#3-4-4选择重传协议SR" class="headerlink" title="3.4.4选择重传协议SR"></a>3.4.4选择重传协议SR</h3><h4 id="发送窗口的尺寸WT的取值-1"><a href="#发送窗口的尺寸WT的取值-1" class="headerlink" title="发送窗口的尺寸WT的取值"></a>发送窗口的尺寸WT的取值</h4><p>​1 &lt; WT &lt;&#x3D; 2(^n-1)</p><h4 id="接受窗口的尺寸WR的取值"><a href="#接受窗口的尺寸WR的取值" class="headerlink" title="接受窗口的尺寸WR的取值"></a>接受窗口的尺寸WR的取值</h4><p>​WR&#x3D;WT</p><h4 id="发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去"><a href="#发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去" class="headerlink" title="发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去"></a>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去</h4><h4 id="接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组"><a href="#接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组" class="headerlink" title="接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组"></a>接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组</h4><h4 id="接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动"><a href="#接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动" class="headerlink" title="接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动"></a>接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动</h4><h4 id="发送方对收到的分组进行记录，以防止其相应数据分组的超时重发"><a href="#发送方对收到的分组进行记录，以防止其相应数据分组的超时重发" class="headerlink" title="发送方对收到的分组进行记录，以防止其相应数据分组的超时重发"></a>发送方对收到的分组进行记录，以防止其相应数据分组的超时重发</h4><hr><h3 id="3-5点对点协议PPP"><a href="#3-5点对点协议PPP" class="headerlink" title="3.5点对点协议PPP"></a>3.5点对点协议PPP</h3><h4 id="是目前使用最广泛的点对点数据链路层协议"><a href="#是目前使用最广泛的点对点数据链路层协议" class="headerlink" title="是目前使用最广泛的点对点数据链路层协议"></a>是目前使用最广泛的点对点数据链路层协议</h4><h4 id="在点对点链路传输提供了一个标准方法，主要由三部分构成"><a href="#在点对点链路传输提供了一个标准方法，主要由三部分构成" class="headerlink" title="在点对点链路传输提供了一个标准方法，主要由三部分构成"></a>在点对点链路传输提供了一个标准方法，主要由三部分构成</h4><h5 id="对各种协议数据报的封装方法（封装成帧）"><a href="#对各种协议数据报的封装方法（封装成帧）" class="headerlink" title="对各种协议数据报的封装方法（封装成帧）"></a>对各种协议数据报的封装方法（封装成帧）</h5><h5 id="链路控制协议LCP"><a href="#链路控制协议LCP" class="headerlink" title="链路控制协议LCP"></a>链路控制协议LCP</h5><p>​用于建立、配置以及测试数据链路的连接</p><h5 id="一套网络控制协议NCPs"><a href="#一套网络控制协议NCPs" class="headerlink" title="一套网络控制协议NCPs"></a>一套网络控制协议NCPs</h5><p>​其中的每一个协议支持不同的网络层协议</p><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><h5 id="帧的首部"><a href="#帧的首部" class="headerlink" title="帧的首部"></a>帧的首部</h5><h6 id="F（1字节）"><a href="#F（1字节）" class="headerlink" title="F（1字节）"></a>F（1字节）</h6><p>​标志（Flag）字段：PPP帧的定界符，取值为0x7E</p><h6 id="A（1字节）"><a href="#A（1字节）" class="headerlink" title="A（1字节）"></a>A（1字节）</h6><p>​地址（Address）字段：取值为0xFF，预留（目前没有什么作用）</p><h6 id="C（1字节）"><a href="#C（1字节）" class="headerlink" title="C（1字节）"></a>C（1字节）</h6><p>​控制（Control）字段：取值为0x03，预留（目前没有什么作用）</p><h6 id="P（2字节）"><a href="#P（2字节）" class="headerlink" title="P（2字节）"></a>P（2字节）</h6><p>​协议（Protocol）字段：指明帧的数据部分送交给哪个协议处理<br>$$<br>取值0x0021表示：帧的数据部分为IP数据报\\<br>取值0xC021表示：帧的数据部分为LCP分组\\<br>取值0x8021表示：帧的数据部分为NCP分组<br>$$</p><h5 id="帧的数据部分"><a href="#帧的数据部分" class="headerlink" title="帧的数据部分"></a>帧的数据部分</h5><p>​不超过1500字节</p><h5 id="帧的尾部"><a href="#帧的尾部" class="headerlink" title="帧的尾部"></a>帧的尾部</h5><h6 id="FCS（2字节）"><a href="#FCS（2字节）" class="headerlink" title="FCS（2字节）"></a>FCS（2字节）</h6><p>​帧校验序列（Frame Check Sequence）字段：CRC计算出的校验位</p><h4 id="解决透明传输"><a href="#解决透明传输" class="headerlink" title="解决透明传输"></a>解决透明传输</h4><h5 id="数据部分出现帧首或帧尾中的标志字段时"><a href="#数据部分出现帧首或帧尾中的标志字段时" class="headerlink" title="数据部分出现帧首或帧尾中的标志字段时"></a>数据部分出现帧首或帧尾中的标志字段时</h5><h5 id="面向字节的异步链路"><a href="#面向字节的异步链路" class="headerlink" title="面向字节的异步链路"></a>面向字节的异步链路</h5><p>​采用字节填充法（插入转义字符）</p><h5 id="面向比特的同步链路"><a href="#面向比特的同步链路" class="headerlink" title="面向比特的同步链路"></a>面向比特的同步链路</h5><p>​采用比特填充法（插入比特0）</p><h4 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h4><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/04/13/shu-ju-lian-lu-ceng/workState.png" class=""></h5><hr><h3 id="3-6-1媒体接入控制的基本概念"><a href="#3-6-1媒体接入控制的基本概念" class="headerlink" title="3.6.1媒体接入控制的基本概念"></a>3.6.1媒体接入控制的基本概念</h3><h4 id="共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium-Access-Control）"><a href="#共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium-Access-Control）" class="headerlink" title="共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium Access Control）"></a>共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium Access Control）</h4><h4 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h4><h5 id="静态划分信道-预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。"><a href="#静态划分信道-预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。" class="headerlink" title="静态划分信道(预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。"></a>静态划分信道(预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。</h5><p>通常在无线网络的物理层中使用)</p><p>​频分多址<br>​时分多址<br>​码分多址</p><h5 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h5><h6 id="受控接入（已被淘汰）"><a href="#受控接入（已被淘汰）" class="headerlink" title="受控接入（已被淘汰）"></a>受控接入（已被淘汰）</h6><p>​集中控制<br>​分散控制</p><h6 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入:"></a>随机接入:</h6><p>​所有站点通过竞争，随机在信道上发送数据。如果恰巧由两个或更多站点在同一时刻发送数据，则信号在共享媒体上就要产生碰撞。使得这些站点都发送失败。因此，这类协议要解决的问题是如何避免冲突以及在发送冲突后如何尽快恢复通信。著名的共享式以太网采用的就是随机接入</p><h4 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h4><h3 id="3-6-2静态划分信道"><a href="#3-6-2静态划分信道" class="headerlink" title="3.6.2静态划分信道"></a>3.6.2静态划分信道</h3><h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><h5 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h5><p>​频分复用的所有用户同时占用不同的频带资源并行通信</p><h5 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h5><p>​所有用户在不同的时间占用同样的频带宽度</p><h5 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h5><h5 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h5><h5 id="使用CDMA的每一个站被指派一个唯一的m-bit码片序列"><a href="#使用CDMA的每一个站被指派一个唯一的m-bit码片序列" class="headerlink" title="使用CDMA的每一个站被指派一个唯一的m bit码片序列"></a>使用CDMA的每一个站被指派一个唯一的m bit码片序列</h5><h6 id="一个站如果要发送比特1，则发送它自己的m-bit码片序列"><a href="#一个站如果要发送比特1，则发送它自己的m-bit码片序列" class="headerlink" title="一个站如果要发送比特1，则发送它自己的m bit码片序列"></a>一个站如果要发送比特1，则发送它自己的m bit码片序列</h6><h6 id="一个站如果要发送比特0，则发送它自己的m-bit码片序列的二进制反码"><a href="#一个站如果要发送比特0，则发送它自己的m-bit码片序列的二进制反码" class="headerlink" title="一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码"></a>一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码</h6><h6 id="码片序列挑选原则"><a href="#码片序列挑选原则" class="headerlink" title="码片序列挑选原则"></a>码片序列挑选原则</h6><p>​码片序列必须各不相同<br>​码片序列必须相互正交（规格化内积为0）<br>​<br>$$<br>S表示站S的码片序列，T表示其他任何站的码片序列\\<br>                    S * T &#x3D; 0\\<br>                    S * S &#x3D; 1\\<br>                    S * 相反T &#x3D; 0\\<br>                    S * 相反S &#x3D; -1<br>$$</p><h3 id="3-6-3CSMA-x2F-CD协议"><a href="#3-6-3CSMA-x2F-CD协议" class="headerlink" title="3.6.3CSMA&#x2F;CD协议"></a>3.6.3CSMA&#x2F;CD协议</h3><h4 id="载波监听多址接入-x2F-碰撞检测-CSMA-x2F-CD-Carrier-Sense-Multiple-Access-x2F-Collision-Detection"><a href="#载波监听多址接入-x2F-碰撞检测-CSMA-x2F-CD-Carrier-Sense-Multiple-Access-x2F-Collision-Detection" class="headerlink" title="载波监听多址接入&#x2F;碰撞检测 CSMA&#x2F;CD(Carrier Sense Multiple Access&#x2F;Collision Detection)"></a>载波监听多址接入&#x2F;碰撞检测 CSMA&#x2F;CD(Carrier Sense Multiple Access&#x2F;Collision Detection)</h4><h5 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h5><p>​多个站连接在一条总线上，竞争使用总线</p><h5 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h5><p>​每一个站在发送帧之前要先检测一下总线上是否由其他站点在发送帧<br>​若检测到总线空闲96比特时间，则发送这个帧<br>​若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧</p><h5 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h5><p>​每一个正在发送的站边发送边检测碰撞<br>​一旦发现总线上出现碰撞，则立即停止发送，退避一段随机事件后再次发送</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p>​以太网端到端往返传播时延2τ称为争用期<br>​主机最多经过2τ的时长就可以检测到本次发送是否遭受了碰撞<br>​共享式以太网不能连接太多的主机，使用的总线也不能太长</p><h4 id="以太网规定最小帧长为64字节（512比特时间即为争用期）"><a href="#以太网规定最小帧长为64字节（512比特时间即为争用期）" class="headerlink" title="以太网规定最小帧长为64字节（512比特时间即为争用期）"></a>以太网规定最小帧长为64字节（512比特时间即为争用期）</h4><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p>$$<br>退避时间 &#x3D; 基本退避时间（争用期2τ） × 随机数r\\（r从离散的整数集合{0,1,…,(2^k-1)}中随机选出一个数\\k &#x3D; Min[重传次数,10]）<br>$$</p><p>​可使重传需要推迟的平均时间随重传次数而增大，因而减小发生碰撞的概率</p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>$$<br>发送一帧占用总线的时间为T0+τ，帧本身发送的时间为T0\\<br>        极限信道利用率Smax &#x3D; T0&#x2F;T0 + τ<br>$$</p><h3 id="3-6-4CSMA-x2F-CA"><a href="#3-6-4CSMA-x2F-CA" class="headerlink" title="3.6.4CSMA&#x2F;CA"></a>3.6.4CSMA&#x2F;CA</h3><h4 id="802-11无线局域网使用CSMA-x2F-CA协议，在CSMA的基础上增加了一个碰撞避免CA功能"><a href="#802-11无线局域网使用CSMA-x2F-CA协议，在CSMA的基础上增加了一个碰撞避免CA功能" class="headerlink" title="802.11无线局域网使用CSMA&#x2F;CA协议，在CSMA的基础上增加了一个碰撞避免CA功能"></a>802.11无线局域网使用CSMA&#x2F;CA协议，在CSMA的基础上增加了一个碰撞避免CA功能</h4><h4 id="802-11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收"><a href="#802-11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收" class="headerlink" title="802.11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收"></a>802.11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收</h4><h4 id="802-11的MAC层标准定义了两种不同媒体的接入控制方式"><a href="#802-11的MAC层标准定义了两种不同媒体的接入控制方式" class="headerlink" title="802.11的MAC层标准定义了两种不同媒体的接入控制方式"></a>802.11的MAC层标准定义了两种不同媒体的接入控制方式</h4><p>​分布式协调功能DCF<br>​点协调功能PCF</p><h4 id="802-11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS"><a href="#802-11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS" class="headerlink" title="802.11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS"></a>802.11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS</h4><h5 id="常用帧间间隔"><a href="#常用帧间间隔" class="headerlink" title="常用帧间间隔"></a>常用帧间间隔</h5><p>​短帧间间隔SIFS(28微妙)<br>​DCF帧间间隔DIFS(128微秒)</p><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p>​当站点检测到信道使空闲，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法</p><h5 id="以下情况必须使用退避算法"><a href="#以下情况必须使用退避算法" class="headerlink" title="以下情况必须使用退避算法"></a>以下情况必须使用退避算法</h5><p>​在发送数据帧之前检测到信道处于忙状态时<br>​在每一次重传一个数据帧时<br>​在每一次成功发送后要连续发送下一个帧时（避免长时间占用信道）</p><h5 id="在执行退避算法时，站点为退避计时器设置一个随机的退避时间"><a href="#在执行退避算法时，站点为退避计时器设置一个随机的退避时间" class="headerlink" title="在执行退避算法时，站点为退避计时器设置一个随机的退避时间"></a>在执行退避算法时，站点为退避计时器设置一个随机的退避时间</h5><p>​当退避计时器的时间减小到零时，就开始发送数据<br>​当退避计时器的时间还未减小到零时而信道又转变为忙状态，则冻结计时器，等重新变为空闲，再经过时间DIFS后，继续启动退避计时器<br>​在进行第i次退避时，退避时间在时隙编号**{0, 1 , … , 2^(2+i) - 1 }<strong>中随机选择一个，然后乘以基本退避时间（一个时隙的长度）就可以得到随机的退避时间。当时隙编号到达</strong>255**时（对应于第6次退避）就不再增加了</p><h4 id="信道预约"><a href="#信道预约" class="headerlink" title="信道预约"></a>信道预约</h4><p>​源站在发送数据帧之前先发送一个短的控制帧，称为请求发送QTS,它包括源地址，目的地址以及这次通信（包括相应的确认帧）所需的持续时间<br>​若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS<br>​源站收到CTS后，等一段SIFS后，就可发送其数据帧<br>​若目的站正确收到源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK</p><h5 id="802-11规定了3中情况供用户选择"><a href="#802-11规定了3中情况供用户选择" class="headerlink" title="802.11规定了3中情况供用户选择"></a>802.11规定了3中情况供用户选择</h5><p>​使用RTS帧和CTS<br>​不使用RTS帧和CTS<br>​只有当数据帧长度超过某一数值时才使用RTS帧和CTS</p><h4 id="虚拟载波监听机制"><a href="#虚拟载波监听机制" class="headerlink" title="虚拟载波监听机制"></a>虚拟载波监听机制</h4><p>​除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要的时间</p><hr><h3 id="3-7MAC地址、IP地址、以及ARP协议"><a href="#3-7MAC地址、IP地址、以及ARP协议" class="headerlink" title="3.7MAC地址、IP地址、以及ARP协议"></a>3.7MAC地址、IP地址、以及ARP协议</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><h5 id="是以太网的MAC子层所使用的地址"><a href="#是以太网的MAC子层所使用的地址" class="headerlink" title="是以太网的MAC子层所使用的地址"></a>是以太网的MAC子层所使用的地址</h5><h5 id="每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media-Access-Control），所以这类地址被称为MAC地址"><a href="#每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media-Access-Control），所以这类地址被称为MAC地址" class="headerlink" title="每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media Access Control），所以这类地址被称为MAC地址"></a>每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media Access Control），所以这类地址被称为MAC地址</h5><h5 id="MAC地址也被称为硬件地址"><a href="#MAC地址也被称为硬件地址" class="headerlink" title="MAC地址也被称为硬件地址"></a>MAC地址也被称为硬件地址</h5><h5 id="是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识"><a href="#是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识" class="headerlink" title="是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识"></a>是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识</h5><h5 id="组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）"><a href="#组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）" class="headerlink" title="组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）"></a>组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）</h5><h6 id="第一字节b0比特"><a href="#第一字节b0比特" class="headerlink" title="第一字节b0比特"></a>第一字节b0比特</h6><p>​为1表示多播<br>​为0表示单播</p><h6 id="第一字节b1比特"><a href="#第一字节b1比特" class="headerlink" title="第一字节b1比特"></a>第一字节b1比特</h6><p>​为1表示本地管理<br>​剩余46位全为1时，就是广播地址FF-FF-FF-FF-FF-FF<br>​为0表示全球管理<br>​字节发送顺序：第一字节》》》第六字节<br>​字节内比特发送顺序：b0》》》b7</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><h5 id="是TCP-x2F-IP体系结构网际层所使用的地址"><a href="#是TCP-x2F-IP体系结构网际层所使用的地址" class="headerlink" title="是TCP&#x2F;IP体系结构网际层所使用的地址"></a>是TCP&#x2F;IP体系结构网际层所使用的地址</h5><h5 id="网络编号"><a href="#网络编号" class="headerlink" title="网络编号"></a>网络编号</h5><p>​标识因特网上数以百万计的网络</p><h5 id="主机编号"><a href="#主机编号" class="headerlink" title="主机编号"></a>主机编号</h5><p>​标识同一网络上不同主机（或路由器各接口）</p><h5 id="数据包转发过程中源IP地址和目的IP地址保持不变"><a href="#数据包转发过程中源IP地址和目的IP地址保持不变" class="headerlink" title="数据包转发过程中源IP地址和目的IP地址保持不变"></a>数据包转发过程中源IP地址和目的IP地址保持不变</h5><h5 id="数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变"><a href="#数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变" class="headerlink" title="数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变"></a>数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变</h5><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>​属于TCP&#x2F;IP体系结构网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址</p><h5 id="ARP高速缓存记录类型"><a href="#ARP高速缓存记录类型" class="headerlink" title="ARP高速缓存记录类型"></a>ARP高速缓存记录类型</h5><h6 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h6><p>​自动获取，生命周期默认为两分钟</p><h6 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h6><p>​手工设置，不同操作系统下的生命周期不同</p><hr><h3 id="3-8集线器与交换机的区别"><a href="#3-8集线器与交换机的区别" class="headerlink" title="3.8集线器与交换机的区别"></a>3.8集线器与交换机的区别</h3><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>​在以太网逻辑上仍然时一个总线网，使用CSMA&#x2F;CD协议<br>​只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）<br>​集线器一般都有少量的容错能力和网络管理能力</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>​通常都有多个接口<br>​一般工作在全双工方式<br>​能同时连通多对接口，无碰撞（不使用CSMA&#x2F;CD协议）<br>​工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧<br>​内部的帧交换表时通过自学习算法自动地逐渐建立起来</p><h5 id="帧两种转发方式"><a href="#帧两种转发方式" class="headerlink" title="帧两种转发方式"></a>帧两种转发方式</h5><p>​存储转发</p><p>​<strong>等待后续补充</strong></p><hr><h3 id="3-9以太网交换机自学习和转发帧的流程"><a href="#3-9以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9以太网交换机自学习和转发帧的流程"></a>3.9以太网交换机自学习和转发帧的流程</h3><h4 id="收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号"><a href="#收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号" class="headerlink" title="收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号"></a>收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号</h4><h4 id="根据帧的目的MAC地址和交换机的帧交换表对帧进行转发"><a href="#根据帧的目的MAC地址和交换机的帧交换表对帧进行转发" class="headerlink" title="根据帧的目的MAC地址和交换机的帧交换表对帧进行转发"></a>根据帧的目的MAC地址和交换机的帧交换表对帧进行转发</h4><h5 id="明确转发"><a href="#明确转发" class="headerlink" title="明确转发"></a>明确转发</h5><p>​交换机知道应当从哪个接口转发该帧（单播、多播、广播）</p><h5 id="盲目转发"><a href="#盲目转发" class="headerlink" title="盲目转发"></a>盲目转发</h5><p>​交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</p><h5 id="明确丢弃"><a href="#明确丢弃" class="headerlink" title="明确丢弃"></a>明确丢弃</h5><p>​交换机知道不应该转发该帧，将其丢弃</p><h4 id="帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下"><a href="#帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下" class="headerlink" title="帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下"></a>帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下</h4><p>​交换机的接口改接了另一台主机<br>​<strong>等待后续补充</strong></p><hr><h3 id="3-10以太网交换机的生成树协议STP"><a href="#3-10以太网交换机的生成树协议STP" class="headerlink" title="3.10以太网交换机的生成树协议STP"></a>3.10以太网交换机的生成树协议STP</h3><h4 id="添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路"><a href="#添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路" class="headerlink" title="添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路"></a>添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路</h4><h5 id="网络环路会带来的问题"><a href="#网络环路会带来的问题" class="headerlink" title="网络环路会带来的问题"></a>网络环路会带来的问题</h5><h6 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h6><p>​大量消耗网络资源，使得网络无法正常转发其他数据帧</p><h6 id="主机收到重复的广播帧"><a href="#主机收到重复的广播帧" class="headerlink" title="主机收到重复的广播帧"></a>主机收到重复的广播帧</h6><p>​大量消耗主机资源</p><h6 id="交换机的帧交换表震荡（漂移）"><a href="#交换机的帧交换表震荡（漂移）" class="headerlink" title="交换机的帧交换表震荡（漂移）"></a>交换机的帧交换表震荡（漂移）</h6><p>​交换机使用生成树协议STP，可以在增加冗余链路提高网络可靠性的同时又避免网络环路带来的各种问题<br>​交换机都能够自动计算并构建出一个逻辑上没有环路的网络，其逻辑拓扑结构必须时树形（无逻辑环路）<br>​最终生成的树形逻辑拓扑要确保连通整个网络<br>​当首次连接交换机或网络物理拓扑发生变化时（有可能时人为改变或故障），交换机都将进行生成树的重新计算</p><hr><h3 id="3-11虚拟局域网VLAN"><a href="#3-11虚拟局域网VLAN" class="headerlink" title="3.11虚拟局域网VLAN"></a>3.11虚拟局域网VLAN</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="网络中会频烦出现广播信息"><a href="#网络中会频烦出现广播信息" class="headerlink" title="网络中会频烦出现广播信息"></a>网络中会频烦出现广播信息</h5><p>​地址解析协议ARP<br>​路由信息协议RIP<br>​动态主机配置协议DHCP<br>​NetBEUI<br>​IPX&#x2F;SPX<br>​Apple Talk</p><h5 id="分割广播域方法"><a href="#分割广播域方法" class="headerlink" title="分割广播域方法"></a>分割广播域方法</h5><h6 id="使用路由器（成本较高）"><a href="#使用路由器（成本较高）" class="headerlink" title="使用路由器（成本较高）"></a>使用路由器（成本较高）</h6><h6 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h6><p>​是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</p><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><h5 id="IEEE-802-1Q帧（也称Dot-One-Q帧）"><a href="#IEEE-802-1Q帧（也称Dot-One-Q帧）" class="headerlink" title="IEEE 802.1Q帧（也称Dot One Q帧）"></a>IEEE 802.1Q帧（也称Dot One Q帧）</h5><h6 id="对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记"><a href="#对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记" class="headerlink" title="对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记"></a>对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记</h6><h6 id="VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN"><a href="#VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN" class="headerlink" title="VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN"></a>VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN</h6><p>​VID取值范围0<del>4095（0</del>2^12-1）<br>​0和4095都不用来表示VLAN，因此用于表示VLAN的VID的有效取值范围是1~4094</p><h6 id="IEEE-802-1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE-802-1Q帧"><a href="#IEEE-802-1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE-802-1Q帧" class="headerlink" title="IEEE 802.1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE 802.1Q帧"></a>IEEE 802.1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE 802.1Q帧</h6><p>​当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称“打标签”<br>​当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称“去标签”</p><h5 id="交换机的端口类型"><a href="#交换机的端口类型" class="headerlink" title="交换机的端口类型"></a>交换机的端口类型</h5><h6 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h6><p>​一般用于连接用户计算机<br>​只能属于一个VLAN<br>​PVID值与端口所属VLAN的ID相同（默认为1）<br>​接收处理方法<br>​一般只接收“未打标签”的普通以太网MAC帧。根据接收帧的端口PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等<br>​发送处理方法<br>​若帧中的VID与端口的PVID相等，则“去标签”并转发该帧；否则不转发。</p><h6 id="Trunk"><a href="#Trunk" class="headerlink" title="Trunk"></a>Trunk</h6><p>​一般用于交换机之间或交换机与路由器之间的互连<br>​可以属于多个VLAN<br>​用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1<br>​接收处理方法<br>​对VID等于PVID的帧，“去标签”再转发<br>​对VID不等于PVID的帧，直接转发<br>​发送处理方法<br>​接收“未打标签”的帧，根据接收帧的端口的PVID帧给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等<br>​接收“已打标签的帧”</p><h6 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h6><p>​绝大部分与Trunk端口相同<br>​端口发送处理方法（与Trunk不同）<br>​查看帧的VID是否再端口的“去标签”列表中<br>​存在<br>​“去标签”后转发<br>​不存在<br>​若不存在，则直接转发</p><h5 id="交换机各端口的缺省VLAN-ID"><a href="#交换机各端口的缺省VLAN-ID" class="headerlink" title="交换机各端口的缺省VLAN ID"></a>交换机各端口的缺省VLAN ID</h5><p>​思科交换机上称为Native VLAN，即本征VLAN<br>​华为交换机上称为Port VLAN ID，简称为PVID</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2022/04/12/vuex/"/>
      <url>/2022/04/12/vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="Vuex工作原理"><a href="#Vuex工作原理" class="headerlink" title="Vuex工作原理"></a>Vuex工作原理</h3><img src="/2022/04/12/vuex/vuex.png" class=""><h4 id="Vuex三个重要工作区域"><a href="#Vuex三个重要工作区域" class="headerlink" title="Vuex三个重要工作区域"></a>Vuex三个重要工作区域</h4><h5 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a><code>Actions</code></h5><p>​在<code>Vue Components</code>调用<code>dispatch()</code>要至少传两个传输，第一个参数为<code>object</code>对象，为在Actions中想要调用的函数名称，第二个参数为想要传递的数据。逻辑运算由Actions来进行，可以减少代码的冗余和增加复用性。在Actions可以调用后端接口或发ajax请求等操作，可以处理业务逻辑。在Actions获得的第一个参数为<code>context</code>可以在<code>context</code>调用<code>commit</code>等方法。<strong>尽量不要在Actions修改state中数据，Devtools捕捉不到行为</strong></p><h5 id="Mutations（方法名一般为大写，方便与Actions区分）"><a href="#Mutations（方法名一般为大写，方便与Actions区分）" class="headerlink" title="Mutations（方法名一般为大写，方便与Actions区分）"></a><code>Mutations</code>（方法名一般为大写，方便与Actions区分）</h5><p>​在<code>Vue Components</code>或<code>Actinos</code>中调用<code>commit()</code>要至少传两个传输，第一个参数为<code>object</code>对象，为在Mutations中想要调用的函数名称，第二个参数为想要传递的数据。此时Mutations所要调用的第一个值为整个<code>state</code>，第二个则为传递过来的数据，在Mutations中调用state里的参数会自动进行调用<code>Mutate</code>函数将State数据进行变换。<strong>函数内部需要return</strong></p><h5 id="State"><a href="#State" class="headerlink" title="State"></a><code>State</code></h5><p>​state主要存放数据，State中数据改变Vuex会主动调用<code>Render</code>对组件重新进行渲染。</p><h4 id="其他配置项"><a href="#其他配置项" class="headerlink" title="其他配置项"></a>其他配置项</h4><h5 id="getters"><a href="#getters" class="headerlink" title="getters"></a><code>getters</code></h5><p>类似于vue中的<code>computed</code>属性，在<code>getters</code>中调用时可以获取到<code>state</code>中的相关数据。适合逻辑复杂并且需要复用的数据。</p><h5 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a><code>mapState</code></h5><p>可以直接从<code>state</code>中拿数据，增加效率，一般以扩展运算符<code>...</code>形式放在computed中</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的computed调用</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//注册完毕后可以直接使用插值语法</span><span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//对象写法,因为后方必须带引号无法使用对象简写方式</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法，生成的计算属性名和读取的数据名一致</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a><code>mapGetters</code></h5><p>同上，可以直接从<code>getters</code>中拿数据，增加效率，一般以扩展运算符<code>...</code>形式放在computed中</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的computed调用</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapGetters<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//注册完毕后可以直接使用插值语法</span><span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//对象写法,因为后方必须带引号无法使用对象简写方式</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法，生成的计算属性名和读取的数据名一致</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a><code>mapMutations</code></h5><p>可以不用自己在方法中使用<code>commit</code>来调用<code>Actions</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的methods调用,调用的时候需要传参，要是没有传参会传所触发的事件事件</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapMutations<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//接入mapMutations生成对应方法，方法中会调用commit去联系Mutations</span>    <span class="token comment">//对象写法</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a><code>mapActions</code></h5><p>可以不用自己在方法中使用<code>commit</code>来调用<code>Actions</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的methods调用,调用的时候需要传参，要是没有传参会传所触发的事件事件</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapActions<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//接入mapActions生成对应方法，方法中会调用dispatch去联系mapActions</span>    <span class="token comment">//对象写法</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h4 id="Vuex工作环境-Vue2版本"><a href="#Vuex工作环境-Vue2版本" class="headerlink" title="Vuex工作环境(Vue2版本)"></a>Vuex工作环境(Vue2版本)</h4><p>目前使用<code>npm i vuex</code>安装的是Vue3版本的Vuex</p><p>使用<code>npm i vuex@3</code>才能安装Vue2版本的Vuex</p><p>安装完成后在根目录创建<code>store</code>文件夹，并创建<code>index.js</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//该文件用于创建Vuex最为核心的store</span><span class="token comment">//引入Vue</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//使用Vuex</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token comment">//准备actions  用于相应组件中的动作</span><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//准备mutations  用于操作数据</span><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//准备state 用于存储数据</span><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//准备getters  用于将state中的数据进行加工</span><span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建store</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    actions<span class="token punctuation">,</span>    mutations<span class="token punctuation">,</span>    state<span class="token punctuation">,</span>    getters<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> store</code></pre><p><strong>注意：import语句会优先执行，Vue.use(Vuex)在main.js中使用会报错</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在vue-cli根目录的main.js中引入Vuex，这样可以全局使用vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//引入store</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>    <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">,</span>    store<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="Vux模块化"><a href="#Vux模块化" class="headerlink" title="Vux模块化"></a>Vux模块化</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//该文件用于创建Vuex最为核心的store</span><span class="token comment">//引入Vue</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//使用Vuex</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token comment">//将功能进行模块化封装，可以封装在其他js文件中</span><span class="token keyword">const</span> example1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//想要直接读取数据需要开启命名空间，默认为false</span>    <span class="token literal-property property">namespaced</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">actions</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">state</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">getters</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">mutations</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> example2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//想要直接读取数据需要开启命名空间，默认为false</span>    <span class="token literal-property property">namespaced</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">actions</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">state</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">getters</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">mutations</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建store</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">modules</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token comment">//在store.state会存放除getters外的方法</span>        example1<span class="token punctuation">,</span>        example2    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> store</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_物理层</title>
      <link href="/2022/04/12/wu-li-ceng/"/>
      <url>/2022/04/12/wu-li-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="2-1物理层的基本概念"><a href="#2-1物理层的基本概念" class="headerlink" title="2.1物理层的基本概念"></a>2.1物理层的基本概念</h3><h4 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h4><h5 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h5><p>​双绞线<br>​同轴电缆<br>​光纤</p><h5 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h5><p>​微波通信<br>​2~40GHz</p><h4 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h4><p>​机械特性<br>​电器特性<br>​功能特性<br>​过程特性</p><h4 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h4><p>​物理层考虑是怎样才能在连接各种计算机的传输媒体上传输数据比特流</p><p>​物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务</p><hr><h3 id="2-2物理层下的传输媒体"><a href="#2-2物理层下的传输媒体" class="headerlink" title="2.2物理层下的传输媒体"></a>2.2物理层下的传输媒体</h3><h4 id="导引型传输媒体-1"><a href="#导引型传输媒体-1" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><h6 id="基带同轴电缆（50Ω）"><a href="#基带同轴电缆（50Ω）" class="headerlink" title="基带同轴电缆（50Ω）"></a>基带同轴电缆（50Ω）</h6><p>​数字传输，过去用于局域网</p><h6 id="宽带同轴电缆（75Ω）"><a href="#宽带同轴电缆（75Ω）" class="headerlink" title="宽带同轴电缆（75Ω）"></a>宽带同轴电缆（75Ω）</h6><p>​模拟传输，目前主要用于有线电视</p><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><h6 id="无屏蔽双绞线UTP"><a href="#无屏蔽双绞线UTP" class="headerlink" title="无屏蔽双绞线UTP"></a>无屏蔽双绞线UTP</h6><h6 id="屏蔽双绞线STP"><a href="#屏蔽双绞线STP" class="headerlink" title="屏蔽双绞线STP"></a>屏蔽双绞线STP</h6><h6 id="绞合的作用"><a href="#绞合的作用" class="headerlink" title="绞合的作用"></a>绞合的作用</h6><p>​抵御部分来自外界的电磁波干扰<br>​减少相邻导线的电磁干扰</p><h5 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>​通信容量大（25000~30000GHz的带宽）<br>​传输损耗小，远距离传输时更加经济<br>​抗雷电和电磁干扰性能好<br>​无串音干扰，保密性好，不易被窃听<br>​体积小，重量轻<br>​电力线</p><h5 id="非导引型传输媒体-1"><a href="#非导引型传输媒体-1" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h5><p>​无线电波<br>​微波<br>​红外线<br>​可见光</p><hr><h3 id="2-3传输方式"><a href="#2-3传输方式" class="headerlink" title="2.3传输方式"></a>2.3传输方式</h3><h4 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h4><h4 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h4><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><h5 id="外同步"><a href="#外同步" class="headerlink" title="外同步"></a>外同步</h5><p>​在收发双方之间添加一条单独的时钟信号线</p><h5 id="内同步"><a href="#内同步" class="headerlink" title="内同步"></a>内同步</h5><p>​发送端将时钟同步信号编码到发送数据中一起传输</p><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><p>​字节之间异步<br>​字节中的每个比特仍然要同步</p><h4 id="单向通信（单工）"><a href="#单向通信（单工）" class="headerlink" title="单向通信（单工）"></a>单向通信（单工）</h4><h4 id="双向交替通信（半双工）"><a href="#双向交替通信（半双工）" class="headerlink" title="双向交替通信（半双工）"></a>双向交替通信（半双工）</h4><h4 id="双向同时通信（全双工）"><a href="#双向同时通信（全双工）" class="headerlink" title="双向同时通信（全双工）"></a>双向同时通信（全双工）</h4><hr><h3 id="2-4编码与调制"><a href="#2-4编码与调制" class="headerlink" title="2.4编码与调制"></a>2.4编码与调制</h3><h4 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h4><p>​在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p><h4 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h4><h5 id="不归零编码"><a href="#不归零编码" class="headerlink" title="不归零编码"></a>不归零编码</h5><p>​存在同步问题</p><h5 id="归零编码"><a href="#归零编码" class="headerlink" title="归零编码"></a>归零编码</h5><p>​自同步，编码效率低</p><h5 id="曼切斯特编码"><a href="#曼切斯特编码" class="headerlink" title="曼切斯特编码"></a>曼切斯特编码</h5><h5 id="差分曼切斯特编码"><a href="#差分曼切斯特编码" class="headerlink" title="差分曼切斯特编码"></a>差分曼切斯特编码</h5><hr><h3 id="2-5信道的极限容量"><a href="#2-5信道的极限容量" class="headerlink" title="2.5信道的极限容量"></a>2.5信道的极限容量</h3><h4 id="造成信号失真的因素"><a href="#造成信号失真的因素" class="headerlink" title="造成信号失真的因素"></a>造成信号失真的因素</h4><p>​码元传输速率<br>​信号传输距离<br>​噪声干扰<br>​传输媒体质量</p><h4 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h4><h5 id="理想低通信道的最高码元传输速率"><a href="#理想低通信道的最高码元传输速率" class="headerlink" title="理想低通信道的最高码元传输速率"></a>理想低通信道的最高码元传输速率</h5><h5 id="理想带通信道的最高码元传输速率"><a href="#理想带通信道的最高码元传输速率" class="headerlink" title="理想带通信道的最高码元传输速率"></a>理想带通信道的最高码元传输速率</h5><h5 id="波特率与比特率的关系"><a href="#波特率与比特率的关系" class="headerlink" title="波特率与比特率的关系"></a>波特率与比特率的关系</h5><p>$$<br>码元传输速率又成为波特率，调制速率、波形速率或符号速率。它与比特率有一定的关系。\\<br>当1个码元只携带1比特的信息量时，波特率（码元&#x2F;秒）与比特率（比特&#x2F;秒）在数值上相等\\<br>当1个码元携带n个比特的信息量时，数值则乘以n\\<br>$$</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>​实际的通信所能传输的最高码元速率，要明显低于奈氏准则给出的上限值</p><h4 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h4><p>​信道的极限信息传输速率<br>$$<br>c&#x3D; W \cdot  \log_2(1+\frac{S}{N} )\\<br>c:信道的极限信息传输速率（单位为b&#x2F;s）\\<br>W: 信道带宽（Hz）\\<br>S: 信道内所传输信号的平均功率\\<br>N: 信道内的高斯噪声功率\\<br>\frac{S}{N}: 信噪比，使用分贝（dB）作为度量单位。\\<br>信噪比（dB） &#x3D; 10 \cdot \log_{10}(\frac{S}{N})\\<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因特网概述</title>
      <link href="/2022/04/11/yin-te-wang-gai-shu/"/>
      <url>/2022/04/11/yin-te-wang-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-1因特网概述："><a href="#1-1因特网概述：" class="headerlink" title="1.1因特网概述："></a>1.1因特网概述：</h3><h4 id="因特网发展的三个阶段："><a href="#因特网发展的三个阶段：" class="headerlink" title="因特网发展的三个阶段："></a>因特网发展的三个阶段：</h4><p>1969年：从单个网络ARPANET向互联网发展</p><p>1985年：逐步建成三级结构的因特网</p><p>1993年：逐步形成了多层次ISP（internet service provider）结构的因特网</p><h5 id="国内三大提供商（第43次统计报告）总共出口宽带数"><a href="#国内三大提供商（第43次统计报告）总共出口宽带数" class="headerlink" title="国内三大提供商（第43次统计报告）总共出口宽带数"></a>国内三大提供商（第43次统计报告）总共出口宽带数</h5><p>中国电信国际出口宽带数：4537680（Mbps）</p><p>中国联通国际出口宽带数：2234738(Mbps)</p><p>中国移动国际出口宽带数：1997000(Mbps)</p><h4 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h4><h5 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h5><p>由所有连接在因特网上的主机组成（包括但不仅限于下几个）</p><ol><li>电脑</li><li>手机</li><li>平板</li><li>笔记本</li></ol><h5 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h5><p>由大量网络和连接这些网络的路由器组成，为边缘部分提供服务（包括但不仅限于下几个）<br>    1.路由器<br>    2.大量网络</p><hr><h3 id="1-2三种交换方式"><a href="#1-2三种交换方式" class="headerlink" title="1.2三种交换方式"></a>1.2三种交换方式</h3><h4 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h4><h5 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h5><p>​建立连接（分配通信资源）<br>​通信（一直占用通信资源）<br>​释放连接（归还通信资源）</p><h5 id="比特流直达终点"><a href="#比特流直达终点" class="headerlink" title="比特流直达终点"></a>比特流直达终点</h5><h5 id="电路交换的优点："><a href="#电路交换的优点：" class="headerlink" title="电路交换的优点："></a>电路交换的优点：</h5><p>​通信时延小<br>​有序传输<br>​没有冲突<br>​适用范围广<br>​实时性强<br>​控制简单</p><h5 id="电路交换的缺点："><a href="#电路交换的缺点：" class="headerlink" title="电路交换的缺点："></a>电路交换的缺点：</h5><p>​建立连接时间长<br>​线路独占，使用效率低<br>​灵活性差<br>​难以规格化</p><h4 id="分组交换（Packet-Switch）"><a href="#分组交换（Packet-Switch）" class="headerlink" title="分组交换（Packet Switch）"></a>分组交换（Packet Switch）</h4><h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5><p>​构造分组<br>​发送分组</p><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><p>​缓存分组<br>​转发分组</p><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><p>​接受分组<br>​还原报文</p><h5 id="报文前加上首部（简称包）"><a href="#报文前加上首部（简称包）" class="headerlink" title="报文前加上首部（简称包）"></a>报文前加上首部（简称包）</h5><p>​整个报文存储转发</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>​无需建立连接<br>​线路利用率高<br>​简化了存储管理<br>​加速传输<br>​减少出错概率和重发数据量</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>​引起了转发时延<br>​需要传输额外的信息量<br>​对于数据报服务，存在失序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</p><h4 id="报文交换（Message-Switching）"><a href="#报文交换（Message-Switching）" class="headerlink" title="报文交换（Message Switching）"></a>报文交换（Message Switching）</h4><h5 id="报文进行分组并前加上首部"><a href="#报文进行分组并前加上首部" class="headerlink" title="报文进行分组并前加上首部"></a>报文进行分组并前加上首部</h5><p>​分组存储转发</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>​无需建立连接<br>​动态分配线路<br>​提高线路可靠性<br>​提高线路利用率<br>​提供多目标服务</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>​引起了转发时延<br>​需要较大存储缓存空间<br>​需要传输额外的信息量</p><hr><h3 id="1-3计算机网络的分类"><a href="#1-3计算机网络的分类" class="headerlink" title="1.3计算机网络的分类"></a>1.3计算机网络的分类</h3><h4 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h4><p>​电路交换网络<br>​报文交换网络<br>​分组交换网络</p><h4 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h4><p>​公用网<br>​专用网</p><h4 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h4><p>​有线网络<br>​无线网络</p><h4 id="按覆盖范围分类"><a href="#按覆盖范围分类" class="headerlink" title="按覆盖范围分类"></a>按覆盖范围分类</h4><h5 id="广域网WAN"><a href="#广域网WAN" class="headerlink" title="广域网WAN"></a>广域网WAN</h5><p>​覆盖范围几十公里到几千公里</p><h5 id="城域网MAN"><a href="#城域网MAN" class="headerlink" title="城域网MAN"></a>城域网MAN</h5><p>​覆盖范围5至50公里</p><h5 id="局域网LAN"><a href="#局域网LAN" class="headerlink" title="局域网LAN"></a>局域网LAN</h5><p>​在较小的范围内（如实验室、教学楼）</p><h5 id="个域网PAN"><a href="#个域网PAN" class="headerlink" title="个域网PAN"></a>个域网PAN</h5><p>​覆盖范围大约为10米</p><h4 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h4><h5 id="总线型网络"><a href="#总线型网络" class="headerlink" title="总线型网络"></a>总线型网络</h5><h6 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h6><p>​建网容易<br>​增减结点方便<br>​节省线路</p><h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><p>​重负载时通信效率不高<br>​总线任意一处出现故障，则全网瘫痪</p><h5 id="星型网络"><a href="#星型网络" class="headerlink" title="星型网络"></a>星型网络</h5><h6 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h6><p>​便于网络的集中控制和管理</p><h6 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h6><p>​成本高，中央设备对故障敏感</p><h5 id="环型网络"><a href="#环型网络" class="headerlink" title="环型网络"></a>环型网络</h5><p>​环中信号是单向传输</p><h5 id="网状型网络"><a href="#网状型网络" class="headerlink" title="网状型网络"></a>网状型网络</h5><h6 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h6><p>​可靠性高</p><h6 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h6><p>​控制复杂、线路成本高</p><hr><h3 id="1-4性能指标"><a href="#1-4性能指标" class="headerlink" title="1.4性能指标"></a>1.4性能指标</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><h5 id="比特"><a href="#比特" class="headerlink" title="比特"></a>比特</h5><p>是计算机中的数据量单位</p><p>​<br>$$<br>8bit &#x3D; 1Byte\\<br>            1KB &#x3D; 2^{10}B\\<br>            1MB &#x3D; K×KB &#x3D; 2^{20}B\\<br>            1GB &#x3D; K×MB &#x3D; 2^{30}B\\<br>            1TB &#x3D; K×GB &#x3D; 2^{40}B\\<br>            厂家中的1GB为10^9<br>$$</p><h5 id="速率-1"><a href="#速率-1" class="headerlink" title="速率"></a>速率</h5><p>是连接在计算机网络上的主机在数字信道上传送比特的速率，也成为比特率或数据率</p><p>​<br>$$ {速率}<br>1bit&#x2F;s\\<br>            1kb&#x2F;s &#x3D; 10^3 b&#x2F;s\\<br>            1Mb&#x2F;s &#x3D; k×kb&#x2F;s &#x3D; 10^6 b&#x2F;s\<br>            1Gb&#x2F;s &#x3D; k×Mb&#x2F;s &#x3D; 10^9 b&#x2F;s\\<br>            1Tb&#x2F;s &#x3D; k×Gb&#x2F;s &#x3D; 10^{12} b&#x2F;s\\<br>$$</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><h5 id="模拟信号系统中的意义"><a href="#模拟信号系统中的意义" class="headerlink" title="模拟信号系统中的意义"></a>模拟信号系统中的意义</h5><p>​信号所包含的各种不同频率成分所占据的频率范围<br>​<br>$$<br>kHz\\<br>                MHz\\<br>                GHz\\<br>$$</p><h5 id="计算机网络中的意义"><a href="#计算机网络中的意义" class="headerlink" title="计算机网络中的意义"></a>计算机网络中的意义</h5><p>​表示网络的通信线路所能传送数据的能力<br>$$<br>kb&#x2F;s<br>                Mb&#x2F;s<br>                Gb&#x2F;s<br>$$</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>​表示在单位时间内通过某个网络（或信道、接口）的数据量<br>​吞吐量受网络的带宽或额定速率的限制</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><h5 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h5><p>​分组长度（b）&#x2F;发送速率（b&#x2F;s）</p><h5 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h5><p>​<br>$$<br>        信道长度（m）&#x2F;电磁波传播速率（m&#x2F;s）\\<br>                自由空间:<br>                    3×10^8 m&#x2F;s\\<br>                铜线:<br>                    2.3×10^8 m&#x2F;s\\<br>                光纤:<br>                    2.0×10^8 m&#x2F;s\\<br>$$</p><h5 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h5><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>​<br>$$<br>    传播时延×带宽<br>$$</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>​源主机收到目的主机的确认需要的时间</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>​<br>$$<br>                        信道利用率\\<br>                        网络利用率\\<br>        网络当前的时延 &#x3D; 网络空闲时的时延 &#x2F; (1 - 利用率)\\<br>$$</p><h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><hr><h3 id="1-5计算机网络体系结构"><a href="#1-5计算机网络体系结构" class="headerlink" title="1.5计算机网络体系结构"></a>1.5计算机网络体系结构</h3><h4 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h4><h5 id="OSI体系结构"><a href="#OSI体系结构" class="headerlink" title="OSI体系结构"></a>OSI体系结构</h5><p>​应用层<br>​表示层<br>​会话层<br>​运输层<br>​网络层<br>​数据链路层<br>​物理层</p><h5 id="TCP-x2F-IP体系结构"><a href="#TCP-x2F-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h5><h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p>​HTTP协议<br>​SMTP协议<br>​DNS协议<br>​RTP协议<br>​等等</p><h6 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h6><p>​TCP协议<br>​UDP协议</p><h6 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h6><p>​IP协议<br>​网络接口层</p><h5 id="原理体系结构"><a href="#原理体系结构" class="headerlink" title="原理体系结构"></a>原理体系结构</h5><p>​应用层<br>​运输层<br>​网络层<br>​数据链路层<br>​物理层</p><h4 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h4><h5 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h5><p>​通过应用进程间的交互来完成特定的网络应用</p><h5 id="运输层-1"><a href="#运输层-1" class="headerlink" title="运输层"></a>运输层</h5><p>​如何解决进程之间基于网络的通信问题<br>​出现传输错误时，如何处理</p><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>​如何标识各网络以及网络中的各主机<br>​路由器如何转发分组，如何进行路由选择</p><h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>​如何标识网络中的各主机<br>​如何从信号所表示的一串比特流中区分出地址和数据<br>​如何协调各主机争用总线</p><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>​使用怎样的信号表示比特0和1</p><h4 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h4><h5 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h5><p>​应用层<br>​HTTP报文<br>​运输层<br>​HTTP TCP报文段<br>​网络层<br>​HTTP TCP IP数据报<br>​数据链路层<br>​ETH HTTP TCP IP ETH帧<br>​物理层<br>​比特流</p><h5 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h5><p>​网络层<br>​HTTP TCP IP数据报<br>​数据链路层<br>​ETH HTTP TCP IP ETH帧<br>​物理层<br>​比特流</p><h5 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h5><p>​发送端同理，发送端自顶向下，接收端逐步解析</p><h4 id="计算机网络体系结构结构的专用术语"><a href="#计算机网络体系结构结构的专用术语" class="headerlink" title="计算机网络体系结构结构的专用术语"></a>计算机网络体系结构结构的专用术语</h4><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>​任何可发送或接受信息的硬件或软件进程</p><h5 id="协议（水平）"><a href="#协议（水平）" class="headerlink" title="协议（水平）"></a>协议（水平）</h5><p>​语法<br>​定义所交换信息的格式<br>​语义<br>​定义收发双方要完成的操作<br>​同步<br>​定义收发双方的时序关系</p><h5 id="服务（垂直）"><a href="#服务（垂直）" class="headerlink" title="服务（垂直）"></a>服务（垂直）</h5><p>​下面的协议对上面的实体时透明的</p><h5 id="协议数据单元PDU"><a href="#协议数据单元PDU" class="headerlink" title="协议数据单元PDU"></a>协议数据单元PDU</h5><p>​对等层次之间传送的数据包</p><h5 id="服务数据单元SDU"><a href="#服务数据单元SDU" class="headerlink" title="服务数据单元SDU"></a>服务数据单元SDU</h5><p>​同一系统内，层与层之间交换的数据包</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建与应用主题</title>
      <link href="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/"/>
      <url>/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h3><p>1.<strong><a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></strong>(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</p><p>2.<strong><a href="http://git-scm.com/">Git (git-scm.com)</a></strong></p><p>3.<strong>淘宝镜像（非必要）</strong><code>npm config set registry https://registry.npm.taobao.org</code> </p><p>​用了淘宝镜像可以更快下载资源包。</p><p>​使用<code>npm config get registry</code>来查看是否配置完成。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/config.png" class=""><p>​显示地址说明配置完成。</p><p>4.安装hexo</p><p><a href="https://hexo.io/zh-cn/">Hexo</a>官网地址(更详细的安装配置等可以看官方文档)</p><p>使用<code>npm install hexo-cli -g</code>可将hexo全局配置。</p><p>使用<code>npx hexo</code>可以来查看hexo是否安装成功。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexoC.png" class=""><p>出现相关命令则安装成功。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="hexo初始化"><a href="#hexo初始化" class="headerlink" title="hexo初始化"></a>hexo初始化</h3><p>到任意磁盘位置创建一个文件夹并打开cmd使用<code>hexo init</code>命令对目标文件夹初始化（这里以D:\blog为例）</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexoI.png" class=""><p>检查文件夹是否有以下几种文件：</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexodocument.png" class=""><p>没有报错则初始化成功。(如果有问题大部分是node.js版本或git未安装导致)</p><p>在控制台使用<code>hexo s</code>可以在本地查看blog效果如何，如果有页面显示说明已成功安装了hexo。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexos.png" class=""><p>在cmd页面使用<code>ctrl+c</code>可以结束本地端口运行。</p><h3 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h3><p>这里主要先搭建github仓库远程上传代码，先在git将仓库建好。</p><p>进入github首页点右上角<code>sign in</code>登录，然后在<code>Repositories</code>中new一个新仓库</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/githubr.png" class=""><p>Repository name 以自己的<code>github账号名.github.io</code>来命名，没有其他要求点击<code>create respository</code>创建仓库即可。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/githubpath.png" class=""><p>将自己仓库的HTTPS地址复制下来（因为我已经建过blog仓库这里就没以<code>github账号名.github.io</code>来命名了，可以看上一张图的第一个仓库来作为参考）</p><p><strong>仓库建完成后在cmd中使用<code>npm install hexo-deployer-git --save</code>来安装插件。</strong></p><p>然后<strong>相关配置</strong>需要打开<code>_config.yml</code>文件，详细信息需要看文档进行配置。</p><p>这里先配置<code>Deployment</code>（位置在最底下）</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexodeploy.png" class=""><p><code>repo</code>放刚刚复制的github仓库地址，保存后在自己文件夹cmd使用<code>hexo clean</code>清除缓存文件（<code>db.json</code>）和已生成静态文件（<code>public</code>），后使用<code>hexo g</code>生成静态文件。（最好在每次上传仓库前重复以上两个步骤）</p><p>然后<code>hexo d</code>来将本地部署到github中</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexode.png" class=""><p>出现自己github仓库地址后，刷新网页。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/gitweb.png" class=""><p>出现文件说明上传成功，可以通过标蓝的地址名来进行线上访问（不过由于在国内有时候会访问不上，可以Netlify等网络托管平台来进行布置）</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/gitwebsee.png" class=""><p>（这里我是以我原先布置的blog来进行展示）</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/web.png" class=""><p>看来类似这个页面就是已经部署成功了。</p><h3 id="配置主题-这里以matery主题为例"><a href="#配置主题-这里以matery主题为例" class="headerlink" title="配置主题(这里以matery主题为例)"></a>配置主题(这里以matery主题为例)</h3><p>在自己blog文件夹的themes路径下下输入<code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code>从github上clone项目到themes文件夹中</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexocp.png" class=""><p>主题配置在源文件夹<code>_config.yml</code>文件的theme中。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexods.png" class=""><p>将<code>landscape</code>替换成要更换的主题，即<code>hexo-theme-matery</code></p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/changeTheme.png" class=""><p>然后在cmd使用<code>hexo s</code>来进行本地查看是否生效</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/themesee.png" class=""><p>发现页面更换了就说明已经使用了主题，相关更多的配置可以在<code>hexo-theme-matery</code>的作者文档中进行查看，也可以去源作者<a href="https://github.com/blinkfox/hexo-theme-matery">blinkfox</a>中了解更多！</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
