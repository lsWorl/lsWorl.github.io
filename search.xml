<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript的基础</title>
      <link href="/2022/04/24/javascript-de-ji-zhi/"/>
      <url>/2022/04/24/javascript-de-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h4 id="javascript的数据类型："><a href="#javascript的数据类型：" class="headerlink" title="javascript的数据类型："></a><code>javascript</code>的数据类型：</h4><img src="/2022/04/24/javascript-de-ji-zhi/dataType.png" class=""><h5 id="使用typeof来判断数据类型"><a href="#使用typeof来判断数据类型" class="headerlink" title="使用typeof来判断数据类型"></a>使用<code>typeof</code>来判断数据类型</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">'字符串'</span><span class="token punctuation">)</span><span class="token comment">//输出 string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token comment">//输出 number</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment">//输出 boolean</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//输出 object null输出object是历史遗留问题</span><span class="token keyword">let</span> aconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token comment">//输出 undefined</span><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> s<span class="token punctuation">)</span><span class="token comment">//输出 symbol</span><span class="token keyword">const</span> bigInt <span class="token operator">=</span> <span class="token number">132n</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bigInt<span class="token punctuation">)</span><span class="token comment">//输出 bigint</span><span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'函数'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> fn<span class="token punctuation">)</span><span class="token comment">//输出 function</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> arr<span class="token punctuation">)</span><span class="token comment">//输出 object</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">)</span><span class="token comment">//输出 object</span></code></pre><h5 id="使用instanceof判断对象是否相等"><a href="#使用instanceof判断对象是否相等" class="headerlink" title="使用instanceof判断对象是否相等"></a>使用<code>instanceof</code>判断对象是否相等</h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">Fn</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token comment">//返回true 因为所有函数的原型链上都有Object方法</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token comment">//返回true</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的基本使用</title>
      <link href="/2022/04/21/shen-ru-jie-xi-axios/"/>
      <url>/2022/04/21/shen-ru-jie-xi-axios/</url>
      
        <content type="html"><![CDATA[<p><strong>本文的后台数据通过<code>json-server</code>来模拟，对<code>json-server</code>感兴趣可以去看<a href="https://github.com/typicode">typicode</a>的github源网站</strong></p><h4 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h4><p>在<code>axios</code>的作者<a href="https://github.com/axios/axios/commits?author=jasonsaayman">jasonsaayman</a>可以看到<code>axios</code>的几种引入方式</p><pre class="language-none"><code class="language-none">Using npm:$ npm install axiosUsing bower:$ bower install axiosUsing yarn:$ yarn add axiosUsing jsDelivr CDN:&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;Using unpkg CDN:&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p><strong>这里以<code>script</code>方式引入来进行介绍</strong></p><h5 id="使用axios-方法来发送请求"><a href="#使用axios-方法来发送请求" class="headerlink" title="使用axios()方法来发送请求"></a>使用<code>axios()</code>方法来发送请求</h5><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送POST请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送PUT请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送DELETE请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token comment">//接收数据</span>        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token comment">//获取元素</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span><span class="token comment">//发送GET请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts'</span> <span class="token comment">//地址是json-server的地址</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//axios返回结果是promise，用then方法来接收</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//发送数据</span>        btns<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'POST'</span><span class="token punctuation">,</span><span class="token comment">//发送POST请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts'</span><span class="token punctuation">,</span><span class="token comment">//根据json-server的规则来编写地址</span>            <span class="token comment">//设置请求体</span>                <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token comment">//要发送的数据</span>                    <span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'今天天气不错'</span><span class="token punctuation">,</span>                    <span class="token literal-property property">author</span><span class="token operator">:</span><span class="token string">'张三'</span>                <span class="token punctuation">&#125;</span><span class="token comment">//此时在自己的json-server中创建的json文件中就会看到发送到的数据</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//更新数据</span>        btns<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'PUT'</span><span class="token punctuation">,</span><span class="token comment">//发送PUT请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts/3'</span><span class="token punctuation">,</span><span class="token comment">// /3表示要修改id为3的内容</span>            <span class="token comment">//设置请求体</span>                <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token comment">//要发送的数据</span>                    <span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'今天天气不错'</span><span class="token punctuation">,</span>                    <span class="token literal-property property">author</span><span class="token operator">:</span><span class="token string">'李四'</span>                <span class="token punctuation">&#125;</span><span class="token comment">//此时在自己的json-server中创建的json文件中就会看到发送到的数据</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//删除数据</span>        btns<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token comment">//请求类型</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'DELETE'</span><span class="token punctuation">,</span><span class="token comment">//发送DELETE请求</span>                <span class="token comment">//URL</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts/3'</span><span class="token punctuation">,</span><span class="token comment">// /3表示要删除id为3的内容</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//输出返回结果</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="使用axios-request-来发送请求"><a href="#使用axios-request-来发送请求" class="headerlink" title="使用axios.request()来发送请求"></a>使用<code>axios.request()</code>来发送请求</h5><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            axios<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'GET'</span><span class="token punctuation">,</span><span class="token comment">//发送GET请求</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/posts'</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="使用axios-post-来发送请求"><a href="#使用axios-post-来发送请求" class="headerlink" title="使用axios.post()来发送请求"></a>使用<code>axios.post()</code>来发送请求</h5><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送POST请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//axios.post(url[, data[, config]])</span>            <span class="token comment">//post第一个参数为url,第二个为请求体内容,第三个为配置 二三都是可选的</span>            axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'http://localhost:3000/comments'</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token comment">//向comments部分发送数据</span>                <span class="token string-property property">"body"</span><span class="token operator">:</span> <span class="token string">"some comment"</span><span class="token punctuation">,</span>                <span class="token string-property property">"postId"</span><span class="token operator">:</span> <span class="token string">"2"</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//发送成功的回调</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p>多余的<code>axios</code>方法基本都与上方相同，就不再过多演示了</p><h5 id="axios默认配置"><a href="#axios默认配置" class="headerlink" title="axios默认配置"></a><code>axios</code>默认配置</h5><p>可以设置一些默认配置来减少代码的冗余</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>method <span class="token operator">=</span> <span class="token string">'GET'</span> <span class="token comment">//设置默认的请求类型为 GET</span>        axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>baseURL <span class="token operator">=</span> <span class="token string">'http://localhost:3000'</span> <span class="token comment">//设置基础URL</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            axios<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'/posts'</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">//返回成功内容</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="axios创建实例对象来发送请求"><a href="#axios创建实例对象来发送请求" class="headerlink" title="axios创建实例对象来发送请求"></a><code>axios</code>创建实例对象来发送请求</h5><p>当想对两个域名不相同的服务器发送请求就可以使用创建实例对象来发送</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送服务器1GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送服务器2GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> server1 <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://api.bilibili.com'</span><span class="token punctuation">,</span> <span class="token comment">//演示这里的api就随便写了</span>            <span class="token literal-property property">timeout</span><span class="token operator">:</span><span class="token number">2000</span><span class="token comment">//设置2秒超时终止</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> server2 <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://sentry.music.163.com'</span><span class="token punctuation">,</span> <span class="token comment">//演示这里的api就随便写了</span>            <span class="token literal-property property">timeout</span><span class="token operator">:</span><span class="token number">2000</span><span class="token comment">//设置2秒超时终止</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">server1</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">'/x/web-interface/zone?jsonp=jsonp'</span><span class="token comment">//发送请求</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        btns<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">server2</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">'/wapm/api/sdk/collect'</span><span class="token comment">//发送请求</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h5 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a><code>axios</code>拦截器</h5><pre class="language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--结果：输出：  请求拦截器 成功   响应拦截器 成功   发送请求成功--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>    btns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//发送请求</span>            <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>                <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">'http://localhost:3000/posts'</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发送请求成功'</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'失败回调'</span><span class="token punctuation">)</span><span class="token comment">//请求拦截器失败会输出</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token comment">// 添加请求拦截器</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//use相当于promise的then方法，前面返回成功值，后面返回失败值</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求拦截器 成功'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> config<span class="token punctuation">;</span><span class="token comment">//这里要是抛出异常或promise返回值为失败则响应拦截器为失败</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求拦截器 失败'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加响应拦截器</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//只要请求码是2xx就是会接收到响应</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'响应拦截器 成功'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> response<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'响应拦截器 失败'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6与之后的语法</title>
      <link href="/2022/04/17/ecmascript6-yu-zhi-hou-de-yu-fa/"/>
      <url>/2022/04/17/ecmascript6-yu-zhi-hou-de-yu-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>注意：具体内容可以去参考<a href="https://www.ecma-international.org/">ECMA</a>官方文档，这里只是对某些语法进行总结与参考</strong></p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p><code>let</code>不能重复声明<code>var</code>可以重复声明</p><p><code>let</code>用来声明变量<code>const</code>用来声明常量<code>const</code>声明后不可以重新赋值，<code>let</code>可以重新赋值。<code>const</code>一定要赋初始值。</p><p>cs6后新增了块级作用域，使用<code>let</code>和<code>const</code>声明只在代码块中生效</p><p><code>let</code>和<code>const</code>不存在变量提升，用<code>var</code>声明变量会参与预加载</p><p>而且不影响作用域链</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> example <span class="token operator">=</span> <span class="token string">'例子'</span>    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//最终输出'例子'</span><span class="token punctuation">&#125;</span></code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这称为解构赋值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//数组解构</span><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子1'</span><span class="token punctuation">,</span><span class="token string">'例子2'</span><span class="token punctuation">,</span><span class="token string">'例子3'</span><span class="token punctuation">]</span><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">,</span><span class="token string">'example3'</span><span class="token punctuation">]</span> <span class="token operator">=</span> example<span class="token comment">//对象解构</span><span class="token keyword">const</span> exampleObj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'title'</span><span class="token punctuation">,</span>    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">'content'</span><span class="token punctuation">,</span>    <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是一个方法'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//let &#123;title,content,fn&#125; = exampleObj</span><span class="token comment">//可以单独解构出某一条你想用的方法或参数，可以直接调用函数</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span>fn<span class="token punctuation">&#125;</span> <span class="token operator">=</span> exampleObj<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以多级解构赋值，以对象为例子</span><span class="token keyword">const</span> reduplicate <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'title'</span><span class="token punctuation">,</span>    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">'content'</span><span class="token punctuation">,</span>    <span class="token literal-property property">obj</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">innterTitle</span><span class="token operator">:</span> <span class="token string">'内部标题'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">obj</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>innterTitle<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> reduplicateconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>innterTitle<span class="token punctuation">)</span><span class="token comment">//控制台输出'内部标题'</span></code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>ES6引入了新的声明字符串方式<code>[``]</code></p><p>特性：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//内容可以直接出现换行符</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;ul>&lt;li>不会报错&lt;/li>&lt;/ul></span><span class="token template-punctuation string">`</span></span><span class="token comment">//可以进行变量拼接</span><span class="token keyword">let</span> example <span class="token operator">=</span> <span class="token string">'例子1'</span><span class="token keyword">let</span> out <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>example<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">是第一个例子</span><span class="token template-punctuation string">`</span></span> <span class="token comment">//$&#123;&#125;是固定格式，里面放要拼接的变量名</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token comment">//输出'例子1是第一个例子'</span></code></pre><h4 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h4><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> example <span class="token operator">=</span> <span class="token string">'例子1'</span><span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//完整写法</span>    <span class="token comment">//example:example,</span>    <span class="token comment">//fn:fn</span>    <span class="token comment">//简化写法</span>    example<span class="token punctuation">,</span>    fn<span class="token punctuation">,</span>    <span class="token comment">//可以简化对象写法，不用再加function</span>    <span class="token literal-property property">Second</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第二个'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数this始终指向函数声明时所在作用域下的this的值</p><p>普通函数this谁调用指向谁</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//判断箭头函数this指向</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//设置window的a属性</span>window<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'window中的a'</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">'对象中的a'</span><span class="token punctuation">&#125;</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'window中的a'</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'window中的a'</span><span class="token comment">//接下来用call方法来调用改变this</span><span class="token function">fn1</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//对象中的a</span><span class="token function">fn2</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//输出'window中的a'</span></code></pre><p>箭头函数不能作为构造实例化对象</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//判断箭头函数是否能构造实例化对象</span><span class="token keyword">let</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">&#125;</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//结果报错Person is not a constructor</span></code></pre><p>箭头函数不能使用<code>arguments</code>变量（arguments是函数内部用来保存实参）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//判断箭头函数是否能使用使用arguments变量</span><span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//输出Arguments</span><span class="token keyword">let</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//结果报错arguments is not defined</span></code></pre><p>箭头函数的简写</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//当形参有且只有一个的时候可以省略小括号</span><span class="token keyword">let</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> n <span class="token operator">+</span> n <span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'2'</span><span class="token comment">//当代码提只有一条需要return语句的时候，可以省略花括号</span><span class="token keyword">let</span> <span class="token function-variable function">pow</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=></span> n<span class="token operator">*</span>nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'4'</span></code></pre><h4 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h4><p>ES6允许给函数参数赋值初始值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//具有默认值的参数，一般位置要靠后</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">3</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">&#125;</span><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment">//输出'6'</span></code></pre><p>可以与解构赋值相结合</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//没有传参数则用初始值</span><span class="token keyword">function</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>host<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>username<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token comment">//输出'127.0.0.1'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token comment">//输出'root'</span><span class="token punctuation">&#125;</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">username</span><span class="token operator">:</span><span class="token string">'root'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a><code>rest</code>参数</h4><p>ES6引入<code>rest</code>参数，用于获取函数的实参，用来代替<code>arguments</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token comment">//输出的是数组，可以使用数组的API，arguments输出的是对象</span><span class="token punctuation">&#125;</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token string">'数据'</span><span class="token punctuation">,</span><span class="token string">'数据2'</span><span class="token punctuation">)</span><span class="token comment">//如果要形参有多个，rest参数必须要放在最后</span></code></pre><h4 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h4><p>[…]扩展运算符能将[数组]转换为逗号分隔的[参数序列]</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//声明一个数组</span><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子1'</span><span class="token punctuation">,</span><span class="token string">'例子2'</span><span class="token punctuation">,</span><span class="token string">'例子3'</span><span class="token punctuation">]</span><span class="token comment">//声明一个函数</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token comment">//输出对象，对象中包含'0: "例子1"  1: "例子2"  2: "例子3"'</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>example<span class="token punctuation">)</span></code></pre><p>扩展运算符可以用于数组的合并</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子1'</span><span class="token punctuation">,</span><span class="token string">'例子2'</span><span class="token punctuation">,</span><span class="token string">'例子3'</span><span class="token punctuation">]</span><span class="token keyword">const</span> example2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'例子4'</span><span class="token punctuation">,</span><span class="token string">'例子5'</span><span class="token punctuation">,</span><span class="token string">'例子6'</span><span class="token punctuation">]</span><span class="token comment">//const gather = example.concat(example2)  传统方法</span><span class="token keyword">const</span> gather <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>example<span class="token punctuation">,</span><span class="token operator">...</span>example2<span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gather<span class="token punctuation">)</span><span class="token comment">//输出['例子1', '例子2', '例子3', '例子4', '例子5', '例子6']</span></code></pre><p>还能将伪数组转为真正的数组</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">const</span> divs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> divArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>divs<span class="token punctuation">]</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>divArr<span class="token punctuation">)</span><span class="token comment">//输出 [div, div, div]</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="Symbol数据类型"><a href="#Symbol数据类型" class="headerlink" title="Symbol数据类型"></a><code>Symbol</code>数据类型</h4><p><code>ES6</code>引入了一种新的原始数据类型<code>Symbol</code>，用来表示独一无二的值，是一种字符串类型。</p><p><code>Symbol</code>特点</p><ol><li><code>Symbol</code>的值是唯一的，用来解决命名冲突的问题。</li><li><code>Symbol</code>值不能与其他数据进行运算。</li><li><code>Symbol</code>定义的对象属性不能使用 <code>for...in</code> 循环遍历，但是可以使用<code>Reflect.ownKeys</code>来获取对象的所有键名。</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建Symbol</span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s2 <span class="token operator">===</span> s<span class="token punctuation">)</span><span class="token comment">//输出false</span><span class="token comment">//Symbol.for 创建</span><span class="token keyword">let</span> s3 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span><span class="token keyword">let</span> s4 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s3<span class="token operator">===</span>s4<span class="token punctuation">)</span><span class="token comment">//输出true</span><span class="token comment">//在不确定对象里是否有要创建的值的时候可以使用Symbol来添加方法</span><span class="token comment">//向对象中添加up down方法</span><span class="token keyword">let</span> game<span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">up</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'gameup'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> methods <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">up</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token literal-property property">down</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> game<span class="token punctuation">[</span>methods<span class="token punctuation">.</span>up<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'up'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>game<span class="token punctuation">[</span>methods<span class="token punctuation">.</span>down<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'down'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>game<span class="token punctuation">.</span><span class="token function">up</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'gameup'</span>game<span class="token punctuation">[</span>methods<span class="token punctuation">.</span>up<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'up'</span><span class="token comment">//在对象中直接定义Symbol</span><span class="token keyword">const</span> example <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>   <span class="token punctuation">[</span>example<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'例子'</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>obj<span class="token punctuation">[</span>example<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'例子'</span></code></pre><p><code>Sybol</code>的<code>hasInstance()</code>可以自己控制类型检测值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//param是判断类型的值</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token comment">//这里因为和o判断所以输出的就是&#123;&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token comment">//因为上方return true 输出的就是true</span></code></pre><p>剩下的方法可以通过官方文档了解更多，这里就不过多赘述了。</p><h4 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h4><p>迭代器（iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p><p><code>ES6</code>创造了一种新的遍历命令<code>for...of</code>循环，iterator接口主要供<code>for...of</code>消费</p><p>原生具备iterator接口的数据</p><ul><li>Array</li><li>Arguments</li><li>Set</li><li>Map</li><li>String</li><li>TypedArray</li><li>NodeList</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//只要有Symbol.iterator()就可以使用for...of</span><span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'exam'</span><span class="token punctuation">,</span><span class="token string">'exam2'</span><span class="token punctuation">,</span><span class="token string">'exam3'</span><span class="token punctuation">]</span><span class="token comment">//先用for...in循环遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">in</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//保存的是键名，输出'0 1 2'</span><span class="token punctuation">&#125;</span><span class="token comment">//使用for...of遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//保存的是键值，输出'exam exam2 exam3</span><span class="token punctuation">&#125;</span></code></pre><p><strong>工作原理</strong></p><ul><li>创建一个指针对象，指向当前数据结构的起始位置</li><li>第一次调用对象的<code>next</code>方法，指针自动指向数据结构的第一个成员</li><li>接下来不断调用<code>next</code>方法，指针一直往后移动，直到指向最后一个成员</li><li>每调用<code>next</code>方法返回一个包含<code>value</code>和<code>done</code>属性的对象</li><li>当<code>value</code>为<code>undefined</code>且<code>done</code>为<code>true</code>时，结束调用</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//手写调用iterator()</span><span class="token comment">//声明一个对象</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'name'</span><span class="token punctuation">,</span>    <span class="token literal-property property">arr</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token string">'arr1'</span><span class="token punctuation">,</span>        <span class="token string">'arr2'</span><span class="token punctuation">,</span>        <span class="token string">'arr3'</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//对象中没有迭代器方法，我们手动添加</span>        <span class="token comment">//用索引变量来判断是否超过了数组的长度</span>        <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">return</span><span class="token punctuation">&#123;</span>            <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token comment">//原本的迭代器需要返回value和done属性，所以我们也要添加上</span>                    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token literal-property property">done</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span>                    index<span class="token operator">++</span>                    <span class="token keyword">return</span> result                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">value</span><span class="token operator">:</span><span class="token keyword">undefined</span> <span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//遍历这个对象,不使用obj.arr拿到arr中数据</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//结果输出'arr1 arr2 arr3'</span><span class="token punctuation">&#125;</span></code></pre><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同</p><p>生成器是一种特殊的函数</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//生成器函数必须要加*</span><span class="token keyword">function</span> <span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'helloWorld'</span><span class="token punctuation">)</span>    <span class="token comment">//内部可以使用yield来作为分隔符</span>    <span class="token keyword">yield</span> <span class="token string">'slide'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'helloHTML'</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span> <span class="token string">'slide2'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'helloJS'</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span> <span class="token string">'slide3'</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> iterator <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//使用迭代器方法调用</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'helloWorld'</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'helloHTML'</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'helloJS'</span><span class="token comment">//也可以使用for...of遍历</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token comment">//输出'helloWorld' 加上分隔符名 'slide' 'helloHTML' 加上分隔符名 'slide'以此类推</span><span class="token punctuation">&#125;</span></code></pre><p>生成器函数参数传递</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> one <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">111</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token comment">//输出next()传递的'one中的BBB'</span>    <span class="token keyword">let</span> two <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">222</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token comment">//输出next()传递的'two中的BBB'</span>    <span class="token keyword">let</span> three <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">333</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span><span class="token comment">//输出next()传递的'three中的BBB'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> interator <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//第一次调用</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'one中的BBB'</span><span class="token punctuation">)</span><span class="token comment">//第二次调用作为第一次yield的返回结果</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'two中的BBB'</span><span class="token punctuation">)</span><span class="token comment">//第三次调用作为第二次yield的返回结果</span>interator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'three中的BBB'</span><span class="token punctuation">)</span><span class="token comment">//第四次调用作为第三次yield的返回结果</span></code></pre><h4 id="Promise（了解更多可以参考我到时候对Promise深入总结）"><a href="#Promise（了解更多可以参考我到时候对Promise深入总结）" class="headerlink" title="Promise（了解更多可以参考我到时候对Promise深入总结）"></a>Promise（了解更多可以参考我到时候对Promise深入总结）</h4><p><code>promise</code>是<code>ES6</code>引入的异步编程的新解决方案。用来封装异步操作并可以获取其成功或失败的结果</p><ul><li><code>Promise</code>构造函数：<code>Promise(excutor)&#123;&#125;</code></li><li><code>Promise.prototype.then</code>方法</li><li><code>Promise.prototype.catch</code>方法(就是捕获<code>promise</code>失败,这里就不过多介绍了)</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//实例化Promise</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">'数据'</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment">//调用resolve即为成功</span>        <span class="token keyword">const</span> err <span class="token operator">=</span> <span class="token string">'错误'</span>        <span class="token comment">//reject(err)  调用reject即为失败</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//then方法返回的也是promise对象，可以继续调用promise方法。状态由回调函数的结果决定</span><span class="token comment">//如果返回的是非promise类型的属性，状态为成功，返回值为对象的成功值</span><span class="token comment">//then中是异步调用，Promise中式同步调用</span><span class="token keyword">const</span> result <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token comment">//输出'数据'</span>    <span class="token keyword">return</span> <span class="token keyword">throw</span> <span class="token number">1</span> <span class="token comment">//不返回默认undifiend 返回错误或者在promise中调用reject都是返回失败的promise</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token parameter">reason</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token comment">//失败时候会调用reason</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">//输出中PromiseResult值为1</span></code></pre><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h4><p><code>ES6</code>提供了新的数据结构<code>Set</code>(集合)。它类似于数组，但成员的值都是唯一的，集合实现了<code>iterator</code>接口，所以可以使用扩展运算符和<code>for...of</code>进行遍历</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//自动去重1就只输出一次</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出Set中包含'1 2 3 4'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment">//输出'4' 类似数组length方法</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">//添加新的元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出Set中包含'1 2 3 4 5'</span>s<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//删除元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出Set中包含'2 3 4 5'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//检测是否有5这个元素  输出'true'</span>s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//清空集合</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment">//输出元素为空</span></code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>ES6</code>停供了<code>Map</code>数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<code>Map</code>也实现了<code>iterator</code>接口，所以可以使用扩展运算符和<code>for...of</code>进行遍历</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'title'</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'title1'</span><span class="token punctuation">,</span><span class="token string">'title2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment">//元素的键为对象，值为数组</span><span class="token comment">//查看长度</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment">//输出1</span><span class="token comment">//获取元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出的是上方数组</span><span class="token comment">//删除元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment">//为空对象</span></code></pre><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p><code>ES6</code>提供了更接近传统语言的写法，引入了<code>Class</code>（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，<code>ES6</code>的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，<code>ES5</code>都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更加面向对象编程的语法</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token comment">//构造方法 名字不能修改</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span> price</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> brand        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price    <span class="token punctuation">&#125;</span>    <span class="token comment">//方法必须使用该语法，不能使用ES5的对象完整写法</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以打电话'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token constant">HW</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token string">'max'</span> <span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">HW</span><span class="token punctuation">)</span><span class="token comment">//输出函数</span></code></pre><p>static静态成员</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token comment">//使用static标识的只属于Phone这个类</span>    <span class="token keyword">static</span> name <span class="token operator">=</span> <span class="token string">'手机'</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> nokia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nokia<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">//输出'undifined'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Phone<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">//输出'手机'</span></code></pre><p>对象继承</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//ES6之前实现继承，原理是使用原型链来实现继承</span><span class="token keyword">function</span> <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span>price</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> brand    <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">&#125;</span><span class="token class-name">Phone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以打电话'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//子级构造函数</span><span class="token keyword">function</span> <span class="token function">SmartPhone</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span>price<span class="token punctuation">,</span>color<span class="token punctuation">,</span>size</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Phone</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>brand<span class="token punctuation">,</span>price<span class="token punctuation">)</span><span class="token comment">//用call()方法改变this指向</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">&#125;</span><span class="token comment">//设置子级构造函数的原型</span><span class="token class-name">SmartPhone</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token class-name">SmartPhone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SmartPhone<span class="token comment">//声明调用子类的方法</span><span class="token class-name">SmartPhone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">photo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以拍照'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> chuizi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmartPhone</span><span class="token punctuation">(</span><span class="token string">'锤子'</span><span class="token punctuation">,</span><span class="token number">2499</span><span class="token punctuation">,</span><span class="token string">'黑色'</span><span class="token punctuation">,</span><span class="token string">'5.5'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chuizi<span class="token punctuation">)</span><span class="token comment">//父类方法在原型链上</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//ES6实现继承</span><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span> price</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> brand        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price    <span class="token punctuation">&#125;</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以打电话'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">SmartPhone</span> <span class="token keyword">extends</span> <span class="token class-name">Phone</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">brand<span class="token punctuation">,</span>price<span class="token punctuation">,</span>color<span class="token punctuation">,</span>size</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//用super来继承父类,super只能再创建对象时候调用，不能直接调用父类方法</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>brand<span class="token punctuation">,</span>price<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size    <span class="token punctuation">&#125;</span>        <span class="token function">photo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'拍照'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//因为父类有了call方法，子类再添加相同名的方法会进行重写call的方法</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我可以视频通话'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> chuizi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmartPhone</span><span class="token punctuation">(</span><span class="token string">'锤子'</span><span class="token punctuation">,</span><span class="token number">2499</span><span class="token punctuation">,</span><span class="token string">'黑色'</span><span class="token punctuation">,</span><span class="token string">'5.5'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chuizi<span class="token punctuation">)</span><span class="token comment">//父类方法在原型链上</span><span class="token function">chuizi</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出'我可以视频通话'</span></code></pre><p><code>getter</code>和<code>setter</code>设置</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span>    <span class="token comment">//只要被读取就会触发get方法</span>    <span class="token keyword">get</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'价格被读取了'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">'get返回了'</span><span class="token comment">//返回值就是属性值</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">set</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//必须设置参数</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'价格属性被修改了'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>price <span class="token operator">=</span> <span class="token string">'1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token comment">//输出'get返回了'</span></code></pre><h4 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//Number.EPSILON 是 JavaScript 表示的最小精度 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token comment">//因为浮点数精度问题 返回的是false</span><span class="token keyword">function</span> <span class="token function">equal</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//判断传过来的两数之差的绝对值是否小于最小精度</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token comment">//小于就认为两数相等</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token operator">+</span><span class="token number">0.2</span><span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出true</span><span class="token comment">//Number.isFinite 检测一个数值是否为有限数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回false</span><span class="token comment">//Number.isNaN 检测是否为NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回false</span><span class="token comment">//Number.isInteger 判断是否为整数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//返回true</span><span class="token comment">//Math.trunc 将数字的小数部分抹掉</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">trunc</span><span class="token punctuation">(</span><span class="token number">123.123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'123'</span><span class="token comment">//Math.sign 判断一个数为正数 负数 还是零</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'0'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'-1'</span></code></pre><h4 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h4><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p><p>模块化的好处：</p><ol><li>防止命名冲突</li><li>代码复用</li><li>高维护性</li></ol><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code></p><ul><li><code>export</code>用于规定模块的对外接口</li><li><code>import</code>用于输入其他模块提供的功能</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//要暴露的文件 所有使用的语法就全在这代码块中演示了，不做分割了</span><span class="token keyword">export</span> <span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token string">'标题'</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这里是内容'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//统一暴露</span><span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token string">'标题'</span><span class="token keyword">function</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这里是内容'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>title<span class="token punctuation">,</span>content<span class="token punctuation">&#125;</span><span class="token comment">//默认暴露,内容以对象居多</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'标题'</span><span class="token punctuation">,</span>    <span class="token function-variable function">content</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这里是内容'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//引入上方的文件</span><span class="token comment">//通用的导入方式</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> m1 <span class="token keyword">from</span> <span class="token string">'./src/js/m1.js'</span> <span class="token comment">//'*'表示全引入</span><span class="token comment">//解构赋值形式</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>title<span class="token punctuation">,</span>content<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./src/js/m1.js'</span> <span class="token comment">//使用方法就和解构语法一样</span><span class="token comment">//简便形式 针对默认暴露</span><span class="token keyword">import</span> m3 <span class="token keyword">from</span> <span class="token string">'./src/js/m1.js'</span></code></pre><h4 id="ES7新特性"><a href="#ES7新特性" class="headerlink" title="ES7新特性"></a>ES7新特性</h4><p><code>Array.includes</code>来判断数组中是否有当前元素</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出true</span><span class="token comment">//之前可以使用indexOf来判断是否有当前元素，返回的是下标，不存在则返回-1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出4</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出-1</span></code></pre><p>幂运算<code>**</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token comment">//输出8</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出8 效果相同</span></code></pre><h4 id="ES8新特性"><a href="#ES8新特性" class="headerlink" title="ES8新特性"></a>ES8新特性</h4><p><code>async</code>和<code>await</code>可以让异步代码像同步代码一样</p><p><code>async</code>函数返回值是<code>promise</code>对象</p><p><code>promise</code>对象的结果由<code>async</code>函数执行的返回值决定</p><p><code>await</code>必须写在<code>async</code>函数中</p><p><code>await</code>右侧的表达式一般为<code>promise</code>对象</p><p><code>await</code>返回的是<code>promise</code>成功的值</p><p><code>await</code>的<code>promise</code>失败了将会抛出异常，需要通过<code>try...catch</code>捕获处理</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//async中的函数为同步执行</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">333</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出结果为 222 111 333</span></code></pre><h4 id="ES9扩展运算符与rest参数"><a href="#ES9扩展运算符与rest参数" class="headerlink" title="ES9扩展运算符与rest参数"></a>ES9扩展运算符与<code>rest</code>参数</h4><p><code>rest</code>参数与<code>spread</code>扩展运算符在<code>ES6</code>中以及引入，不过<code>ES6</code>中只针对于数组，在<code>ES9</code>中为对象提供了像数组一样的<code>rest</code>参数和扩展运算符</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> ip <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">host</span><span class="token operator">:</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'root'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> pwd <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">password</span><span class="token operator">:</span><span class="token string">'root'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> connect <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span>ip<span class="token punctuation">,</span><span class="token operator">...</span>name<span class="token punctuation">,</span><span class="token operator">...</span>pwd<span class="token punctuation">&#125;</span><span class="token comment">//将三个对象的属性放在了一个对象中</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>connect<span class="token punctuation">)</span><span class="token comment">//输出对象包含上面三个属性</span></code></pre><p><strong><code>ES9</code>新增的正则扩展就不介绍了</strong></p><h4 id="ES10扩展方法"><a href="#ES10扩展方法" class="headerlink" title="ES10扩展方法"></a>ES10扩展方法</h4><p>对象扩展方法<code>Object.fromEntries</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建一个二维数组</span><span class="token keyword">const</span> result <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'名字'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span><span class="token string">'标题'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment">//输出&#123;name: '名字', title: '标题'&#125;</span><span class="token comment">//与ES8中的Object.entries相当于逆运算</span><span class="token comment">//Object.fromEntries是把二维数组转换为对象</span><span class="token comment">//Object.entries是把对象转换为二维数组</span><span class="token keyword">const</span> arr <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'名字'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">//输出[Array(2)]</span></code></pre><p>字符串方法扩展</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//trim用来清除字符串空白字符</span><span class="token comment">//ES10中引入trimStart trimEnd来选择清除开始还是结束的空白字符</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'   e    '</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment">//输出'   e    '</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">trimStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'e    '</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">trimEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出'   e'</span></code></pre><p>数组方法扩展</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//flat </span><span class="token comment">//将多维数组转化为低维数组</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">//创建一个三维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出  [1, 2, 3, Array(3)]  三维数组变成了二维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出 [1, 2, 3, 4, 5, 6] 二维数组变成了一维数组  flat默认深度为1</span></code></pre><h4 id="ES11特性"><a href="#ES11特性" class="headerlink" title="ES11特性"></a>ES11特性</h4><p>私有属性</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token comment">//公有属性</span>    name    <span class="token comment">//私有属性</span>    #age    #weight        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>weight</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name        <span class="token keyword">this</span><span class="token punctuation">.</span>#age <span class="token operator">=</span> age        <span class="token keyword">this</span><span class="token punctuation">.</span>#weight <span class="token operator">=</span> weight    <span class="token punctuation">&#125;</span>        <span class="token function">intro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#age<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#weight<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//实例化</span><span class="token keyword">const</span> gril <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span> <span class="token punctuation">(</span><span class="token string">'小红'</span><span class="token punctuation">,</span> <span class="token number">18</span> <span class="token punctuation">,</span> <span class="token string">'45kg'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gril<span class="token punctuation">)</span>gril<span class="token punctuation">.</span><span class="token function">intro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//输出 小红 18 45kg</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gril<span class="token punctuation">.</span>#age<span class="token punctuation">)</span><span class="token comment">//报语法错误，不能在类外部调用</span></code></pre><p><code>Promise.allSettled</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//声明两个promise对象</span><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第一个'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'第二个'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//调用allSettled方法</span><span class="token keyword">const</span> result <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment">//输出promise成功的值和结果数组  无论结果失败成功都会输出成功状态</span><span class="token comment">//调用all方法</span><span class="token keyword">const</span> result2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token comment">//值为失败并报错</span></code></pre><p>可选链操作符</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// ?. 用于判断前前面的值是否存在</span><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> db <span class="token operator">=</span> config <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>db <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>db<span class="token punctuation">.</span>host <span class="token comment">//原先的判断方法，当全为true再赋值</span>    <span class="token keyword">const</span> newDb <span class="token operator">=</span> config<span class="token operator">?.</span>db<span class="token operator">?.</span>host    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token comment">//输出172.0.0.1</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newDb<span class="token punctuation">)</span><span class="token comment">//输出172.0.0.1</span><span class="token punctuation">&#125;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">db</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">host</span><span class="token operator">:</span><span class="token string">'172.0.0.1'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>动态<code>import</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//要引入的文件</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是要暴露的文件'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用的时候在引入文件</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./fn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token operator">=></span><span class="token punctuation">&#123;</span> <span class="token comment">//是一个promise对象  路径是我随便瞎写的，根据实际情况调整</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>moudule<span class="token punctuation">)</span><span class="token comment">//使用的时候才会调用</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p><code>BigInt</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">123n</span> <span class="token comment">//加了n就表示大整形，bigInt用于更大数值的运算，bigInt不能和普通整形运算，必须都为bigInt</span><span class="token keyword">let</span> max <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token comment">//获取整数最大安全值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token comment">//输出9007199254740991</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token function">BigInt</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出9007199254741114n</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//报错</span></code></pre><p><code>globalThis</code>如字面意思，<code>this</code>始终指向全局对象，无论在任何环境，这里就不作代码介绍了。</p><hr><blockquote><p>目前就到这里先结束了，以后要是有新总结会新添加</p><p>文章参考了尚硅谷的ES6教程，非常感谢老师们的辛勤付出！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理_存储器</title>
      <link href="/2022/04/17/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi/"/>
      <url>/2022/04/17/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h4><ol><li><p>​    按存储介质分类</p><p>(1)半导体存储器：TTL、MOS </p><p>​    如果半导体中没有电流，存储器中的信息将会消失，称这种情况为<strong>易失</strong></p><p>(2)磁表面存储器：磁头载磁体   非易失（不通电其中的存储信息也是保存的）</p><p>(3)磁芯存储器：硬磁材料、环状元件  非易失</p><p>(4)光盘存储器：激光、激光材料  非易失</p></li><li><p>​    按存取方式分类</p><p>(1)存取时间与物理地址无关（随机访问）</p><p>​    随机存储器   在程序的执行过程中 可读可写</p><p>​    只读存储器    在程序的执行过程中  只读</p><p>(2)存取时间与物理地址有关（串行访问）</p><p>​    顺序存取存储器   磁带</p><p>​    直接存取存储器   磁盘</p></li><li><p>按在计算机中的作用分类</p><p>主存储器： </p><p>RAM（可读可写）：可分为静态RAM、动态RAM</p><p>ROM（只读）：可分为MROM、PROM、EPROM、EEPROM</p><p>Flash Memory（SSD核心存储材料就是这个）</p><p>高速缓冲存储器（Cache，通过静态RAM来制作）</p><p>辅助存储器：磁盘、磁带、光盘等</p></li></ol><hr><h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><ol><li><p>存储器三个主要特性的关系</p><img src="/2022/04/17/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi/ComputerCharacter.png" class=""><p>寄存器不仅CPU当中有IO端口也有寄存器。</p><p>不透明且提供给机器语言程序员的寄存器称为体系结构寄存器</p><p>透明且不提供给机器语言程序员的寄存器称为非体系结构寄存器，不能直接进行操作</p><p>随着半导体技术的发展，部分缓存就被集成到了CPU当中。</p><p>金字塔顶端向下，速度便随高到底，容量便小到大，价格为高到底。</p></li><li><p>缓存-主存层次和主存-辅存层次</p><img src="/2022/04/17/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi/saveData.png" class=""><p>通过软硬件相结合的方式来调用程序，应用程序员不需要关心应用是如何在缓存中实现的。</p><p>程序员要执行程序需要考虑将程序分为多个模块，有些模块放在主存当中，有些放在辅存中。</p><p>因为辅存的容量在不断提升，而主存的容量提升微乎其微，为了增加速度在主存与CPU之间添加<strong>缓存</strong>作为缓冲空间。缓存速度要比主存快的多。CPU可以通过缓存来访问主存。</p><p>主存和缓存之间主要解决速度问题，因此用硬件相连接。</p><p>主存和辅存之间主要解决容量问题，因此用软硬件相连接。</p><p>主存和辅存构成的整体一般我们把他叫做<strong>虚拟存储器</strong>。</p><p>虚拟存储器的地址空间用虚地址和逻辑地址。</p><p>主存和缓存就是使用主存储器的实地址。</p></li></ol><hr><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><h5 id="主存的中存储单元地址的分配"><a href="#主存的中存储单元地址的分配" class="headerlink" title="主存的中存储单元地址的分配"></a>主存的中存储单元地址的分配</h5><p>​    12345678H这个数据如何在主存储器中进行存储？</p><p>​    <img src="/2022/04/17/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi/address.png" class=""></p><h5 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h5><p>​    存储容量： 主存 存放二进制代码的个位数</p><p>​    存储速度：</p><p>​        存取时间：存储器的访问时间   读出时间  写入时间</p><p>​        存取周期：  连续两次独立的存储器操作（读或写）所需的最小间隔时间</p><p>​    存储器的带宽 单位（位&#x2F;秒）</p><h5 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h5><img src="/2022/04/17/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi/contain.png" class=""><p>地址线是单向传输，数据线是双向传输。<br>$$<br>芯片容量 &#x3D; 2^{地址线}(K) × 数据线(位)<br>$$<br>片选线：包括CS（芯片选择）和CE（使能信号）（上面有一表示低电平有效）</p><p>读&#x2F;写控制线： WE（低电平写 高电平读）。也可以使用两条控制线OE（允许读）WE（允许写）</p><h5 id="存储芯片片选线的作用"><a href="#存储芯片片选线的作用" class="headerlink" title="存储芯片片选线的作用"></a>存储芯片片选线的作用</h5><p>如何用16K×1位的存储芯片组成64K×8位的存储器：</p><img src="/2022/04/17/ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi/chip.png" class=""><p>可以将用8个16K×1位的芯片组成一个芯片组，此时就变成了16K×8位，再添加3组同样的芯片组。就成了64K×8位。每个芯片组要同时工作才能保证同时的读写。总共32片，每一组都保证是16K×8位。第一组的地址为0K<del>16K-1。第二组的地址为16K</del>32K-1以此类推分配完地址。</p><h5 id="随机存储存储器（RAM）"><a href="#随机存储存储器（RAM）" class="headerlink" title="随机存储存储器（RAM）"></a>随机存储存储器（RAM）</h5>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 存储器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_应用层</title>
      <link href="/2022/04/16/ji-suan-ji-wang-luo-ying-yong-ceng/"/>
      <url>/2022/04/16/ji-suan-ji-wang-luo-ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="6-1客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#6-1客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="6.1客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>6.1客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h3><p>​    开发一种新的网络应用首先要考虑的问题就是网络应用程序再各种端系统上的组织方式和它们之间的关系</p><h4 id="客户-x2F-服务器方式"><a href="#客户-x2F-服务器方式" class="headerlink" title="客户&#x2F;服务器方式"></a>客户&#x2F;服务器方式</h4><p>​            客户和服务器是指通信中所设计的两个应用进程<br>​            客户&#x2F;服务器方式所描述的是进程之间服务和被服务的关系<br>​            客户是服务请求方，服务器是服务提供方<br>​            服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号80），而运行服务器的主机也具有固定的IP地址<br>​            基于C&#x2F;S方式的应用服务通常是服务集中型的，常会出现服务器计算跟不上众多客户机请求的情况</p><h4 id="对等方式"><a href="#对等方式" class="headerlink" title="对等方式"></a>对等方式</h4><p>​            没有固定的服务请求者和服务提供者，分布再网络边缘各端系统中的应用进程是对等的，被称为对等方。对等相互之间直接通信<br>​            目前，再因特网上流行的P2P应用主要包括P2P文件共享、即时通讯、P2P流媒体、分布式存储等<br>​            P2P的应用是服务分散型<br>​            P2P方式最突出的特性之一就是它的可扩展性，系统性能不会因规模的增大而降低<br>​            P2P方式具有成本上的优势</p><hr><h3 id="6-2动态主机配置协议DHCP"><a href="#6-2动态主机配置协议DHCP" class="headerlink" title="6.2动态主机配置协议DHCP"></a>6.2动态主机配置协议DHCP</h3><p>​    允许一台计算机加入新网络时可自动获取IP地址等网络配置信息而不用手工参与</p><h4 id="DHCP主要使用以下报文来实现其功能"><a href="#DHCP主要使用以下报文来实现其功能" class="headerlink" title="DHCP主要使用以下报文来实现其功能"></a>DHCP主要使用以下报文来实现其功能</h4><h5 id="DHCP-DISCOVER"><a href="#DHCP-DISCOVER" class="headerlink" title="DHCP DISCOVER"></a>DHCP DISCOVER</h5><p>​            DHCP发现报文</p><h5 id="DHCP-REQUEST"><a href="#DHCP-REQUEST" class="headerlink" title="DHCP REQUEST"></a>DHCP REQUEST</h5><p>​            DHCP请求报文</p><h5 id="DHCP-NACK"><a href="#DHCP-NACK" class="headerlink" title="DHCP NACK"></a>DHCP NACK</h5><p>​            DHCP否认报文</p><h5 id="DHCP-OFFER"><a href="#DHCP-OFFER" class="headerlink" title="DHCP OFFER"></a>DHCP OFFER</h5><p>​            DHCP提供报文</p><h5 id="DHCP-ACK"><a href="#DHCP-ACK" class="headerlink" title="DHCP ACK"></a>DHCP ACK</h5><p>​            DHCP确认报文</p><h5 id="DHCP-RELEASE"><a href="#DHCP-RELEASE" class="headerlink" title="DHCP RELEASE"></a>DHCP RELEASE</h5><p>​            DHCP释放报文</p><h4 id="DHCP报文再运输层使用UDP协议封装"><a href="#DHCP报文再运输层使用UDP协议封装" class="headerlink" title="DHCP报文再运输层使用UDP协议封装"></a>DHCP报文再运输层使用UDP协议封装</h4><p>​        DHCP客户使用的UDP端口号为68<br>​        DHCP服务器使用的UDP端口号为67</p><h4 id="DHCP客户再未获得IP地址时使用地址0-0-0-0"><a href="#DHCP客户再未获得IP地址时使用地址0-0-0-0" class="headerlink" title="DHCP客户再未获得IP地址时使用地址0.0.0.0"></a>DHCP客户再未获得IP地址时使用地址0.0.0.0</h4><p>​    现在是使每一个网络至少有一个DHCP中继代理（通常是一台路由器），它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁</p><hr><h3 id="6-3域名系统DNS"><a href="#6-3域名系统DNS" class="headerlink" title="6.3域名系统DNS"></a>6.3域名系统DNS</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>​        将服务器IP地址解析为域名<br>​    因特网采用层次树状结构的域名结构</p><h4 id="域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名"><a href="#域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名" class="headerlink" title="域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名"></a>域名结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名</h4><p>​        每一级域名不超过63个字符，不区分大小写字母<br>​        级别最低的域名写在最左边，最高的顶级域名写在最右边<br>​        完整的域名不超过255个字符</p><h4 id="各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理"><a href="#各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理" class="headerlink" title="各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理"></a>各级域名由其上一级的域名管理机构管理，而最高级的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理</h4><h4 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h4><h5 id="国家顶级域名nTLD"><a href="#国家顶级域名nTLD" class="headerlink" title="国家顶级域名nTLD"></a>国家顶级域名nTLD</h5><h5 id="通用顶级域名gTLD"><a href="#通用顶级域名gTLD" class="headerlink" title="通用顶级域名gTLD"></a>通用顶级域名gTLD</h5><h5 id="反向域arpa"><a href="#反向域arpa" class="headerlink" title="反向域arpa"></a>反向域arpa</h5><p>​            用于反向域名解析，即IP地址反向解析为域名</p><h4 id="在国家顶级域名下注册的二级域名均有该国家自行确定"><a href="#在国家顶级域名下注册的二级域名均有该国家自行确定" class="headerlink" title="在国家顶级域名下注册的二级域名均有该国家自行确定"></a>在国家顶级域名下注册的二级域名均有该国家自行确定</h4><h4 id="我国则将二级域名划分为两类"><a href="#我国则将二级域名划分为两类" class="headerlink" title="我国则将二级域名划分为两类"></a>我国则将二级域名划分为两类</h4><p>​        类别域名<br>​        行政区域名</p><h4 id="域名服务器可以划分为四种类型"><a href="#域名服务器可以划分为四种类型" class="headerlink" title="域名服务器可以划分为四种类型"></a>域名服务器可以划分为四种类型</h4><h5 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h5><p>​            通常不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</p><h5 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h5><p>​            管理在该顶级域名服务器注册的所有二级域名</p><h5 id="权限域名服务器"><a href="#权限域名服务器" class="headerlink" title="权限域名服务器"></a>权限域名服务器</h5><p>​            负责管理某个区的域名</p><h5 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h5><p>​            本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中，它有时也称为默认域名服务器</p><h4 id="域名解析的过程"><a href="#域名解析的过程" class="headerlink" title="域名解析的过程"></a>域名解析的过程</h4><p>​        递归查询<br>​        迭代查询<br>​        递归查询对于被查询的域名服务器负担太大，通常采用以下模式：从请求主机到本地域名服务器的查询时递归查询，则其余的查询时迭代查询</p><h4 id="在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项"><a href="#在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项" class="headerlink" title="在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项"></a>在域名服务器中使用高速缓存来提高DNS的查询效率，并设置计时器删除超过合理时间的项</h4><hr><h3 id="6-4文件传送协议FTP"><a href="#6-4文件传送协议FTP" class="headerlink" title="6.4文件传送协议FTP"></a>6.4文件传送协议FTP</h3><p>​    FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限</p><p>​    FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</p><h4 id="FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接"><a href="#FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接" class="headerlink" title="FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接"></a>FTP客户和FTP服务器会建立用于传输控制命令的TCP连接和用于传送数据的TCP连接</h4><p>​        控制连接在整个会话期间一直保持打开，用于传送FTP相关控制命令<br>​        数据连接用于文件传输，在每次文件传输时才建立，传输结束就关闭</p><h4 id="默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定"><a href="#默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定" class="headerlink" title="默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定"></a>默认情况下，FTP使用TCP21端口进行控制连接，TCP20端口进行数据连接。主动方式使用TCP20端口，被动方式由服务器和客户端自行协商决定</h4><hr><h3 id="6-5电子邮件"><a href="#6-5电子邮件" class="headerlink" title="6.5电子邮件"></a>6.5电子邮件</h3><p>​    电子邮件时因特网上最早流行的一种应用<br>​    电子邮件采用客户&#x2F;服务器方式</p><h4 id="电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议"><a href="#电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议" class="headerlink" title="电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议"></a>电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议</h4><h5 id="用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件"><a href="#用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件" class="headerlink" title="用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件"></a>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</h5><h5 id="邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱"><a href="#邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱" class="headerlink" title="邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱"></a>邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱</h5><h5 id="协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3-IMAP）"><a href="#协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3-IMAP）" class="headerlink" title="协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3,IMAP）"></a>协议包括邮件发送协议（例如SMTP）和邮件读取协议（POP3,IMAP）</h5><h6 id="SMTP协议只能传送ASCLL码文本数据"><a href="#SMTP协议只能传送ASCLL码文本数据" class="headerlink" title="SMTP协议只能传送ASCLL码文本数据"></a>SMTP协议只能传送ASCLL码文本数据</h6><h6 id="为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件"><a href="#为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件" class="headerlink" title="为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件"></a>为解决SMTP传送非ASCLL码文本问题，提出了多用途因特网邮件扩展MIME来转换非ASCLL码的文件</h6><p>​                增加了5各新的邮件首部字段，这些字段提供了有关邮件主体的信息<br>​                定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化<br>​                定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变<br>​                常见的邮件读取协议<br>​                    邮局协议POP<br>​                        POP3是其第三个版本，是因特网正式标准<br>​                        用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机，不允许用户在邮件服务器上管理自己的邮件<br>​                    因特网邮件访问协议IMAP<br>​                        IMAP4是其第四个版本，目前还只是因特网建议标准<br>​                        用户在自己的计算机上就可以操控邮件服务器中的邮箱<br>​                    POP3和IMAP4都采用基于TCP连接的客户&#x2F;服务器方式。POP3使用熟知端口110，IMAP4使用熟知端口143</p><h4 id="电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322-一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成"><a href="#电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322-一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成" class="headerlink" title="电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322.一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成"></a>电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC5322.一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成</h4><hr><h3 id="6-7万维网WWW"><a href="#6-7万维网WWW" class="headerlink" title="6.7万维网WWW"></a>6.7万维网WWW</h3><p>​    是运行在因特网上的一个分布式应用</p><h4 id="万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置"><a href="#万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置" class="headerlink" title="万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置"></a>万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置</h4><p>​        URL的一般形式由四个部分组成<br>​            &lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</p><h4 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h4><h5 id="HTTP-x2F-1-0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接"><a href="#HTTP-x2F-1-0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接" class="headerlink" title="HTTP&#x2F;1.0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接"></a>HTTP&#x2F;1.0采用非持续连接。每次浏览器请求一个文件都要与服务器建立TCP六案件，当收到响应后就立即关闭连接</h5><p>​            每请求一次文档就要有两倍的RTT的开销<br>​            为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但这会大量占用万维网服务器资源</p><h5 id="HTTP-x2F-1-1采用持续连接。"><a href="#HTTP-x2F-1-1采用持续连接。" class="headerlink" title="HTTP&#x2F;1.1采用持续连接。"></a>HTTP&#x2F;1.1采用持续连接。</h5><p>​        HTTP是面向文本，其报文中的每一个字段都是一些ASCLL码串，并且每个字段的长度都是不确定的</p><h5 id="使用Cookie在服务器上记录用于信息"><a href="#使用Cookie在服务器上记录用于信息" class="headerlink" title="使用Cookie在服务器上记录用于信息"></a>使用Cookie在服务器上记录用于信息</h5><p>​            Cookie是一种对无状态的HTTP进行状态化的技术</p><h5 id="万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器"><a href="#万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器" class="headerlink" title="万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器"></a>万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器</h5><h5 id="Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源"><a href="#Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源" class="headerlink" title="Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源"></a>Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源</h5>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理_总线</title>
      <link href="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/"/>
      <url>/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h3><h4 id="一、为什么要用总线"><a href="#一、为什么要用总线" class="headerlink" title="一、为什么要用总线"></a>一、为什么要用总线</h4><p>分散连接存在的问题：</p><p>​    1.内部的连线复杂</p><p>​    2.新增IO设备困难</p><h4 id="二、什么是总线"><a href="#二、什么是总线" class="headerlink" title="二、什么是总线"></a>二、什么是总线</h4><p>​        总线是连接各个部件的信息传输线，是<strong>各个部件共享的传输介质</strong></p><h4 id="三、总线上信息的传送"><a href="#三、总线上信息的传送" class="headerlink" title="三、总线上信息的传送"></a>三、总线上信息的传送</h4><p>​    串行：所谓的串行就是将要传输的信息一位一位的放在总线上，接收方一位一位的进行接收，支持距离长</p><p>​    并行：需要多条数据线进行传输，数据能同步进行传输，如果传输距离长，线与线之间并行传输，传输信号可能会发生变形，接收方很难接收到正确信号</p><p>四、总线结构</p><p>​    1.单总线结构</p><p>​        所有数据在同一条总线上传输，会发生总线争用问题</p><p>​    2.面向CPU双总线结构</p><p>​        向CPU延生出两条总线，IO总线和M总线，M总线连接主存。</p><p>​        存在问题：一旦IO总线和M总线同时向CPU发送数据，CPU的计算任务还是会被打断。</p><p>​    3.以存储器为中心的双总线结构</p><p>​        从贮存延生两条总线，一条连接系统总线（包括IO设备接口和CPU），一条存储总线连接CPU。</p><hr><h3 id="3-2总线的分类"><a href="#3-2总线的分类" class="headerlink" title="3.2总线的分类"></a>3.2总线的分类</h3><h4 id="1-片内总线（芯片内部的总线）"><a href="#1-片内总线（芯片内部的总线）" class="headerlink" title="1.片内总线（芯片内部的总线）"></a>1.片内总线（芯片内部的总线）</h4><h4 id="2-系统总线（计算机各部件之间的信息）"><a href="#2-系统总线（计算机各部件之间的信息）" class="headerlink" title="2.系统总线（计算机各部件之间的信息）"></a>2.系统总线（计算机各部件之间的信息）</h4><h5 id="1-数据总线"><a href="#1-数据总线" class="headerlink" title="1.数据总线"></a>1.数据总线</h5><p>​            <strong>双向</strong>与机器字长、存储字长有关。通常情况下，总线宽度&lt;&#x3D;机器字长或存储字长</p><h5 id="2-地址总线"><a href="#2-地址总线" class="headerlink" title="2.地址总线"></a>2.地址总线</h5><p>​            <strong>单向</strong>与存储地址、IO地址有关</p><h5 id="3-控制总线"><a href="#3-控制总线" class="headerlink" title="3.控制总线"></a>3.控制总线</h5><p>​            <strong>有出</strong> <strong>有入</strong>：存储器读、存储器写，总线允许、中断确认（都是由CPU向外送）</p><h4 id="3-通信总线"><a href="#3-通信总线" class="headerlink" title="3.通信总线"></a>3.通信总线</h4><p>​        用于<strong>计算机系统之间</strong>或<strong>计算机系统与其他系统</strong>（如控制仪表、移动通信等）之间的通信</p><p>​        传输方式： </p><p>​            串行通信总线 </p><p>​            并行通信总线</p><hr><h3 id="3-3总线特性及性能指标"><a href="#3-3总线特性及性能指标" class="headerlink" title="3.3总线特性及性能指标"></a>3.3总线特性及性能指标</h3><h4 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h4><h5 id="机械特性"><a href="#机械特性" class="headerlink" title="机械特性"></a>机械特性</h5><p>​            尺寸、形状、管脚数以及排列顺序</p><h5 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h5><p>​            传输方向和有效的电平范围</p><h5 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h5><p>​            每根传输线的功能</p><h5 id="时间特性"><a href="#时间特性" class="headerlink" title="时间特性"></a>时间特性</h5><p>​            信号的时序关系</p><h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><ol><li><p>总线宽度： 数据线的根数</p></li><li><p>标准传输率：每秒传输的最大字节数（如MBps）  </p></li><li><p>时钟同步&#x2F;异步：同步还是不同步</p></li><li><p>总线复用： 地址线与数据线复用（如8086）</p></li><li><p>信号线数： 地址线、数据线和控制线的综合</p></li><li><p>总线控制方式： 突发、自动、仲裁、逻辑、计数</p></li><li><p>其他指标： 负载能力</p></li></ol><hr><h3 id="3-4总线结构"><a href="#3-4总线结构" class="headerlink" title="3.4总线结构"></a>3.4总线结构</h3><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p>​        将所有设备都连接在一条总线（系统总线）上</p><h4 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h4><p>​    分为主存总线与IO总线，通过通道（具有特殊功能的处理器，由通道对IO统一管理）进行连接</p><h5 id="主存总线"><a href="#主存总线" class="headerlink" title="主存总线"></a>主存总线</h5><p>​        连接CPU和主存</p><h5 id="IO总线"><a href="#IO总线" class="headerlink" title="IO总线"></a>IO总线</h5><p>​        连接各种IO设备</p><h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><h5 id="结构一："><a href="#结构一：" class="headerlink" title="结构一："></a>结构一：</h5><p>​    分为主存总线、IO总线、DMA总线（直接存储器访问）。</p><p>​    主存总线连接CPU与主存。</p><p>​    IO总线连接CPU与IO接口。</p><p>​    DMA总线连接主存与IO接口。</p><h5 id="结构二："><a href="#结构二：" class="headerlink" title="结构二："></a>结构二：</h5><p>​    分为局部总线、系统总线、扩展总线。</p><p>​    <strong>局部总线</strong>连接CPU和Cache与局部IO控制器。</p><p>​    <strong>系统总线</strong>连接主存与扩展总线接口。</p><p>​    <strong>扩展总线</strong>连接局域网、SCSI、扩展总线接口、Modem、串行接口</p><h4 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h4><p>​    分为局部总线、系统总线、高速总线、扩展总线。</p><p>​    <strong>局部总线</strong>连接CPU和Cache&#x2F;桥。</p><p>​    <strong>系统总线</strong>连接主存与Cache&#x2F;桥。</p><p>​    <strong>高速总线</strong>连接SCSI、图形、多媒体、局域网、Cache&#x2F;桥和扩展总线接口。</p><p>​    <strong>扩展总线</strong>连接FAX、扩展总线接口、Modem、串行接口。</p><h4 id="传统微型机总线结构"><a href="#传统微型机总线结构" class="headerlink" title="传统微型机总线结构"></a>传统微型机总线结构</h4><p>​    分为系统总线和IO总线</p><p>​    <strong>系统总线</strong>通过<strong>33MHz的32位数据通路</strong>连接CPU和主存控制器与存储器。</p><p>​    系统总线通过<strong>标准总线控制器</strong>与IO总线相连。</p><p>​    <strong>IO总线</strong>通过<strong>8MHz的16位数据通路</strong>连接SCSI II控制器、多媒体、高速局域网、高性能图形、Modem等。</p><h4 id="VL-BUS局部总线结构"><a href="#VL-BUS局部总线结构" class="headerlink" title="VL-BUS局部总线结构"></a>VL-BUS局部总线结构</h4><p>​    分为系统总线、VL-BUS总线、IO总线</p><p>​    <strong>系统总线</strong>连接CPU和主存控制器与存储器并延生一条线连接局部总线控制器和VL-BUS总线。</p><p>​    <strong>VL-BUS总线（高速总线）</strong>通过<strong>33MHz的32位数据通路</strong>连接标准总线控制器、SCSI II控制器、多媒体、高速局域网、高性能图形等。</p><p>​    <strong>IO总线</strong>通过<strong>8MHz的16位数据通路</strong>连接标准总线控制器、图文传真、Modem等</p><h4 id="PCI总线结构"><a href="#PCI总线结构" class="headerlink" title="PCI总线结构"></a>PCI总线结构</h4><p>分为系统总线、PCI总线、IO总线</p><p><strong>系统总线</strong>连接CPU、存储器和<strong>PCI桥</strong></p><p><strong>PCI总线</strong>通过<strong>33MHz的32位数据通路</strong>连接标准总线控制器、SCSI II控制器、多媒体、高速局域网、高性能图形等。</p><p><strong>IO总线</strong>通过<strong>8MHz的16位数据通路</strong>连接标准总线控制器、图文传真、Modem等</p><h4 id="多层PCI总线结构"><a href="#多层PCI总线结构" class="headerlink" title="多层PCI总线结构"></a>多层PCI总线结构</h4><p>分为存储器总线与各种桥电路</p><hr><h3 id="3-5总线控制"><a href="#3-5总线控制" class="headerlink" title="3.5总线控制"></a>3.5总线控制</h3><p>如何完成通信过程，保证通信过程的准确性，这就是总线控制</p><h4 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>​        主设备（模块）：对总线由控制权</p><p>​        从设备（模块）：相应从主设备发来的总线命令<strong>（有些设备既可以作为主设备也可以作为从设备）</strong></p><p>​        总线判优控制：</p><p>​            集中式（总线控制部件集中在一起）：</p><h6 id="链式查询方式："><a href="#链式查询方式：" class="headerlink" title="链式查询方式："></a>链式查询方式：</h6><p>​            <img src="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/chainSearch.png" class=""></p><p>​            数据线：用于信息交换过程数据的传输</p><p>​            地址线：主设备与从设备进行数据传输要通过地址总线</p><p>​            BR：所有线通过这条发送总线占用请求</p><p>​            BS：某个设备占用了总线通过这条线告诉其他部件总线忙</p><p>​            BG： 总线授权线</p><p>​            <strong>注意：有一条总线出现故障，后面的电路均无法使用总线</strong></p><h6 id="计时器定时查询方式："><a href="#计时器定时查询方式：" class="headerlink" title="计时器定时查询方式："></a>计时器定时查询方式：</h6><p>​    <img src="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/countSearch.png" class=""></p><p>​            通过BR发送总线占用请求，总线控制部件收到请求后，通过<strong>设备地址</strong>向外传输响应。再通过计数器向IO接口进行查询是否提出了总线占用请求。最后通过BS进行应答。</p><p>​            这种方式优先级确定非常灵活。</p><h6 id="独立请求方式："><a href="#独立请求方式：" class="headerlink" title="独立请求方式："></a>独立请求方式：</h6><p>​    <img src="/2022/04/15/ji-suan-ji-zu-cheng-yuan-li-zong-xian/SingleQuestion.png" class=""></p><p>​    在总线控制部件中有排队器进行优先级控制</p><p>​        分布式：</p><p>​    </p><h4 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h4><p>​    目的：解决通信双方协同配合问题</p><h5 id="总线传输周期"><a href="#总线传输周期" class="headerlink" title="总线传输周期"></a>总线传输周期</h5><p>​        申请分配阶段：主模块申请，总线仲裁决定</p><p>​        寻址阶段：主模块向从模块给出地址和命令</p><p>​        传数阶段：主模块和从模块交换数据</p><p>​        结束阶段：主模块撤销有关信息</p><h5 id="总线通信的四种方式"><a href="#总线通信的四种方式" class="headerlink" title="总线通信的四种方式"></a>总线通信的四种方式</h5><p>​        同步通信：由统一时标控制数据传送</p><p>​        异步通信：采用应答方式，没有公告时钟标准</p><p>​        半同步通信：同步、异步结合</p><p>​            同步： 发送方用系统时钟前沿发信号</p><p>​                        接收方用系统时钟后延判断、识别</p><p>​            异步：允许不同速度的模块和谐工作</p><p>​                        增加一条“等待”响应信号</p><p>​        上述三种通信的共同点：</p><p>​        一个总线传输周期（以输入数据为例）</p><ul><li>​    主模块发地址、命令   占用总线</li><li>​     从模块准备数据    不占用总线（此时总线空闲，对总线资源是一种浪费）</li><li>​     从模块向主模块发数据  占用总线</li></ul><p>​        分离式通信：充分挖掘系统总线每个瞬间的最大效能</p><p>​            一个总线传输周期</p><p>​                子周期1    主模块申请占用总线，使用完后即放弃总线的使用权</p><p>​                子周期2     从模块申请占用总线，将各种信息送至总线上</p><p>​            分离式通信特点：</p><ol><li>​    各模块有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲</li></ol><p><strong>说明：以上图片与内容均在中国大学MOOC刘教授（刘宏伟）的网课下的总结与摘录</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_运输层</title>
      <link href="/2022/04/15/yun-shu-ceng/"/>
      <url>/2022/04/15/yun-shu-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="5-1运输层概述"><a href="#5-1运输层概述" class="headerlink" title="5.1运输层概述"></a>5.1运输层概述</h3><p>​    如何为运行在不同主机上的应用进程提供直接的通信服务使运输层的任务<br>​    它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道<br>​    因特网的运输层位应用层提供了两种不同的运输协议，即面向<strong>连接的TCP和无连接的UDP</strong></p><hr><h3 id="5-2运输层端口号、复用与分用的概念"><a href="#5-2运输层端口号、复用与分用的概念" class="headerlink" title="5.2运输层端口号、复用与分用的概念"></a>5.2运输层端口号、复用与分用的概念</h3><p>​    运行在计算机上的进程使用进程标识符PID来标志<br>​    因特网上不同操作系统又使用不同格式的进程标识符</p><h4 id="TCP-x2F-IP体系的运输层使用端口号来区分应用层的不同应用进程"><a href="#TCP-x2F-IP体系的运输层使用端口号来区分应用层的不同应用进程" class="headerlink" title="TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程"></a>TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程</h4><h5 id="端口号使用16比特表示，取值范围0-65535"><a href="#端口号使用16比特表示，取值范围0-65535" class="headerlink" title="端口号使用16比特表示，取值范围0~65535"></a>端口号使用16比特表示，取值范围0~65535</h5><p>​            熟知端口号：0<del>1023，IANA把这些端口号派给了TCP&#x2F;IP体系中最重要的一些应用协议<br>​            登记端口号：1024</del>49151，为没有熟知端口号的应用程序使用<br>​            短暂端口号：49152~65535，留给客户进程选择暂时使用</p><h5 id="端口号只具有本地意义，不同计算机中的相同端口号使没有联系的"><a href="#端口号只具有本地意义，不同计算机中的相同端口号使没有联系的" class="headerlink" title="端口号只具有本地意义，不同计算机中的相同端口号使没有联系的"></a>端口号只具有本地意义，不同计算机中的相同端口号使没有联系的</h5><hr><h3 id="5-3UDP和TCP的对比"><a href="#5-3UDP和TCP的对比" class="headerlink" title="5.3UDP和TCP的对比"></a>5.3UDP和TCP的对比</h3><h4 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h4><p>​        无连接的UDP<br>​        UDP支持单播、多播以及广播<br>​        UDP使面向应用报文<br>​        提供不可靠传输，不使用流量控制和拥塞控制<br>​        首部开销小，仅8字节</p><h4 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h4><p>​        面向连接TCP<br>​        TCP仅支持单播<br>​        面向字节流<br>​        提供可靠传输<br>​        首部最少20字节，至多60字节</p><hr><h3 id="5-4TCP的流量控制"><a href="#5-4TCP的流量控制" class="headerlink" title="5.4TCP的流量控制"></a>5.4TCP的流量控制</h3><p>​    流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收<br>​    利用滑动窗口机制来实现TCP连接上对发送方的流量控制<br>​    当发送窗口被调控为0且接收方发送的ACK帧丢失了，发送方抑制等待接收方非零窗口的通知，接收方也一直等待发送方发送的数据，这种状态就称为死锁<br>​        发送方可启用持续计时器，当持续计时器超时发送零窗口探测报文，当接收到rwnd!&#x3D;0时就可打破死锁局面</p><hr><h3 id="5-5TCP的拥塞控制"><a href="#5-5TCP的拥塞控制" class="headerlink" title="5.5TCP的拥塞控制"></a>5.5TCP的拥塞控制</h3><p>​    若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做拥塞<br>​    若出现拥塞而不进行控制，整个网络的吞吐量将随输入符负荷的增大而下降</p><h4 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h4><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>​            <strong>cwnd</strong>呈指数增长<br>​            慢开始指一开始向网络注入的报文段少，并不是指<strong>拥塞窗口cwnd</strong>增长速度慢<br>​        拥塞避免<br>​            <strong>cwnd</strong>呈线性加1<br>​            当启动重传计时器超时判断网络很可能出现了拥塞<br>​                将ssthresh值更新为发生拥塞时swnd值的一半<br>​                将cwnd值减少为1，并重新开始执行慢开始算法</p><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>​            可以让发送方尽早知道发生了个别报文段的丢失<br>​            就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传<br>​            要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认<br>​            即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认<br>​            发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传</p><h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>​            就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法<br>​            发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半‘开始执行拥塞避免算法<br>​            也有的快恢复是把快恢复时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3<br>​        发送方维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化<br>​            <strong>拥塞窗口cwnd的维护原则</strong>：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要网络出现拥塞，拥塞窗口就减少一些<br>​            判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发送超时重传）<br>​        发送方将拥塞窗口作为发送窗口swnd。即<strong>swnd &#x3D; cwnd</strong><br>​        维护一个慢开始门限ssthresh状态变量<br>​            当<strong>cwnd &lt; ssthresh**时，使用慢开始算法<br>​            当**cwnd &gt; ssthresh</strong>时，停止使用慢开始算法而改用拥塞避免算法<br>​            当<strong>cwnd &#x3D; ssthresh</strong>时，即可使用慢开始算法，也可使用拥塞避免算法</p><hr><h3 id="5-6TCP超时重传时间的选择"><a href="#5-6TCP超时重传时间的选择" class="headerlink" title="5.6TCP超时重传时间的选择"></a>5.6TCP超时重传时间的选择</h3><h4 id="加权平均往返时间RTTs"><a href="#加权平均往返时间RTTs" class="headerlink" title="加权平均往返时间RTTs"></a>加权平均往返时间RTTs</h4><p>$$<br>RTTs1 &#x3D; RTT1\\<br>新的RTTs &#x3D; (1 -α) * 旧的RTTs + α * 新的RTTs样本\\<br>0 &lt;&#x3D; α &lt; 1\\<br>已成为建议标准的RFC6298推荐的α值为0.125<br>$$</p><h4 id="RTT偏差的加权平均RTTD"><a href="#RTT偏差的加权平均RTTD" class="headerlink" title="RTT偏差的加权平均RTTD"></a>RTT偏差的加权平均RTTD</h4><p>$$<br>RTTD_1 &#x3D; RTT\frac{1}{2}\\<br>新的RTTD &#x3D; (1-β) × 旧的RTTD + β * |RTTs - 新的RTT样本 |\\</p><p>0 &lt;&#x3D; β &lt; 1\\<br>已成为建议标准的RFC6298推荐的β值为0.25<br>$$</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>$$<br>RTO &#x3D; RTTs +4 × RTTD<br>$$</p><h4 id="出现超时重传时，新RTO-x3D-2倍的旧RTO"><a href="#出现超时重传时，新RTO-x3D-2倍的旧RTO" class="headerlink" title="出现超时重传时，新RTO&#x3D;2倍的旧RTO"></a>出现超时重传时，新RTO&#x3D;2倍的旧RTO</h4><hr><h3 id="5-7TCP可靠传输的实现"><a href="#5-7TCP可靠传输的实现" class="headerlink" title="5.7TCP可靠传输的实现"></a>5.7TCP可靠传输的实现</h3><h4 id="TCP基于以字节为单位的滑动窗口来实现可靠传输"><a href="#TCP基于以字节为单位的滑动窗口来实现可靠传输" class="headerlink" title="TCP基于以字节为单位的滑动窗口来实现可靠传输"></a>TCP基于以字节为单位的滑动窗口来实现可靠传输</h4><h4 id="发送方的发送窗口并不总是和接收放的窗口一样大"><a href="#发送方的发送窗口并不总是和接收放的窗口一样大" class="headerlink" title="发送方的发送窗口并不总是和接收放的窗口一样大"></a>发送方的发送窗口并不总是和接收放的窗口一样大</h4><p>​        网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的<br>​        发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</p><h4 id="对于不按序到达的数据应如何处理，TCP并无明确规定"><a href="#对于不按序到达的数据应如何处理，TCP并无明确规定" class="headerlink" title="对于不按序到达的数据应如何处理，TCP并无明确规定"></a>对于不按序到达的数据应如何处理，TCP并无明确规定</h4><p>​        TCP通常对不按序到达的数据先临时存放再接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</p><h4 id="TCP要求接收方必须有累计确认和捎带确认机制"><a href="#TCP要求接收方必须有累计确认和捎带确认机制" class="headerlink" title="TCP要求接收方必须有累计确认和捎带确认机制"></a>TCP要求接收方必须有累计确认和捎带确认机制</h4><p>​        接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传</p><h4 id="TCP的通信是全双工通信"><a href="#TCP的通信是全双工通信" class="headerlink" title="TCP的通信是全双工通信"></a>TCP的通信是全双工通信</h4><hr><h3 id="5-8TCP的运输连接管理"><a href="#5-8TCP的运输连接管理" class="headerlink" title="5.8TCP的运输连接管理"></a>5.8TCP的运输连接管理</h3><h4 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h4><h5 id="TCP是面向连接的协议，它基于运输连接来传输TCP报文段"><a href="#TCP是面向连接的协议，它基于运输连接来传输TCP报文段" class="headerlink" title="TCP是面向连接的协议，它基于运输连接来传输TCP报文段"></a>TCP是面向连接的协议，它基于运输连接来传输TCP报文段</h5><h5 id="TCP运输连接有以下三个阶段"><a href="#TCP运输连接有以下三个阶段" class="headerlink" title="TCP运输连接有以下三个阶段"></a>TCP运输连接有以下三个阶段</h5><p>​            建立TCP连接<br>​            数据传送<br>​            释放TCP连接</p><h5 id="TCP的连接建立要解决三个问题"><a href="#TCP的连接建立要解决三个问题" class="headerlink" title="TCP的连接建立要解决三个问题"></a>TCP的连接建立要解决三个问题</h5><p>​            使TCP双方能够确知对方的存在<br>​            使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）<br>​            使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</p><h5 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h5><h6 id="TCP客户端发送同步位SYN-x3D-1-序号字段seq-x3D-x"><a href="#TCP客户端发送同步位SYN-x3D-1-序号字段seq-x3D-x" class="headerlink" title="TCP客户端发送同步位SYN&#x3D;1 序号字段seq &#x3D; x"></a>TCP客户端发送同步位SYN&#x3D;1 序号字段seq &#x3D; x</h6><p>​                SYN&#x3D;1的数据段不能携带数据</p><h6 id="TCP服务器发送SYN-x3D-1和确认位ACK-x3D-1-序号字段seq-x3D-y-确认号字段ack-x3D-x-1"><a href="#TCP服务器发送SYN-x3D-1和确认位ACK-x3D-1-序号字段seq-x3D-y-确认号字段ack-x3D-x-1" class="headerlink" title="TCP服务器发送SYN&#x3D;1和确认位ACK&#x3D;1 序号字段seq &#x3D; y 确认号字段ack &#x3D; x +1"></a>TCP服务器发送SYN&#x3D;1和确认位ACK&#x3D;1 序号字段seq &#x3D; y 确认号字段ack &#x3D; x +1</h6><h6 id="TCP客户端发送确认位ACK-x3D-1-序号字段seq-x3D-x-1-ack-x3D-y-1"><a href="#TCP客户端发送确认位ACK-x3D-1-序号字段seq-x3D-x-1-ack-x3D-y-1" class="headerlink" title="TCP客户端发送确认位ACK&#x3D;1 序号字段seq &#x3D; x +1 ack &#x3D; y +1"></a>TCP客户端发送确认位ACK&#x3D;1 序号字段seq &#x3D; x +1 ack &#x3D; y +1</h6><h6 id="普通的确认报文段如果不懈怠数据，则不消耗序号"><a href="#普通的确认报文段如果不懈怠数据，则不消耗序号" class="headerlink" title="普通的确认报文段如果不懈怠数据，则不消耗序号"></a>普通的确认报文段如果不懈怠数据，则不消耗序号</h6><h5 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h5><h6 id="客户TCP向服务器TCP发送进程终止报文段，终止位FIN-x3D-1-ACK-x3D-1-seq-x3D-u-等于TCP客户进程之前已传送过的数据最后一个字节的序号-1-，ack-x3D-v-等于TCP客户进程之前已收到过的数据最后一个字节的序号-1"><a href="#客户TCP向服务器TCP发送进程终止报文段，终止位FIN-x3D-1-ACK-x3D-1-seq-x3D-u-等于TCP客户进程之前已传送过的数据最后一个字节的序号-1-，ack-x3D-v-等于TCP客户进程之前已收到过的数据最后一个字节的序号-1" class="headerlink" title="客户TCP向服务器TCP发送进程终止报文段，终止位FIN &#x3D; 1 , ACK &#x3D; 1 , seq &#x3D; u(等于TCP客户进程之前已传送过的数据最后一个字节的序号+1)，ack &#x3D; v(等于TCP客户进程之前已收到过的数据最后一个字节的序号+1)"></a>客户TCP向服务器TCP发送进程终止报文段，终止位FIN &#x3D; 1 , ACK &#x3D; 1 , seq &#x3D; u(等于TCP客户进程之前已传送过的数据最后一个字节的序号+1)，ack &#x3D; v(等于TCP客户进程之前已收到过的数据最后一个字节的序号+1)</h6><h6 id="服务器TCP向客户TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-v-ack-x3D-u-1"><a href="#服务器TCP向客户TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-v-ack-x3D-u-1" class="headerlink" title="服务器TCP向客户TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; v ,ack &#x3D; u+1"></a>服务器TCP向客户TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; v ,ack &#x3D; u+1</h6><h6 id="这时服务器TCP还可以向TCP客户发送报文段"><a href="#这时服务器TCP还可以向TCP客户发送报文段" class="headerlink" title="这时服务器TCP还可以向TCP客户发送报文段"></a>这时服务器TCP还可以向TCP客户发送报文段</h6><h6 id="服务器TCP向客户TCP发送TCP连续释放，该报文段FIN-x3D-1-ACK-x3D-1-seq-x3D-w-ack-x3D-u-1"><a href="#服务器TCP向客户TCP发送TCP连续释放，该报文段FIN-x3D-1-ACK-x3D-1-seq-x3D-w-ack-x3D-u-1" class="headerlink" title="服务器TCP向客户TCP发送TCP连续释放，该报文段FIN &#x3D; 1,ACK &#x3D; 1 , seq &#x3D; w ,ack &#x3D; u+1"></a>服务器TCP向客户TCP发送TCP连续释放，该报文段FIN &#x3D; 1,ACK &#x3D; 1 , seq &#x3D; w ,ack &#x3D; u+1</h6><h6 id="客户TCP向服务器TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-u-1-ack-x3D-w-1"><a href="#客户TCP向服务器TCP发送TCP普通确认，该报文段ACK-x3D-1-seq-x3D-u-1-ack-x3D-w-1" class="headerlink" title="客户TCP向服务器TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; u+1 ,ack &#x3D; w+1"></a>客户TCP向服务器TCP发送TCP普通确认，该报文段ACK &#x3D; 1 , seq &#x3D; u+1 ,ack &#x3D; w+1</h6><h6 id="TCP客户端进入时间等待要等待2MSL后才进入关闭"><a href="#TCP客户端进入时间等待要等待2MSL后才进入关闭" class="headerlink" title="TCP客户端进入时间等待要等待2MSL后才进入关闭"></a>TCP客户端进入时间等待要等待2MSL后才进入关闭</h6><p>​            MSL使最大报文段寿命，RFC793建议位2分钟</p><h6 id="TCP服务器进程每收到TCP客户进程的数据，-就重新设置并启动保活计时器（2小时定时）"><a href="#TCP服务器进程每收到TCP客户进程的数据，-就重新设置并启动保活计时器（2小时定时）" class="headerlink" title="TCP服务器进程每收到TCP客户进程的数据， 就重新设置并启动保活计时器（2小时定时）"></a>TCP服务器进程每收到TCP客户进程的数据， 就重新设置并启动保活计时器（2小时定时）</h6><h6 id="若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接"><a href="#若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接" class="headerlink" title="若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接"></a>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器就向TCP客户发送一个探测报文段，若一连10次探测报文段后TCP进程仍无响应，则关闭连接</h6><hr><h3 id="5-9TCP报文段首部格式"><a href="#5-9TCP报文段首部格式" class="headerlink" title="5.9TCP报文段首部格式"></a>5.9TCP报文段首部格式</h3><p>​    为了实现可靠传输，TCP采用了面向字节流的方式</p><h4 id="固定首部（20字节）"><a href="#固定首部（20字节）" class="headerlink" title="固定首部（20字节）"></a>固定首部（20字节）</h4><h5 id="源端口（16字节）"><a href="#源端口（16字节）" class="headerlink" title="源端口（16字节）"></a>源端口（16字节）</h5><p>​            用来标识发送该TCP报文段的应用进程</p><h5 id="目的端口（16字节）"><a href="#目的端口（16字节）" class="headerlink" title="目的端口（16字节）"></a>目的端口（16字节）</h5><p>​            标识接收该TCP报文段的应用进程</p><h5 id="序号（32比特）"><a href="#序号（32比特）" class="headerlink" title="序号（32比特）"></a>序号（32比特）</h5><p>​            指出本TCP报文段数据载荷的第一个字节的序号</p><h5 id="确认号（32比特）"><a href="#确认号（32比特）" class="headerlink" title="确认号（32比特）"></a>确认号（32比特）</h5><p>​            指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认</p><h5 id="数据偏移（4比特，并以4字节为单位）"><a href="#数据偏移（4比特，并以4字节为单位）" class="headerlink" title="数据偏移（4比特，并以4字节为单位）"></a>数据偏移（4比特，并以4字节为单位）</h5><p>​            指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远，这个字段实际是指出了TCP报文段的首部长度</p><h5 id="保留（6比特）保留今后使用，目前应置为0"><a href="#保留（6比特）保留今后使用，目前应置为0" class="headerlink" title="保留（6比特）保留今后使用，目前应置为0"></a>保留（6比特）保留今后使用，目前应置为0</h5><h5 id="ACK：取值位1时确认号字段才有效，0为无效"><a href="#ACK：取值位1时确认号字段才有效，0为无效" class="headerlink" title="ACK：取值位1时确认号字段才有效，0为无效"></a>ACK：取值位1时确认号字段才有效，0为无效</h5><h5 id="窗口（16比特，以字节为单位）"><a href="#窗口（16比特，以字节为单位）" class="headerlink" title="窗口（16比特，以字节为单位）"></a>窗口（16比特，以字节为单位）</h5><p>​            指出发送本报文段的一方的接收窗口</p><h5 id="校验和（16比特）"><a href="#校验和（16比特）" class="headerlink" title="校验和（16比特）"></a>校验和（16比特）</h5><p>​            检查范围包括TCP报文段的首部和数据载荷两部分</p><h5 id="同步标志位SYN：在TCP连接建立时同步序号"><a href="#同步标志位SYN：在TCP连接建立时同步序号" class="headerlink" title="同步标志位SYN：在TCP连接建立时同步序号"></a>同步标志位SYN：在TCP连接建立时同步序号</h5><h5 id="终止标志位FIN：用来释放TCP连接"><a href="#终止标志位FIN：用来释放TCP连接" class="headerlink" title="终止标志位FIN：用来释放TCP连接"></a>终止标志位FIN：用来释放TCP连接</h5><h5 id="复位标志位RST-用来复位TCP连接，当RST-x3D-1时，表明TCP连接出现了异常，必须释放连接"><a href="#复位标志位RST-用来复位TCP连接，当RST-x3D-1时，表明TCP连接出现了异常，必须释放连接" class="headerlink" title="复位标志位RST:用来复位TCP连接，当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接"></a>复位标志位RST:用来复位TCP连接，当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接</h5><h5 id="推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付"><a href="#推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付" class="headerlink" title="推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付"></a>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付</h5><h5 id="进击标志位URG：取值为1时紧急指针字段有效，0为无效"><a href="#进击标志位URG：取值为1时紧急指针字段有效，0为无效" class="headerlink" title="进击标志位URG：取值为1时紧急指针字段有效，0为无效"></a>进击标志位URG：取值为1时紧急指针字段有效，0为无效</h5><h5 id="紧急指针（16比特，以字节为单位）"><a href="#紧急指针（16比特，以字节为单位）" class="headerlink" title="紧急指针（16比特，以字节为单位）"></a>紧急指针（16比特，以字节为单位）</h5><h4 id="扩展首部（最大40字节）"><a href="#扩展首部（最大40字节）" class="headerlink" title="扩展首部（最大40字节）"></a>扩展首部（最大40字节）</h4><h5 id="选项（长度可变）"><a href="#选项（长度可变）" class="headerlink" title="选项（长度可变）"></a>选项（长度可变）</h5><p>​            最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度</p><h5 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h5><p>​            用来确保报文段首部能被4整除</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 运输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueRouter</title>
      <link href="/2022/04/14/vueroute/"/>
      <url>/2022/04/14/vueroute/</url>
      
        <content type="html"><![CDATA[<h4 id="路由的基本概念"><a href="#路由的基本概念" class="headerlink" title="路由的基本概念"></a>路由的基本概念</h4><p><strong>2022年2月7日以后，<code>vue-router</code>的默认版本，为Vue3专属的4版本</strong></p><p><code>Vue</code>的一个插件库，专门来实现SPA应用</p><h5 id="路由就是一组key-value的对应关系"><a href="#路由就是一组key-value的对应关系" class="headerlink" title="路由就是一组key-value的对应关系"></a>路由就是一组key-value的对应关系</h5><p><code>key</code>为路径，<code>value</code>肯使<code>function</code>或<code>component</code></p><p><code>route</code>规则: <code>/example</code> &#x3D;&gt; 例子组件</p><h4 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h4><p>先创建两个组件</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--组件1--&gt;&lt;template&gt;&lt;h2&gt;        我是About内容    &lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;      name:&#39;About&#39;  &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--组件2--&gt;&lt;template&gt;&lt;h2&gt;        我是Home内容    &lt;&#x2F;h2&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;      name:&#39;Home&#39;  &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//入口文件main.js</span><span class="token comment">//引入Vue</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment">//引入App</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token comment">//引入VueRouter</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入路由器</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token literal-property property">router</span><span class="token operator">:</span>router<span class="token punctuation">,</span>  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>新建路由器文件</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'../components/Home'</span><span class="token comment">//创建一个路由器</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>Home        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>在<code>App</code>入口文件中新建样式引用组件</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!--原始html中用a标签实现页面的跳转--&gt;&lt;!-- &lt;a href&#x3D;&quot;.&#x2F;about.html&quot;&gt;About&lt;&#x2F;a&gt; --&gt;&lt;!-- &lt;a href&#x3D;&quot;.&#x2F;home.html&quot;&gt;Home&lt;&#x2F;a&gt; --&gt;&lt;!--原始html中用a标签实现页面的跳转 active-class是激活时候的样式--&gt;&lt;router-link to&#x3D;&quot;&#x2F;about&quot; active-class&#x3D;&quot;&quot;&gt;About&lt;&#x2F;router-link&gt;&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;Home&lt;&#x2F;router-link&gt;&lt;!--router-view--&gt;&lt;router-view&gt;&lt;&#x2F;router-view&gt;&lt;&#x2F;template&gt;</code></pre><p>路由的基本功能就能实现了。</p><h4 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h4><p>以上方页面为基准，修改<code>index.js</code>路由文件和新建两个子级路由。</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--Message页面--&gt;&lt;template&gt;&lt;div&gt;        &lt;ul&gt;            &lt;li&gt;消息&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        name:&#39;Message&#39;    &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--News页面--&gt;&lt;template&gt;&lt;div&gt;        &lt;ul&gt;            &lt;li&gt;新闻&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        name:&#39;News&#39;    &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'../components/Home'</span><span class="token keyword">import</span> News <span class="token keyword">from</span> <span class="token string">'../components/News'</span><span class="token keyword">import</span> Message <span class="token keyword">from</span> <span class="token string">'../components/Message'</span><span class="token comment">//创建一个路由器</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>Home<span class="token punctuation">,</span>            <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span> <span class="token comment">//子路由</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'news'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>News                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>Message                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>再将需要调用的home页面中的<code>a</code>标签进行修改为<code>router-link</code>。并用<code>router-view</code>进行子路由的显示。</p><p><strong><code>router-link</code>中的<code>to</code>路径要为“&#x2F;一级路由&#x2F;二级路由&#x2F;….”</strong></p><h4 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h4><h5 id="以query进行传参"><a href="#以query进行传参" class="headerlink" title="以query进行传参"></a>以<code>query</code>进行传参</h5><p>把上方的写死的数据存在<code>data</code>中来进行传参。</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--Message页面--&gt;&lt;template&gt;&lt;div&gt;        &lt;ul&gt;            &lt;li v-for&#x3D;&quot;m in massageList&quot; :key&#x3D;&quot;m.id&quot;&gt;               &lt;!--传参以&#39;?&#39;进行分割,to的字符串写法--&gt;               &lt;!-- &lt;router-link :to&#x3D;&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;&#123;m.id&#125;&amp;title&#x3D;                 &#123;m.title&#125;&#96;&gt;&#123;&#123;m.title&#125;&#125;&lt;&#x2F;router-link&gt; --&gt;                 &lt;!--传参以&#39;?&#39;进行分割,to的对象写法--&gt;               &lt;router-link :to&#x3D;&quot;&#123;                  path:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,                  query:&#123;                    id:m.id,                    title:m.title                  &#125;                &#125;&quot;&gt;                   &#123;&#123;m.title&#125;&#125;       &lt;&#x2F;router-link&gt;    &lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;        &lt;!--展示detail页面--&gt;        &lt;router-view&gt;&lt;&#x2F;router-view&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        name:&#39;Message&#39;,        data () &#123;            return &#123;                massageList:[                    &#123;id:&#39;001&#39;,title:&#39;消息1&#39;&#125;,                    &#123;id:&#39;002&#39;,title:&#39;消息2&#39;&#125;,                    &#123;id:&#39;003&#39;,title:&#39;消息3&#39;&#125;                ]            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--用来接收传递过来数据的Detail页面--&gt;&lt;template&gt;&lt;ul&gt;        &lt;li&gt;消息编号：&#123;&#123;$route.query.id&#125;&#125;&lt;&#x2F;li&gt;        &lt;li&gt;消息标题：&#123;&#123;$route.query.id&#125;&#125;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default&#123;      name:&#39;Detail&#39;  &#125;&lt;&#x2F;script&gt;</code></pre><p>再对路由配置信息页面进行修改</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'../components/Home'</span><span class="token keyword">import</span> News <span class="token keyword">from</span> <span class="token string">'../components/News'</span><span class="token keyword">import</span> Message <span class="token keyword">from</span> <span class="token string">'../components/Message'</span><span class="token keyword">import</span> Detail <span class="token keyword">from</span> <span class="token string">'../components/Detail'</span><span class="token comment">//创建一个路由器</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>Home<span class="token punctuation">,</span>            <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span> <span class="token comment">//子路由</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'news'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>News                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token comment">//子路由就不需要再加'/'</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>Message<span class="token punctuation">,</span>                    <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span>                        <span class="token punctuation">&#123;</span>                    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'detail'</span><span class="token punctuation">,</span>                    <span class="token literal-property property">component</span><span class="token operator">:</span>Detail                <span class="token punctuation">&#125;</span>                    <span class="token punctuation">]</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h5 id="以params进行传参"><a href="#以params进行传参" class="headerlink" title="以params进行传参"></a>以<code>params</code>进行传参</h5><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--传参格式 &#39;路由&#x2F;参数&#x2F;参数&#x2F;...&#39;--&gt;&lt;router-link :to&#x3D;&quot;&#x2F;detail&#x2F;66&#x2F;消息&quot;&gt;&lt;&#x2F;router-link&gt;</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//路由的index.js</span><span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'detail/:id/:title'</span></code></pre><p>在页面使用对象方法传参配置时候不能使用<code>path</code>作为路径跳转必须舒勇<code>name</code>形式。剩下部分与<code>query</code>基本相同。</p><h4 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的<code>props</code>配置</h4><p>传参的时候以<code>query</code>方式进行传参</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//路由的index.js</span><span class="token literal-property property">component</span><span class="token operator">:</span>Detail<span class="token punctuation">,</span><span class="token comment">//props第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件</span><span class="token comment">//用的比较少，传递的为死数据</span><span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">b</span><span class="token operator">:</span><span class="token string">'helloWorld'</span><span class="token punctuation">&#125;</span><span class="token comment">//props第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件</span><span class="token literal-property property">props</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token comment">//props第三种写法，值为函数</span><span class="token function">props</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span><span class="token literal-property property">query</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>id<span class="token punctuation">,</span>title<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//直接用解构来获取$router中query参数</span>    <span class="token keyword">return</span><span class="token punctuation">&#123;</span><span class="token literal-property property">id</span><span class="token operator">:</span><span class="token string">'id'</span><span class="token punctuation">,</span><span class="token literal-property property">title</span><span class="token operator">:</span><span class="token string">'title'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在<code>Detail</code>组件中接收</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;ul&gt;        &lt;!--&lt;li&gt;&#123;&#123;a&#125;&#125;&lt;&#x2F;li&gt;--&gt;        &lt;!--&lt;li&gt;&#123;&#123;b&#125;&#125;&lt;&#x2F;li&gt;--&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default&#123;        name:&#39;Detail&#39;,        &#x2F;&#x2F;id和title由上方Message组件传递        &#x2F;&#x2F;第一种方式接收        props:[&#39;a&#39;,&#39;b&#39;],        &#x2F;&#x2F;第二种方式接收        computed:&#123;            id()&#123;                return this.$route.query.id            &#125;,            title()&#123;                return this.$route.query.title            &#125;        &#125;        &#x2F;&#x2F;第三种方式接收        props:[&#39;id&#39;,&#39;title&#39;]        ...&#x2F;&#x2F;方便演示就不显示其他数据了    &#125;&lt;&#x2F;script&gt;</code></pre><h4 id="浏览器历史记录"><a href="#浏览器历史记录" class="headerlink" title="浏览器历史记录"></a>浏览器历史记录</h4><p>​    浏览器的结构为栈形式。</p><p>​    浏览器默认保存历史记录的方式为<code>push</code>，即压栈。</p><p>​    <code>router-link</code>默认开启的为<code>push</code>模式，可以在<code>router-link</code>中添加<code>replace</code>改变浏览器的保存历史记录模式。（只对使用的连接起作用）</p><h4 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h4><p><code>routuer-link</code>在页面中默认转换为<code>a</code>标签，要想让按钮等能触发点击的事件进行页面跳转，就得使用编程式路由导航。</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;!--前面写的Message页面，其他就不再重复写了--&gt;&lt;template&gt;&lt;button @click&#x3D;&quot;pushShow&quot;&gt;        跳转到Home页面    &lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;        name:&#39;Message&#39;,        methods: &#123;            pushShow()&#123;                &#x2F;&#x2F;push为默认的方式，可更换为replace                 this.$router.push(&#123;                    path:&#39;&#x2F;home&#39;,                    query:&#123;                        id:this.$store.query.id,                        title:this.$store.query.title                    &#125;                &#125;)            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h4 id="两个新生命钩子"><a href="#两个新生命钩子" class="headerlink" title="两个新生命钩子"></a>两个新生命钩子</h4><p>当路由被缓存并在挂载前设定了<code>setInterval</code>等方法。因为组件被路由缓存了并不会触发销毁流程但页面又没有进行显示，此时会浪费浏览器资源就需要用新的生命钩子来对方法进行清除。</p><h5 id="activated-激活"><a href="#activated-激活" class="headerlink" title="activated(激活)"></a>activated(激活)</h5><p>当路由被激活时该钩子被调用</p><h5 id="deactivated-失活"><a href="#deactivated-失活" class="headerlink" title="deactivated(失活)"></a>deactivated(失活)</h5><p>当路由失活时候该钩子被调用</p><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>路由守卫用来设置权限</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//router的index.js文件</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token comment">//引入组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">'../components/About'</span><span class="token operator">...</span><span class="token comment">//创建一个路由器</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">routers</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/about'</span><span class="token punctuation">,</span>            <span class="token literal-property property">component</span><span class="token operator">:</span>About<span class="token punctuation">,</span>            <span class="token comment">//用meta来判断是否需要权限校验，meta可以创建路由独有的信息</span>            <span class="token literal-property property">meta</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token literal-property property">isAuth</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token comment">//独享路由守卫  与全局路由守卫功能相同</span>            <span class="token function">beforeEnter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">...</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//全局前置路由守卫  初始化的时候被调用、每次路由切换之前调用</span>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//to表示要跳转到的路由页面，from表示从哪个路由开始跳转的</span>    <span class="token comment">//next表示可以放行，可以跳转路由页面</span>    <span class="token comment">//可以通过逻辑判断来让用户是否可以跳转到目标页面</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>isAuth<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//全局后置路由守卫  初始化的时候被调用、每次路由切换之后被调用</span>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span><span class="token keyword">from</span></span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//to表示要跳转到的路由页面，from表示从哪个路由开始跳转的</span>    <span class="token comment">//next表示可以放行，可以跳转路由页面</span>    <span class="token comment">//能进入后置守卫表示能成功进入页面</span>    <span class="token comment">//可以实现点击后页面标题的切换等功能</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> router</code></pre><p>组件内路由守卫</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;...&lt;&#x2F;template&gt;&lt;script&gt;export default&#123;        ...,        &#x2F;&#x2F;通过路由规则，进入该组件时被调用        beforeRouteEnter(to,from,next)&#123;            &#x2F;&#x2F;写的逻辑判断由组件独有            next()        &#125;,        &#x2F;&#x2F;通过路由规则，离开该组件时被调用        beforeRouteLeave(to,from,next)&#123;            next()        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h4 id="history模式与hash模式"><a href="#history模式与hash模式" class="headerlink" title="history模式与hash模式"></a><code>history</code>模式与<code>hash</code>模式</h4><p>使用路由时地址栏会新增<code>#</code>，称为<code>hash</code>，不会随着http请求发给服务器。默认开启的<code>hash</code>模式。</p><p>改变路由模式：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在路由配置中修改</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token comment">//改为history模式，history没有#显示</span>    <span class="token literal-property property">mode</span><span class="token operator">:</span><span class="token string">'history'</span><span class="token punctuation">,</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p><code>history</code>模式的兼容比<code>hash</code>模式差</p><h4 id="路由的几个注意事项"><a href="#路由的几个注意事项" class="headerlink" title="路由的几个注意事项"></a>路由的几个注意事项</h4><p>1.未被路由调用的页面会被销毁而不是隐藏</p><p>2.使用路由的页面会增加路由规则，<code>$route</code>和<code>$router</code>。<code>$route</code>存放自己的路由信息，每个页面均不相同，<code>$router</code>相同</p><p>3.路由组件通常存放在<code>pages</code>文件夹</p><p>4.可以通过<code>keep-alive</code>对路由组件进行缓存不会进行销毁，<code>keep-alive</code>放在一级路由中</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!--include来记录要缓存的组件(里面填组件名)，其他的则不缓存。不写则都缓存--&gt;&lt;!--缓存多个写法： :include&#x3D;&quot;[&#39;第一个组件名&#39;,&#39;第二个组件名&#39;]&quot;--&gt;&lt;keep-alive include&#x3D;&quot;&quot;&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;    &lt;&#x2F;keep-alive&gt;&lt;&#x2F;template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> VueRouter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机概论</title>
      <link href="/2022/04/14/ji-suan-ji-gai-lun/"/>
      <url>/2022/04/14/ji-suan-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机的基本构成"><a href="#计算机的基本构成" class="headerlink" title="计算机的基本构成"></a>计算机的基本构成</h3><p><strong>指令格式为：   操作码  地址码</strong></p><h4 id="存储器的基本组成："><a href="#存储器的基本组成：" class="headerlink" title="存储器的基本组成："></a>存储器的基本组成：</h4><p>MAR:存储器地址寄存器，反映存储单元的个数</p><p>MDR:存储器数据寄存器，反映存储字长</p><h4 id="运算器的基本组成："><a href="#运算器的基本组成：" class="headerlink" title="运算器的基本组成："></a>运算器的基本组成：</h4><ul><li><p>ACC:累加器</p></li><li><p>ALU:算数逻辑单元</p></li><li><p>X:操作寄存器</p></li><li><p>MQ:乘商寄存器</p></li></ul><h4 id="控制器的基本组成："><a href="#控制器的基本组成：" class="headerlink" title="控制器的基本组成："></a>控制器的基本组成：</h4><ul><li>PC:存放当前欲执行指令的地址，具有计数功能</li><li>IR:存放当前欲执行的指令</li><li>CU:执行指令</li></ul><h3 id="计算机硬件的性能指标"><a href="#计算机硬件的性能指标" class="headerlink" title="计算机硬件的性能指标"></a>计算机硬件的性能指标</h3><h4 id="1-机器字长"><a href="#1-机器字长" class="headerlink" title="1.机器字长"></a>1.机器字长</h4><p>CPU一次能处理数据的位数与CPU中的<strong>寄存器位数有关</strong></p><h4 id="2-运算速度"><a href="#2-运算速度" class="headerlink" title="2.运算速度"></a>2.运算速度</h4><ul><li><p>主频</p></li><li><p>核数，每个核支持的线程数</p></li><li><p>吉普森法<br>$$<br>T_M &#x3D; \sum^n_{i&#x3D;1}f_it_i<br>$$</p></li><li><p>CPI:执行一条指令所需时钟周期数</p></li><li><p>MIPS：每秒执行百万条指令</p></li><li><p>FLOPS：每秒浮点运算次数</p></li></ul><h4 id="3-存储容量"><a href="#3-存储容量" class="headerlink" title="3.存储容量"></a>3.存储容量</h4><h5 id="主存容量"><a href="#主存容量" class="headerlink" title="主存容量"></a>主存容量</h5><p>​    存储单元个数×存储字长</p><p>​        如MAR MDR 容量(MAR以2为底进行运算)<br>$$<br>1K&#x3D;2^{10}<br>$$<br>​    字节数</p><h5 id="辅存容量"><a href="#辅存容量" class="headerlink" title="辅存容量"></a>辅存容量</h5><p>字节数 如 80GB</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_网络层</title>
      <link href="/2022/04/14/wang-luo-ceng/"/>
      <url>/2022/04/14/wang-luo-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="4-1网络层概述"><a href="#4-1网络层概述" class="headerlink" title="4.1网络层概述"></a>4.1网络层概述</h3><h4 id="网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输"><a href="#网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输" class="headerlink" title="网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输"></a>网络层的主要任务是实现网络互连，进而实现数据包再各网络之间的传输</h4><h4 id="实现网络层任务，需要解决的问题"><a href="#实现网络层任务，需要解决的问题" class="headerlink" title="实现网络层任务，需要解决的问题"></a>实现网络层任务，需要解决的问题</h4><p>​        网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）<br>​        网络层寻址问题<br>​        路由选择问题</p><h4 id="因特网是目前全世界用户最多的互联网，它使用TCP-x2F-IP协议栈"><a href="#因特网是目前全世界用户最多的互联网，它使用TCP-x2F-IP协议栈" class="headerlink" title="因特网是目前全世界用户最多的互联网，它使用TCP&#x2F;IP协议栈"></a>因特网是目前全世界用户最多的互联网，它使用TCP&#x2F;IP协议栈</h4><p>​        由于TCP&#x2F;IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP&#x2F;IP协议栈中网络层常称为网际层</p><hr><h3 id="4-2网络层提供的两种服务"><a href="#4-2网络层提供的两种服务" class="headerlink" title="4.2网络层提供的两种服务"></a>4.2网络层提供的两种服务</h3><h4 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h4><p>​        可靠通信由网络来保证<br>​        必须建立网络层的连接—虚电路VC(Virtual Circuit)<br>​        通信双方沿着已建立的虚电路发送分组<br>​        分组的首部只需携带一条虚电路的编号<br>​        通信结束后，需要释放之前所建立的虚电路</p><h4 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h4><p>​        可靠通信由用户主机来保证<br>​        不需要建立网络层连接<br>​        每个分组可走不同路径<br>​        每个分组首部必须携带目的主机的完整地址<br>​        分组可能误码、丢失、重复和失序<br>​        由于网络本身不提供端到端的可靠传输服务，造价成本相对低廉<br>​        因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心</p><hr><h3 id="4-3-1IPv4地址概述"><a href="#4-3-1IPv4地址概述" class="headerlink" title="4.3.1IPv4地址概述"></a>4.3.1IPv4地址概述</h3><h4 id="是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符"><a href="#是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符" class="headerlink" title="是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符"></a>是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符</h4><h4 id="编址方法经历了三个历史阶段"><a href="#编址方法经历了三个历史阶段" class="headerlink" title="编址方法经历了三个历史阶段"></a>编址方法经历了三个历史阶段</h4><p>​        分类编址（1981）<br>​        划分子网（1985）<br>​        无分类编址（1993）</p><h4 id="采用点分十进制表示方法"><a href="#采用点分十进制表示方法" class="headerlink" title="采用点分十进制表示方法"></a>采用点分十进制表示方法</h4><hr><h3 id="4-3-2分类编址的IPv4地址"><a href="#4-3-2分类编址的IPv4地址" class="headerlink" title="4.3.2分类编址的IPv4地址"></a>4.3.2分类编址的IPv4地址</h3><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h4><h5 id="网络号"><a href="#网络号" class="headerlink" title="网络号"></a>网络号</h5><p>​            8位（最高位固定为0）</p><h5 id="主机号"><a href="#主机号" class="headerlink" title="主机号"></a>主机号</h5><p>​            24位</p><h5 id="最小网络号0，保留不指派"><a href="#最小网络号0，保留不指派" class="headerlink" title="最小网络号0，保留不指派"></a>最小网络号0，保留不指派</h5><h5 id="第一个可指派的网络号为1，网络地址为1-0-0-0"><a href="#第一个可指派的网络号为1，网络地址为1-0-0-0" class="headerlink" title="第一个可指派的网络号为1，网络地址为1.0.0.0"></a>第一个可指派的网络号为1，网络地址为1.0.0.0</h5><h5 id="最大网络号127，作为本地环回测试地址，不指派"><a href="#最大网络号127，作为本地环回测试地址，不指派" class="headerlink" title="最大网络号127，作为本地环回测试地址，不指派"></a>最大网络号127，作为本地环回测试地址，不指派</h5><p>​            最小本地环回测试地址为127.0.0.1<br>​            最大本地环回测试地址为127.255.255.254</p><h5 id="最后一个可指派的网络号为126，网络地址为126-0-0-0"><a href="#最后一个可指派的网络号为126，网络地址为126-0-0-0" class="headerlink" title="最后一个可指派的网络号为126，网络地址为126.0.0.0"></a>最后一个可指派的网络号为126，网络地址为126.0.0.0</h5><p>​<br>$$<br>可指派的网络数量为2^{8-1}-2 &#x3D; 126(除去最小网络号和最大网络号)\\</p><pre><code>    可分配的IP数量为2^&#123;24&#125; - 2 =16777214(除去全0网络地址和全1广播地址)        </code></pre><p>$$</p><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h4><h5 id="网络号-1"><a href="#网络号-1" class="headerlink" title="网络号"></a>网络号</h5><p>​            16位（最高位固定为10）</p><h5 id="主机号-1"><a href="#主机号-1" class="headerlink" title="主机号"></a>主机号</h5><p>​            16位</p><h5 id="最小网络号也是第一个可指派的网络号128-0，网络地址128-0-0-0"><a href="#最小网络号也是第一个可指派的网络号128-0，网络地址128-0-0-0" class="headerlink" title="最小网络号也是第一个可指派的网络号128.0，网络地址128.0.0.0"></a>最小网络号也是第一个可指派的网络号128.0，网络地址128.0.0.0</h5><h5 id="最大网络号也是最后一个可指派的网络号191-255，网络地址191-255-0-0"><a href="#最大网络号也是最后一个可指派的网络号191-255，网络地址191-255-0-0" class="headerlink" title="最大网络号也是最后一个可指派的网络号191.255，网络地址191.255.0.0"></a>最大网络号也是最后一个可指派的网络号191.255，网络地址191.255.0.0</h5><p>​<br>$$<br>可指派的网络数量为2^{16-2}&#x3D; 16384\\<br>        可分配的IP数量为2^{16} - 2 &#x3D;65534(除去全0网络地址和全1广播地址)</p><p>$$<br>​        根据2002年9月发表的RFC 3330文档，128.0可以分配</p><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h4><h5 id="网络号-2"><a href="#网络号-2" class="headerlink" title="网络号"></a>网络号</h5><p>​            24位（最高位固定为110）</p><h5 id="主机号-2"><a href="#主机号-2" class="headerlink" title="主机号"></a>主机号</h5><p>​            8位</p><h5 id="最小网络号也是第一个可指派的网络号192-0-0，网络地址192-0-0-0"><a href="#最小网络号也是第一个可指派的网络号192-0-0，网络地址192-0-0-0" class="headerlink" title="最小网络号也是第一个可指派的网络号192.0.0，网络地址192.0.0.0"></a>最小网络号也是第一个可指派的网络号192.0.0，网络地址192.0.0.0</h5><h5 id="最大网络号也是最后一个可指派的网络号223-255-255，网络地址223-255-255-0"><a href="#最大网络号也是最后一个可指派的网络号223-255-255，网络地址223-255-255-0" class="headerlink" title="最大网络号也是最后一个可指派的网络号223.255.255，网络地址223.255.255.0"></a>最大网络号也是最后一个可指派的网络号223.255.255，网络地址223.255.255.0</h5><p>​<br>$$<br>可指派的网络数量为2^{24-3}&#x3D; 2097152\\<br>        可分配的IP数量为2^8 - 2 &#x3D; 254(除去全0网络地址和全1广播地址)</p><p>$$<br>​        根据2002年9月发表的RFC 3330文档，192.0.0可以分配</p><h4 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h4><h5 id="多播地址"><a href="#多播地址" class="headerlink" title="多播地址"></a>多播地址</h5><p>​            最高位固定1110</p><h4 id="E类地址"><a href="#E类地址" class="headerlink" title="E类地址"></a>E类地址</h4><h5 id="保留为今后使用"><a href="#保留为今后使用" class="headerlink" title="保留为今后使用"></a>保留为今后使用</h5><p>​            最高位固定1111</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>​        只有A类、B类和C类地址可分配给网络中的主机或路由器的各接口<br>​        主机号为“全0”的地址是网络地址，不能分配<br>​        主机号为“全1”的地址是广播地址，不能分配</p><h4 id="一般不使用的特殊IP地址"><a href="#一般不使用的特殊IP地址" class="headerlink" title="一般不使用的特殊IP地址"></a>一般不使用的特殊IP地址</h4><p>​        地址0.0.0.0是一个特殊的IPv4地址，只能作为源地址使用，表示“在本网络上的本主机”，封装由DHCP Discovery报文的IP分组的源地址使用0.0.0.0<br>​        以127开头且后面三个字节非“全0”或“全1”的IP地址是一类特殊的IPv4地址，既可以作为源地址使用，也可以作为目的地址使用，用于本地软件环回测试<br>​        地址255.255.255.255只能作为目的地址使用，表示“只在本网络上进行广播”（路由器均不转发）</p><hr><h3 id="4-3-3划分子网的IPv4地址"><a href="#4-3-3划分子网的IPv4地址" class="headerlink" title="4.3.3划分子网的IPv4地址"></a>4.3.3划分子网的IPv4地址</h3><h4 id="为新增网络申请新的网络号回带来弊端"><a href="#为新增网络申请新的网络号回带来弊端" class="headerlink" title="为新增网络申请新的网络号回带来弊端"></a>为新增网络申请新的网络号回带来弊端</h4><p>​        需要等待时间和花费更多的费用<br>​        会增加其他路由器中路由表记录的数量<br>​        浪费原有网络中剩余的大量IP地址</p><h4 id="32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号"><a href="#32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号" class="headerlink" title="32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号"></a>32比特的子网掩码可以表名分类IP地址的主机号部分被借用了几个比特作为子网号</h4><p>​        用连续的比特1来对应网络号和子网号<br>​        用连续的比特0来对应主机号<br>​        将划分子网的IPv4与其对应的子网掩码进行逻辑与运算就可以得到IPv4地址所在的子网的网络地址<br>​            结果网络号和子网号被保留，主机号被清零</p><h4 id="默认的子网掩码是指在未划分子网的情况下使用的子网掩码"><a href="#默认的子网掩码是指在未划分子网的情况下使用的子网掩码" class="headerlink" title="默认的子网掩码是指在未划分子网的情况下使用的子网掩码"></a>默认的子网掩码是指在未划分子网的情况下使用的子网掩码</h4><h5 id="A类地址默认子网掩码"><a href="#A类地址默认子网掩码" class="headerlink" title="A类地址默认子网掩码"></a>A类地址默认子网掩码</h5><p>​            255.0.0.0</p><h5 id="B类地址默认子网掩码"><a href="#B类地址默认子网掩码" class="headerlink" title="B类地址默认子网掩码"></a>B类地址默认子网掩码</h5><p>​            255.255.0.0</p><h5 id="C类地址默认子网掩码"><a href="#C类地址默认子网掩码" class="headerlink" title="C类地址默认子网掩码"></a>C类地址默认子网掩码</h5><p>​            255.255.255.0</p><hr><h3 id="4-3-4无分类编址的IPv4地址"><a href="#4-3-4无分类编址的IPv4地址" class="headerlink" title="4.3.4无分类编址的IPv4地址"></a>4.3.4无分类编址的IPv4地址</h3><h4 id="提出采用无分类编址来解决IP地址紧张的问题"><a href="#提出采用无分类编址来解决IP地址紧张的问题" class="headerlink" title="提出采用无分类编址来解决IP地址紧张的问题"></a>提出采用无分类编址来解决IP地址紧张的问题</h4><h4 id="1993年，IETF发布了无分类域间路由选择CIDR-Classless-Inter-Domain-Routing"><a href="#1993年，IETF发布了无分类域间路由选择CIDR-Classless-Inter-Domain-Routing" class="headerlink" title="1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-Domain Routing)"></a>1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-Domain Routing)</h4><h5 id="消除了传统A类、B类、C类地址，以及划分子网概念"><a href="#消除了传统A类、B类、C类地址，以及划分子网概念" class="headerlink" title="消除了传统A类、B类、C类地址，以及划分子网概念"></a>消除了传统A类、B类、C类地址，以及划分子网概念</h5><h5 id="可以更有效的分配地址空间"><a href="#可以更有效的分配地址空间" class="headerlink" title="可以更有效的分配地址空间"></a>可以更有效的分配地址空间</h5><h5 id="使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量"><a href="#使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量" class="headerlink" title="使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量"></a>使用“斜线记法”，在斜线后面写上网络前缀所占的比特数量</h5><h5 id="是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128-14-35-7-x2F-20）"><a href="#是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128-14-35-7-x2F-20）" class="headerlink" title="是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128.14.35.7&#x2F;20）"></a>是将网络前缀都相同的连续IP地址组成一个“CIDR地址块”（如128.14.35.7&#x2F;20）</h5><h5 id="只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节"><a href="#只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节" class="headerlink" title="只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节"></a>只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节</h5><p>​            地址块的最小地址<br>​            地址块的最大地址<br>​            地址块的地址数量<br>​            地址块的聚合某类网络数量<br>​            地址掩码（子网掩码）</p><h4 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h4><p>​        网络前缀越长、地址块越小，路由越具体<br>​        若路由器查表转发分组时发现由多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配</p><hr><h3 id="4-3-5IPv4地址的应用规划"><a href="#4-3-5IPv4地址的应用规划" class="headerlink" title="4.3.5IPv4地址的应用规划"></a>4.3.5IPv4地址的应用规划</h3><h4 id="定长的子网掩码FLSM"><a href="#定长的子网掩码FLSM" class="headerlink" title="定长的子网掩码FLSM"></a>定长的子网掩码FLSM</h4><p>​        使用同一个子网掩码来划分子网<br>​        子网划分方式不灵活：只能划分除2^n个子网（n是从主机号部分借用的用来作为子网号的比特数量）<br>​        每个子网所分配的IP地址数量相同，容易造成IP地址浪费</p><h4 id="变长的子网掩码VLSM"><a href="#变长的子网掩码VLSM" class="headerlink" title="变长的子网掩码VLSM"></a>变长的子网掩码VLSM</h4><p>​        使用不同的子网掩码来划分子网<br>​        子网划分方式灵活：可以按需分配<br>​        每个子网所分配的IP数量可以不同，尽可能减少对IP地址的浪费</p><hr><h3 id="4-4IP地址数据报的发送和转发过程"><a href="#4-4IP地址数据报的发送和转发过程" class="headerlink" title="4.4IP地址数据报的发送和转发过程"></a>4.4IP地址数据报的发送和转发过程</h3><h4 id="主机发送IP数据报"><a href="#主机发送IP数据报" class="headerlink" title="主机发送IP数据报"></a>主机发送IP数据报</h4><h5 id="判断目的主机是否与自己在同一个网络"><a href="#判断目的主机是否与自己在同一个网络" class="headerlink" title="判断目的主机是否与自己在同一个网络"></a>判断目的主机是否与自己在同一个网络</h5><p>​            同一个网络属于直接交付<br>​            不同网络属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发</p><h4 id="路由器转发IP数据报"><a href="#路由器转发IP数据报" class="headerlink" title="路由器转发IP数据报"></a>路由器转发IP数据报</h4><p>​        检查IP数据报首付是否出错<br>​        根据IP数据报的目的地址在路由表中查找匹配的条目</p><hr><h3 id="4-5静态路由配置及其可能产生的路由环路问题"><a href="#4-5静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5静态路由配置及其可能产生的路由环路问题"></a>4.5静态路由配置及其可能产生的路由环路问题</h3><h4 id="静态路由指人工配置的路由表"><a href="#静态路由指人工配置的路由表" class="headerlink" title="静态路由指人工配置的路由表"></a>静态路由指人工配置的路由表</h4><p>​        这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）变化</p><h4 id="可能导致出现路由环路"><a href="#可能导致出现路由环路" class="headerlink" title="可能导致出现路由环路"></a>可能导致出现路由环路</h4><p>​        配置错误<br>​        聚合了不存在的网络<br>​        网络故障</p><h4 id="路由条目的类型"><a href="#路由条目的类型" class="headerlink" title="路由条目的类型"></a>路由条目的类型</h4><p>​        直连网络<br>​        静态路由（人工配置）<br>​        动态路由（路由选择协议）</p><h4 id="特殊的静态路由条目"><a href="#特殊的静态路由条目" class="headerlink" title="特殊的静态路由条目"></a>特殊的静态路由条目</h4><p>​        默认路由（目的网络为0.0.0.0，地址掩码为0.0.0.0）<br>​        特定主机路由（目的网络为特定主机的IP地址，地址掩码为255.255.255.255）<br>​        黑洞路由（下一跳为null0）</p><hr><h3 id="4-6-1路由选择协议概述"><a href="#4-6-1路由选择协议概述" class="headerlink" title="4.6.1路由选择协议概述"></a>4.6.1路由选择协议概述</h3><h4 id="静态路由选择"><a href="#静态路由选择" class="headerlink" title="静态路由选择"></a>静态路由选择</h4><p>​        由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由<br>​        人工配置方式简单、开销小，但不能及时适应网络状态（流量、拓扑）的变化<br>​        一般只在小规模中采用</p><h4 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h4><p>​        路由器通过路由选择协议自动获取路由信息<br>​        能比较好地适应网络状态的变化<br>​        适用于大规模网络</p><h4 id="因特网所采用的路由选择协议的主要特点"><a href="#因特网所采用的路由选择协议的主要特点" class="headerlink" title="因特网所采用的路由选择协议的主要特点"></a>因特网所采用的路由选择协议的主要特点</h4><h5 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h5><p>​            动态路由选择，能较好的适应网络状态的变化</p><h5 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h5><p>​            路由器之间交换路由信息</p><h5 id="分层次"><a href="#分层次" class="headerlink" title="分层次"></a>分层次</h5><p>​            将整个因特网划分为许多较小的自治系统AS（Automous System）</p><h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><h5 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h5><h6 id="基于距离向量"><a href="#基于距离向量" class="headerlink" title="基于距离向量"></a>基于距离向量</h6><p>​                路由信息协议RIP<br>​                内部网关路由协议IGRP</p><h6 id="增强型内部网关路由协议EIGRP"><a href="#增强型内部网关路由协议EIGRP" class="headerlink" title="增强型内部网关路由协议EIGRP"></a>增强型内部网关路由协议EIGRP</h6><h6 id="基于链路状态"><a href="#基于链路状态" class="headerlink" title="基于链路状态"></a>基于链路状态</h6><p>​                开放式最短路径优先OSPF<br>​                中间系统到中级系统IS-IS</p><h5 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h5><p>​            边界网关协议BGP</p><hr><h3 id="4-6-2路由信息协议RIP的基本工作原理"><a href="#4-6-2路由信息协议RIP的基本工作原理" class="headerlink" title="4.6.2路由信息协议RIP的基本工作原理"></a>4.6.2路由信息协议RIP的基本工作原理</h3><h4 id="RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”"><a href="#RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”" class="headerlink" title="RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”"></a>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V（Distance-Vector）”</h4><h4 id="RIP使用跳数作为度量来衡量到达目的网络的距离"><a href="#RIP使用跳数作为度量来衡量到达目的网络的距离" class="headerlink" title="RIP使用跳数作为度量来衡量到达目的网络的距离"></a>RIP使用跳数作为度量来衡量到达目的网络的距离</h4><p>​        路由器到直连网络的距离定义为1<br>​        路由器到非直连网络的距离定义为所经过的路由器加1<br>​        允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。因此RIP只适用于小型互联网</p><h4 id="RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由"><a href="#RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由" class="headerlink" title="RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由"></a>RIP认为好的路由就是“距离短”的路由，也就是所通过的路由器数量最少的路由</h4><h4 id="当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡"><a href="#当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡" class="headerlink" title="当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡"></a>当到达同一目的网络由多条“距离相等”的路由时，可以进行等价负载均衡</h4><h4 id="RIP包含三个要点"><a href="#RIP包含三个要点" class="headerlink" title="RIP包含三个要点"></a>RIP包含三个要点</h4><h5 id="和谁交换信息"><a href="#和谁交换信息" class="headerlink" title="和谁交换信息"></a>和谁交换信息</h5><p>​            仅和相邻路由器交换信息</p><h5 id="交换什么信息"><a href="#交换什么信息" class="headerlink" title="交换什么信息"></a>交换什么信息</h5><p>​            自己的路由表</p><h5 id="何时交换信息"><a href="#何时交换信息" class="headerlink" title="何时交换信息"></a>何时交换信息</h5><p>​            周期性交换（例如每30秒）</p><h4 id="路由器刚开始工作时，只知道自己到直连网络的距离为1"><a href="#路由器刚开始工作时，只知道自己到直连网络的距离为1" class="headerlink" title="路由器刚开始工作时，只知道自己到直连网络的距离为1"></a>路由器刚开始工作时，只知道自己到直连网络的距离为1</h4><p>​    每个路由器仅和相邻路由器周期性地交换并更新路由信息<br>​    若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛</p><h4 id="RIP存在“坏消息传播得慢”问题"><a href="#RIP存在“坏消息传播得慢”问题" class="headerlink" title="RIP存在“坏消息传播得慢”问题"></a>RIP存在“坏消息传播得慢”问题</h4><p>​        又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害</p><h5 id="限制最大路径距离为15（16表示不可达）"><a href="#限制最大路径距离为15（16表示不可达）" class="headerlink" title="限制最大路径距离为15（16表示不可达）"></a>限制最大路径距离为15（16表示不可达）</h5><h5 id="当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送"><a href="#当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送" class="headerlink" title="当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送"></a>当路由表发送变化时就立即发送更新报文（即“触发更新”），而不仅时周期性发送</h5><h5 id="让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）"><a href="#让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）" class="headerlink" title="让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）"></a>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向发送（即“水平分割”）</h5><hr><h3 id="4-6-3开放最短路径优先OSPF的基本工作原理"><a href="#4-6-3开放最短路径优先OSPF的基本工作原理" class="headerlink" title="4.6.3开放最短路径优先OSPF的基本工作原理"></a>4.6.3开放最短路径优先OSPF的基本工作原理</h3><p>​    OSPF是基于链路状态</p><p>​    采用SPF算法计算路由，从算法上保证了不会产生路由环路<br>​    不限制网络规模，更新效率高，收敛速度快</p><h4 id="链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”"><a href="#链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”" class="headerlink" title="链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”"></a>链路状态时指本路由器和哪些路由器相邻，以及相应链路的“代价”</h4><p>​        “代价”用来表示费用、距离、时延、带宽，等等。</p><p>​    思科路由器OSPF计算代价的方法：100Mbps &#x2F; 链路带宽</p><h4 id="OSPF相邻路由器之间通过交互问候分组-Hello-，建立和维护邻居关系"><a href="#OSPF相邻路由器之间通过交互问候分组-Hello-，建立和维护邻居关系" class="headerlink" title="OSPF相邻路由器之间通过交互问候分组(Hello)，建立和维护邻居关系"></a>OSPF相邻路由器之间通过交互问候分组(Hello)，建立和维护邻居关系</h4><p>​        Hello分组封装再IP数据报中</p><h4 id="使用OSPF的每个路由器会产生链路状态通告LSA"><a href="#使用OSPF的每个路由器会产生链路状态通告LSA" class="headerlink" title="使用OSPF的每个路由器会产生链路状态通告LSA"></a>使用OSPF的每个路由器会产生链路状态通告LSA</h4><p>​        直连网络的链路状态信息<br>​        邻居路由器的链路状态信息<br>​    LSA被封装再链路状态更新分组LSU中，采用洪泛法发送<br>​    使用OSPF的每一个路由器都有一个链路状态数据库LSDB，用于存储LSA<br>​    通过各路由器洪泛发送封装又自己的LSA的LSU分组，各路由器的LSDB最终达到一致<br>​    使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表</p><h4 id="OSPF有五种分组类型"><a href="#OSPF有五种分组类型" class="headerlink" title="OSPF有五种分组类型"></a>OSPF有五种分组类型</h4><p>​        问候（Hello）分组<br>​        数据库描述（Database Description）分组<br>​        链路状态请求（Link State Request）分组<br>​        链路状态更新（Link State Update）分组<br>​        链路状态确认（Link State Acknowledgment）分组</p><h4 id="OSPF在多点接入网络中路由器邻居关系的建立"><a href="#OSPF在多点接入网络中路由器邻居关系的建立" class="headerlink" title="OSPF在多点接入网络中路由器邻居关系的建立"></a>OSPF在多点接入网络中路由器邻居关系的建立</h4><p>​        选举指定路由器DR和备用的指定路由器BDR<br>​        所有的非DR&#x2F;BDR只与DR&#x2F;BDR建立邻居关系<br>​        非DR&#x2F;BDR之间通过DR&#x2F;BDR交换信息</p><hr><h3 id="4-6-4边界网关协议BGP的基本工作原理"><a href="#4-6-4边界网关协议BGP的基本工作原理" class="headerlink" title="4.6.4边界网关协议BGP的基本工作原理"></a>4.6.4边界网关协议BGP的基本工作原理</h3><p>​    BGP只是力求寻找一条能够到达目的网络且比较好的路由，并非寻找一条最佳路由<br>​    配置BGP时，每个自治系统的管理员至少选择一个路由器作为该自治系统的“BGP发言人”</p><h4 id="不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接"><a href="#不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接" class="headerlink" title="不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接"></a>不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接</h4><p>​        TCP连接上交换BGP报文以建立BGP会话<br>​        利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）<br>​    BGP发言人除了运行BGP外，还必须运行自己的自治系统所使用的内部网关协议IGP，例如OSPF或RIP<br>​    RGP发言人交换网络可达性的信息<br>​    当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通路</p><h4 id="BGP-4有四种报文"><a href="#BGP-4有四种报文" class="headerlink" title="BGP-4有四种报文"></a>BGP-4有四种报文</h4><p>​        OPEN报文<br>​        UPDATE报文<br>​        KEEPLIVE报文<br>​        NOTIFICATION报文</p><hr><h3 id="4-7IPv4数据报的首部格式"><a href="#4-7IPv4数据报的首部格式" class="headerlink" title="4.7IPv4数据报的首部格式"></a>4.7IPv4数据报的首部格式</h3><h4 id="固定部分（20字节）"><a href="#固定部分（20字节）" class="headerlink" title="固定部分（20字节）"></a>固定部分（20字节）</h4><p>​        版本<br>​        首部长度<br>​        区分服务<br>​        总长度<br>​        标识<br>​        标志<br>​        片偏移<br>​        帧的数据载荷长度受限于最大传输单元MTU<br>​            以太网规定MTU值为1500字节<br>​        生存时间TTL<br>​        协议<br>​        首部校验和<br>​        源IP地址和目的IP地址<br>​        这三个字段共用于IP数据报分片</p><h4 id="可变部分（40字节）"><a href="#可变部分（40字节）" class="headerlink" title="可变部分（40字节）"></a>可变部分（40字节）</h4><h5 id="可选字段（长度可变）"><a href="#可选字段（长度可变）" class="headerlink" title="可选字段（长度可变）"></a>可选字段（长度可变）</h5><p>​            长度从1个字节到40字节不等，用来支持排错、测量及安全等措施<br>​            可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用</p><h5 id="填充字段"><a href="#填充字段" class="headerlink" title="填充字段"></a>填充字段</h5><p>​            确保首部长度为4字节的整数倍，使用全0填充<br>​    </p><hr><h3 id="4-8网际控制报文协议ICMP"><a href="#4-8网际控制报文协议ICMP" class="headerlink" title="4.8网际控制报文协议ICMP"></a>4.8网际控制报文协议ICMP</h3><p>​    主机或路由器使用ICMP来发送差错报告报文和询问报文<br>​    ICMP报文被封装在IP数据报中发送</p><h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h4><h5 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h5><p>​            当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</p><h5 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h5><p>​            当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</p><h5 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h5><p>​            当TTL值为0时，除丢弃该IP数据报外，还要向源点发送时间超过报文</p><h5 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h5><p>​            当首部出现误码，就向源点发送参数问题报文</p><h5 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h5><p>​            让主机知道下次应将数据发送给通过更好的路由</p><h5 id="不应发送ICMP差错报告报文的情况"><a href="#不应发送ICMP差错报告报文的情况" class="headerlink" title="不应发送ICMP差错报告报文的情况"></a>不应发送ICMP差错报告报文的情况</h5><p>​            对ICMP报文不再发送ICMP<br>​            对第一个分片的数据报片的所有后续数据报片不发送<br>​            对具有多播地址的数据报不发送<br>​            对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送</p><h4 id="常用的ICMP询问报文"><a href="#常用的ICMP询问报文" class="headerlink" title="常用的ICMP询问报文"></a>常用的ICMP询问报文</h4><h5 id="回送请求和回答"><a href="#回送请求和回答" class="headerlink" title="回送请求和回答"></a>回送请求和回答</h5><p>​            用来测试目的站是否可达</p><h5 id="时间戳请求和回答"><a href="#时间戳请求和回答" class="headerlink" title="时间戳请求和回答"></a>时间戳请求和回答</h5><p>​            用来进行时钟同步和测量时间</p><hr><h3 id="4-9虚拟专用网VPN与网络地址转换NAT"><a href="#4-9虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9虚拟专用网VPN与网络地址转换NAT"></a>4.9虚拟专用网VPN与网络地址转换NAT</h3><p>​    利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网</p><h4 id="各主机所分配的地址应该是本机构可自由分配的专用地址"><a href="#各主机所分配的地址应该是本机构可自由分配的专用地址" class="headerlink" title="各主机所分配的地址应该是本机构可自由分配的专用地址"></a>各主机所分配的地址应该是本机构可自由分配的专用地址</h4><h5 id="专用（私有）地址："><a href="#专用（私有）地址：" class="headerlink" title="专用（私有）地址："></a>专用（私有）地址：</h5><p>​            10.0.0.0<del>10.255.255.255（10&#x2F;8地址块）<br>​            172.16.0.0</del>172.31.255.255（172.16&#x2F;12地址块）<br>​            192.168.0.0~192.168.255.255（192.168&#x2F;16地址块）<br>​    同一机构内不同部分的内部网络所构成的虚拟专用网VPN又成为内联网VPN<br>​    有时一个机构的VPN需要某些外部机构参加进来，这样的VPN就成为外联网VPN<br>​    在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种vpn成为远程接入VPN</p><h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>​        NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源<br>​        该转换方法存在一个问题：如果NAT路由器具有N各地址IP地址，那么至多只能有n个内网主机能够同时和因特网上的主机通信<br>​        用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP一起进行转换的技术叫做网络地址与端口号转换NAPT</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑合集</title>
      <link href="/2022/04/13/cai-keng-he-ji/"/>
      <url>/2022/04/13/cai-keng-he-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="Blog优化相关"><a href="#Blog优化相关" class="headerlink" title="Blog优化相关"></a>Blog优化相关</h3><p>在第一次使用代码块时候发现样式重叠且代码块奇丑无比，马上去网上参考了<a href="http://luckyzmj.cn/posts/1b9a9e28.html">LuckySec</a>的代码优化的文章，在根据他的步骤一步一步下来，发现代码块样式并没有改变，又去修改<code>hexo</code>根目录的<code>_config.yml</code>，将自带的highlight改为false，prismjs改为true，并取消了行标显示，发现样式仍然没有太大改变，经过一段时间的琢磨，才发现需要用<code>hexo clean &amp;&amp; hexo g</code>才能使样式生效。简直了，<strong>每次修改样式必须得重新清理和编译才行，直接在本地运行会有不生效的可能</strong></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_数据链路层</title>
      <link href="/2022/04/13/shu-ju-lian-lu-ceng/"/>
      <url>/2022/04/13/shu-ju-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="3-1数据链路层概述"><a href="#3-1数据链路层概述" class="headerlink" title="3.1数据链路层概述"></a>3.1数据链路层概述</h3><h4 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h4><p>​        就是从一个结点道相邻结点的一段物理线路，而中间没有任何其他的交换结点</p><h4 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h4><p>​        是指把实现通信协议的硬件和软件加道链路上，就构成了数据链路</p><h4 id="数据链路层以帧为单位传输和处理数据"><a href="#数据链路层以帧为单位传输和处理数据" class="headerlink" title="数据链路层以帧为单位传输和处理数据"></a>数据链路层以帧为单位传输和处理数据</h4><h4 id="数据链路层的三个重要问题"><a href="#数据链路层的三个重要问题" class="headerlink" title="数据链路层的三个重要问题"></a>数据链路层的三个重要问题</h4><p>​        封装成帧<br>​        差错检测<br>​        可靠传输</p><hr><h3 id="3-2封装成帧"><a href="#3-2封装成帧" class="headerlink" title="3.2封装成帧"></a>3.2封装成帧</h3><h4 id="封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧"><a href="#封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧" class="headerlink" title="封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧"></a>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</h4><p>​        帧头和帧尾中包含有重要的控制信息<br>​        帧头和帧尾的作用之一就是帧定界</p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>​        指数据链路层对上层交付的传输数据中没有任何限制，就好像数据链层不存在一样<br>​        面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输<br>​        面向比特的物理链路使用比特填充的方法实现透明传输</p><h4 id="为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些"><a href="#为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些" class="headerlink" title="为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些"></a>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些</h4><h4 id="考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU"><a href="#考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU" class="headerlink" title="考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU"></a>考虑道差错检测的多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU</h4><hr><h3 id="3-3差错检测"><a href="#3-3差错检测" class="headerlink" title="3.3差错检测"></a>3.3差错检测</h3><h4 id="实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1-这称为比特差错"><a href="#实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1-这称为比特差错" class="headerlink" title="实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1.这称为比特差错"></a>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1.这称为比特差错</h4><h4 id="在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit-Error-Rate）"><a href="#在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit-Error-Rate）" class="headerlink" title="在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit Error Rate）"></a>在一段时间内，传输错误的比特占所传输比特总数的比率成为误码率BER（Bit Error Rate）</h4><h4 id="使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一"><a href="#使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一" class="headerlink" title="使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一"></a>使用差错检测吗来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一</h4><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>​        在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的检验位在内）中“1”的个数为奇数或偶数</p><p>​        如果有奇数个位发送无码，则奇偶性发生变化，可以检查出误码<br>​        如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码（漏检）</p><h4 id="循环冗余校验CRC（Cyclic-Redundancy-Check）"><a href="#循环冗余校验CRC（Cyclic-Redundancy-Check）" class="headerlink" title="循环冗余校验CRC（Cyclic Redundancy Check）"></a>循环冗余校验CRC（Cyclic Redundancy Check）</h4><p>​        收发双方约定好一个生成多项式G（x）<br>​        发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加道待传输数据的后面一起传输<br>​        接收方通过生成多项式来计算收到的数据是否产生了误码</p><h4 id="检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误"><a href="#检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误" class="headerlink" title="检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误"></a>检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误</h4><h4 id="要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用"><a href="#要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用" class="headerlink" title="要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用"></a>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用</h4><hr><h3 id="3-4-1可靠传输的基本概念"><a href="#3-4-1可靠传输的基本概念" class="headerlink" title="3.4.1可靠传输的基本概念"></a>3.4.1可靠传输的基本概念</h3><p>​    无线链路易受干扰，误码率较高，因此要求数据链路层必须向上提供可靠传输服务<br>​    有线链路的误码率比较低，并不要求数据链路层向上提供可靠传输服务<br>​    传输差错还包括分组丢失、分组失序以及分组重复</p><h3 id="3-4-2停止-等待协议SW"><a href="#3-4-2停止-等待协议SW" class="headerlink" title="3.4.2停止-等待协议SW"></a>3.4.2停止-等待协议SW</h3><p>​    为解决接收方收不到数据分组，不发送ACK或NAK问题，可以启动一个超时计时器。一般将重传时间选为略大于“从发送方道接收方的平均往返时间”<br>​    为避免分组重复这种传输错误，必须给每个分组带上序号<br>​    数据链路层一般不会出现ACK分组迟到情况，因此在数据链路层可以不用给ACK分组编号</p><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>$$<br>    信道利用率U &#x3D; TD&#x2F;TD + RTT + TA\\<br>    TD （发送方发送分组的发送时延）\\<br>    RTT（收发双方的往返时间）\\<br>    TA（接收方发送确认分组所消耗的发送时延）\\<br>$$</p><h3 id="3-4-3回退N帧协议"><a href="#3-4-3回退N帧协议" class="headerlink" title="3.4.3回退N帧协议"></a>3.4.3回退N帧协议</h3><h4 id="发送窗口的尺寸WT的取值"><a href="#发送窗口的尺寸WT的取值" class="headerlink" title="发送窗口的尺寸WT的取值"></a>发送窗口的尺寸WT的取值</h4><p>​        1&lt;WT&lt;&#x3D;2^n- 1 </p><h4 id="接收窗口的尺寸WR的取值"><a href="#接收窗口的尺寸WR的取值" class="headerlink" title="接收窗口的尺寸WR的取值"></a>接收窗口的尺寸WR的取值</h4><p>​        WR&#x3D;1</p><h4 id="接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认"><a href="#接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认" class="headerlink" title="接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认"></a>接收方不一定要对收到的数据分组逐个发送确认，可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认</h4><h3 id="3-4-4选择重传协议SR"><a href="#3-4-4选择重传协议SR" class="headerlink" title="3.4.4选择重传协议SR"></a>3.4.4选择重传协议SR</h3><h4 id="发送窗口的尺寸WT的取值-1"><a href="#发送窗口的尺寸WT的取值-1" class="headerlink" title="发送窗口的尺寸WT的取值"></a>发送窗口的尺寸WT的取值</h4><p>​        1 &lt; WT &lt;&#x3D; 2(^n-1)</p><h4 id="接受窗口的尺寸WR的取值"><a href="#接受窗口的尺寸WR的取值" class="headerlink" title="接受窗口的尺寸WR的取值"></a>接受窗口的尺寸WR的取值</h4><p>​        WR&#x3D;WT</p><h4 id="发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去"><a href="#发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去" class="headerlink" title="发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去"></a>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组发送出去</h4><h4 id="接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组"><a href="#接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组" class="headerlink" title="接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组"></a>接收方可接受未按序到达但没有误码并且序号落在接受窗口的数据分组</h4><h4 id="接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动"><a href="#接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动" class="headerlink" title="接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动"></a>接收方只有在按序接受数据分组后，接受窗口才能向前相应滑动</h4><h4 id="发送方对收到的分组进行记录，以防止其相应数据分组的超时重发"><a href="#发送方对收到的分组进行记录，以防止其相应数据分组的超时重发" class="headerlink" title="发送方对收到的分组进行记录，以防止其相应数据分组的超时重发"></a>发送方对收到的分组进行记录，以防止其相应数据分组的超时重发</h4><hr><h3 id="3-5点对点协议PPP"><a href="#3-5点对点协议PPP" class="headerlink" title="3.5点对点协议PPP"></a>3.5点对点协议PPP</h3><h4 id="是目前使用最广泛的点对点数据链路层协议"><a href="#是目前使用最广泛的点对点数据链路层协议" class="headerlink" title="是目前使用最广泛的点对点数据链路层协议"></a>是目前使用最广泛的点对点数据链路层协议</h4><h4 id="在点对点链路传输提供了一个标准方法，主要由三部分构成"><a href="#在点对点链路传输提供了一个标准方法，主要由三部分构成" class="headerlink" title="在点对点链路传输提供了一个标准方法，主要由三部分构成"></a>在点对点链路传输提供了一个标准方法，主要由三部分构成</h4><h5 id="对各种协议数据报的封装方法（封装成帧）"><a href="#对各种协议数据报的封装方法（封装成帧）" class="headerlink" title="对各种协议数据报的封装方法（封装成帧）"></a>对各种协议数据报的封装方法（封装成帧）</h5><h5 id="链路控制协议LCP"><a href="#链路控制协议LCP" class="headerlink" title="链路控制协议LCP"></a>链路控制协议LCP</h5><p>​            用于建立、配置以及测试数据链路的连接</p><h5 id="一套网络控制协议NCPs"><a href="#一套网络控制协议NCPs" class="headerlink" title="一套网络控制协议NCPs"></a>一套网络控制协议NCPs</h5><p>​            其中的每一个协议支持不同的网络层协议</p><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><h5 id="帧的首部"><a href="#帧的首部" class="headerlink" title="帧的首部"></a>帧的首部</h5><h6 id="F（1字节）"><a href="#F（1字节）" class="headerlink" title="F（1字节）"></a>F（1字节）</h6><p>​                标志（Flag）字段：PPP帧的定界符，取值为0x7E</p><h6 id="A（1字节）"><a href="#A（1字节）" class="headerlink" title="A（1字节）"></a>A（1字节）</h6><p>​                地址（Address）字段：取值为0xFF，预留（目前没有什么作用）</p><h6 id="C（1字节）"><a href="#C（1字节）" class="headerlink" title="C（1字节）"></a>C（1字节）</h6><p>​                控制（Control）字段：取值为0x03，预留（目前没有什么作用）</p><h6 id="P（2字节）"><a href="#P（2字节）" class="headerlink" title="P（2字节）"></a>P（2字节）</h6><p>​                协议（Protocol）字段：指明帧的数据部分送交给哪个协议处理<br>$$<br>取值0x0021表示：帧的数据部分为IP数据报\\<br>取值0xC021表示：帧的数据部分为LCP分组\\<br>取值0x8021表示：帧的数据部分为NCP分组<br>$$</p><h5 id="帧的数据部分"><a href="#帧的数据部分" class="headerlink" title="帧的数据部分"></a>帧的数据部分</h5><p>​            不超过1500字节</p><h5 id="帧的尾部"><a href="#帧的尾部" class="headerlink" title="帧的尾部"></a>帧的尾部</h5><h6 id="FCS（2字节）"><a href="#FCS（2字节）" class="headerlink" title="FCS（2字节）"></a>FCS（2字节）</h6><p>​                帧校验序列（Frame Check Sequence）字段：CRC计算出的校验位</p><h4 id="解决透明传输"><a href="#解决透明传输" class="headerlink" title="解决透明传输"></a>解决透明传输</h4><h5 id="数据部分出现帧首或帧尾中的标志字段时"><a href="#数据部分出现帧首或帧尾中的标志字段时" class="headerlink" title="数据部分出现帧首或帧尾中的标志字段时"></a>数据部分出现帧首或帧尾中的标志字段时</h5><h5 id="面向字节的异步链路"><a href="#面向字节的异步链路" class="headerlink" title="面向字节的异步链路"></a>面向字节的异步链路</h5><p>​            采用字节填充法（插入转义字符）</p><h5 id="面向比特的同步链路"><a href="#面向比特的同步链路" class="headerlink" title="面向比特的同步链路"></a>面向比特的同步链路</h5><p>​            采用比特填充法（插入比特0）</p><h4 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h4><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/04/13/shu-ju-lian-lu-ceng/workState.png" class=""></h5><hr><h3 id="3-6-1媒体接入控制的基本概念"><a href="#3-6-1媒体接入控制的基本概念" class="headerlink" title="3.6.1媒体接入控制的基本概念"></a>3.6.1媒体接入控制的基本概念</h3><h4 id="共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium-Access-Control）"><a href="#共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium-Access-Control）" class="headerlink" title="共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium Access Control）"></a>共享信道要着重考虑的一个问题就是如何协同多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium Access Control）</h4><h4 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h4><h5 id="静态划分信道-预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。"><a href="#静态划分信道-预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。" class="headerlink" title="静态划分信道(预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。"></a>静态划分信道(预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。</h5><p>通常在无线网络的物理层中使用)</p><p>​            频分多址<br>​            时分多址<br>​            码分多址</p><h5 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h5><h6 id="受控接入（已被淘汰）"><a href="#受控接入（已被淘汰）" class="headerlink" title="受控接入（已被淘汰）"></a>受控接入（已被淘汰）</h6><p>​                集中控制<br>​                分散控制</p><h6 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入:"></a>随机接入:</h6><p>​                所有站点通过竞争，随机在信道上发送数据。如果恰巧由两个或更多站点在同一时刻发送数据，则信号在共享媒体上就要产生碰撞。使得这些站点都发送失败。因此，这类协议要解决的问题是如何避免冲突以及在发送冲突后如何尽快恢复通信。著名的共享式以太网采用的就是随机接入</p><h4 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h4><h3 id="3-6-2静态划分信道"><a href="#3-6-2静态划分信道" class="headerlink" title="3.6.2静态划分信道"></a>3.6.2静态划分信道</h3><h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><h5 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h5><p>​            频分复用的所有用户同时占用不同的频带资源并行通信</p><h5 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h5><p>​            所有用户在不同的时间占用同样的频带宽度</p><h5 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h5><h5 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h5><h5 id="使用CDMA的每一个站被指派一个唯一的m-bit码片序列"><a href="#使用CDMA的每一个站被指派一个唯一的m-bit码片序列" class="headerlink" title="使用CDMA的每一个站被指派一个唯一的m bit码片序列"></a>使用CDMA的每一个站被指派一个唯一的m bit码片序列</h5><h6 id="一个站如果要发送比特1，则发送它自己的m-bit码片序列"><a href="#一个站如果要发送比特1，则发送它自己的m-bit码片序列" class="headerlink" title="一个站如果要发送比特1，则发送它自己的m bit码片序列"></a>一个站如果要发送比特1，则发送它自己的m bit码片序列</h6><h6 id="一个站如果要发送比特0，则发送它自己的m-bit码片序列的二进制反码"><a href="#一个站如果要发送比特0，则发送它自己的m-bit码片序列的二进制反码" class="headerlink" title="一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码"></a>一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码</h6><h6 id="码片序列挑选原则"><a href="#码片序列挑选原则" class="headerlink" title="码片序列挑选原则"></a>码片序列挑选原则</h6><p>​                码片序列必须各不相同<br>​                码片序列必须相互正交（规格化内积为0）<br>​<br>$$<br>S表示站S的码片序列，T表示其他任何站的码片序列\\<br>                    S * T &#x3D; 0\\<br>                    S * S &#x3D; 1\\<br>                    S * 相反T &#x3D; 0\\<br>                    S * 相反S &#x3D; -1<br>$$</p><h3 id="3-6-3CSMA-x2F-CD协议"><a href="#3-6-3CSMA-x2F-CD协议" class="headerlink" title="3.6.3CSMA&#x2F;CD协议"></a>3.6.3CSMA&#x2F;CD协议</h3><h4 id="载波监听多址接入-x2F-碰撞检测-CSMA-x2F-CD-Carrier-Sense-Multiple-Access-x2F-Collision-Detection"><a href="#载波监听多址接入-x2F-碰撞检测-CSMA-x2F-CD-Carrier-Sense-Multiple-Access-x2F-Collision-Detection" class="headerlink" title="载波监听多址接入&#x2F;碰撞检测 CSMA&#x2F;CD(Carrier Sense Multiple Access&#x2F;Collision Detection)"></a>载波监听多址接入&#x2F;碰撞检测 CSMA&#x2F;CD(Carrier Sense Multiple Access&#x2F;Collision Detection)</h4><h5 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h5><p>​            多个站连接在一条总线上，竞争使用总线</p><h5 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h5><p>​            每一个站在发送帧之前要先检测一下总线上是否由其他站点在发送帧<br>​                若检测到总线空闲96比特时间，则发送这个帧<br>​                若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧</p><h5 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h5><p>​            每一个正在发送的站边发送边检测碰撞<br>​                一旦发现总线上出现碰撞，则立即停止发送，退避一段随机事件后再次发送</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p>​        以太网端到端往返传播时延2τ称为争用期<br>​        主机最多经过2τ的时长就可以检测到本次发送是否遭受了碰撞<br>​        共享式以太网不能连接太多的主机，使用的总线也不能太长</p><h4 id="以太网规定最小帧长为64字节（512比特时间即为争用期）"><a href="#以太网规定最小帧长为64字节（512比特时间即为争用期）" class="headerlink" title="以太网规定最小帧长为64字节（512比特时间即为争用期）"></a>以太网规定最小帧长为64字节（512比特时间即为争用期）</h4><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p>$$<br>退避时间 &#x3D; 基本退避时间（争用期2τ） × 随机数r\\（r从离散的整数集合{0,1,…,(2^k-1)}中随机选出一个数\\k &#x3D; Min[重传次数,10]）<br>$$</p><p>​        可使重传需要推迟的平均时间随重传次数而增大，因而减小发生碰撞的概率</p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>$$<br>发送一帧占用总线的时间为T0+τ，帧本身发送的时间为T0\\<br>        极限信道利用率Smax &#x3D; T0&#x2F;T0 + τ<br>$$</p><h3 id="3-6-4CSMA-x2F-CA"><a href="#3-6-4CSMA-x2F-CA" class="headerlink" title="3.6.4CSMA&#x2F;CA"></a>3.6.4CSMA&#x2F;CA</h3><h4 id="802-11无线局域网使用CSMA-x2F-CA协议，在CSMA的基础上增加了一个碰撞避免CA功能"><a href="#802-11无线局域网使用CSMA-x2F-CA协议，在CSMA的基础上增加了一个碰撞避免CA功能" class="headerlink" title="802.11无线局域网使用CSMA&#x2F;CA协议，在CSMA的基础上增加了一个碰撞避免CA功能"></a>802.11无线局域网使用CSMA&#x2F;CA协议，在CSMA的基础上增加了一个碰撞避免CA功能</h4><h4 id="802-11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收"><a href="#802-11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收" class="headerlink" title="802.11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收"></a>802.11标准还使用了数据链路层确认机制（停止等待协议）来保证数据被正确接收</h4><h4 id="802-11的MAC层标准定义了两种不同媒体的接入控制方式"><a href="#802-11的MAC层标准定义了两种不同媒体的接入控制方式" class="headerlink" title="802.11的MAC层标准定义了两种不同媒体的接入控制方式"></a>802.11的MAC层标准定义了两种不同媒体的接入控制方式</h4><p>​        分布式协调功能DCF<br>​        点协调功能PCF</p><h4 id="802-11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS"><a href="#802-11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS" class="headerlink" title="802.11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS"></a>802.11规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间被称为帧间间隔IFS</h4><h5 id="常用帧间间隔"><a href="#常用帧间间隔" class="headerlink" title="常用帧间间隔"></a>常用帧间间隔</h5><p>​            短帧间间隔SIFS(28微妙)<br>​            DCF帧间间隔DIFS(128微秒)</p><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p>​        当站点检测到信道使空闲，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法</p><h5 id="以下情况必须使用退避算法"><a href="#以下情况必须使用退避算法" class="headerlink" title="以下情况必须使用退避算法"></a>以下情况必须使用退避算法</h5><p>​            在发送数据帧之前检测到信道处于忙状态时<br>​            在每一次重传一个数据帧时<br>​            在每一次成功发送后要连续发送下一个帧时（避免长时间占用信道）</p><h5 id="在执行退避算法时，站点为退避计时器设置一个随机的退避时间"><a href="#在执行退避算法时，站点为退避计时器设置一个随机的退避时间" class="headerlink" title="在执行退避算法时，站点为退避计时器设置一个随机的退避时间"></a>在执行退避算法时，站点为退避计时器设置一个随机的退避时间</h5><p>​            当退避计时器的时间减小到零时，就开始发送数据<br>​            当退避计时器的时间还未减小到零时而信道又转变为忙状态，则冻结计时器，等重新变为空闲，再经过时间DIFS后，继续启动退避计时器<br>​        在进行第i次退避时，退避时间在时隙编号**{0, 1 , … , 2^(2+i) - 1 }<strong>中随机选择一个，然后乘以基本退避时间（一个时隙的长度）就可以得到随机的退避时间。当时隙编号到达</strong>255**时（对应于第6次退避）就不再增加了</p><h4 id="信道预约"><a href="#信道预约" class="headerlink" title="信道预约"></a>信道预约</h4><p>​        源站在发送数据帧之前先发送一个短的控制帧，称为请求发送QTS,它包括源地址，目的地址以及这次通信（包括相应的确认帧）所需的持续时间<br>​        若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS<br>​        源站收到CTS后，等一段SIFS后，就可发送其数据帧<br>​        若目的站正确收到源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK</p><h5 id="802-11规定了3中情况供用户选择"><a href="#802-11规定了3中情况供用户选择" class="headerlink" title="802.11规定了3中情况供用户选择"></a>802.11规定了3中情况供用户选择</h5><p>​            使用RTS帧和CTS<br>​            不使用RTS帧和CTS<br>​            只有当数据帧长度超过某一数值时才使用RTS帧和CTS</p><h4 id="虚拟载波监听机制"><a href="#虚拟载波监听机制" class="headerlink" title="虚拟载波监听机制"></a>虚拟载波监听机制</h4><p>​        除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要的时间</p><hr><h3 id="3-7MAC地址、IP地址、以及ARP协议"><a href="#3-7MAC地址、IP地址、以及ARP协议" class="headerlink" title="3.7MAC地址、IP地址、以及ARP协议"></a>3.7MAC地址、IP地址、以及ARP协议</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><h5 id="是以太网的MAC子层所使用的地址"><a href="#是以太网的MAC子层所使用的地址" class="headerlink" title="是以太网的MAC子层所使用的地址"></a>是以太网的MAC子层所使用的地址</h5><h5 id="每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media-Access-Control），所以这类地址被称为MAC地址"><a href="#每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media-Access-Control），所以这类地址被称为MAC地址" class="headerlink" title="每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media Access Control），所以这类地址被称为MAC地址"></a>每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media Access Control），所以这类地址被称为MAC地址</h5><h5 id="MAC地址也被称为硬件地址"><a href="#MAC地址也被称为硬件地址" class="headerlink" title="MAC地址也被称为硬件地址"></a>MAC地址也被称为硬件地址</h5><h5 id="是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识"><a href="#是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识" class="headerlink" title="是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识"></a>是对网络各接口的唯一标识，而不是对网络上各设备的唯一标识</h5><h5 id="组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）"><a href="#组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）" class="headerlink" title="组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）"></a>组织唯一标识符OUI（由IEEE的注册管理机构分配）（在前三个字节）</h5><h6 id="第一字节b0比特"><a href="#第一字节b0比特" class="headerlink" title="第一字节b0比特"></a>第一字节b0比特</h6><p>​                为1表示多播<br>​                为0表示单播</p><h6 id="第一字节b1比特"><a href="#第一字节b1比特" class="headerlink" title="第一字节b1比特"></a>第一字节b1比特</h6><p>​                为1表示本地管理<br>​                    剩余46位全为1时，就是广播地址FF-FF-FF-FF-FF-FF<br>​                为0表示全球管理<br>​        字节发送顺序：第一字节》》》第六字节<br>​        字节内比特发送顺序：b0》》》b7</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><h5 id="是TCP-x2F-IP体系结构网际层所使用的地址"><a href="#是TCP-x2F-IP体系结构网际层所使用的地址" class="headerlink" title="是TCP&#x2F;IP体系结构网际层所使用的地址"></a>是TCP&#x2F;IP体系结构网际层所使用的地址</h5><h5 id="网络编号"><a href="#网络编号" class="headerlink" title="网络编号"></a>网络编号</h5><p>​            标识因特网上数以百万计的网络</p><h5 id="主机编号"><a href="#主机编号" class="headerlink" title="主机编号"></a>主机编号</h5><p>​            标识同一网络上不同主机（或路由器各接口）</p><h5 id="数据包转发过程中源IP地址和目的IP地址保持不变"><a href="#数据包转发过程中源IP地址和目的IP地址保持不变" class="headerlink" title="数据包转发过程中源IP地址和目的IP地址保持不变"></a>数据包转发过程中源IP地址和目的IP地址保持不变</h5><h5 id="数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变"><a href="#数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变" class="headerlink" title="数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变"></a>数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变</h5><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>​        属于TCP&#x2F;IP体系结构网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址</p><h5 id="ARP高速缓存记录类型"><a href="#ARP高速缓存记录类型" class="headerlink" title="ARP高速缓存记录类型"></a>ARP高速缓存记录类型</h5><h6 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h6><p>​                自动获取，生命周期默认为两分钟</p><h6 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h6><p>​                手工设置，不同操作系统下的生命周期不同</p><hr><h3 id="3-8集线器与交换机的区别"><a href="#3-8集线器与交换机的区别" class="headerlink" title="3.8集线器与交换机的区别"></a>3.8集线器与交换机的区别</h3><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>​        在以太网逻辑上仍然时一个总线网，使用CSMA&#x2F;CD协议<br>​        只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）<br>​        集线器一般都有少量的容错能力和网络管理能力</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>​        通常都有多个接口<br>​        一般工作在全双工方式<br>​        能同时连通多对接口，无碰撞（不使用CSMA&#x2F;CD协议）<br>​        工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧<br>​        内部的帧交换表时通过自学习算法自动地逐渐建立起来</p><h5 id="帧两种转发方式"><a href="#帧两种转发方式" class="headerlink" title="帧两种转发方式"></a>帧两种转发方式</h5><p>​            存储转发</p><p>​            <strong>等待后续补充</strong></p><hr><h3 id="3-9以太网交换机自学习和转发帧的流程"><a href="#3-9以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9以太网交换机自学习和转发帧的流程"></a>3.9以太网交换机自学习和转发帧的流程</h3><h4 id="收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号"><a href="#收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号" class="headerlink" title="收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号"></a>收到帧机型登记。登记内容为帧的源MAC地址以及进入交换机的接口号</h4><h4 id="根据帧的目的MAC地址和交换机的帧交换表对帧进行转发"><a href="#根据帧的目的MAC地址和交换机的帧交换表对帧进行转发" class="headerlink" title="根据帧的目的MAC地址和交换机的帧交换表对帧进行转发"></a>根据帧的目的MAC地址和交换机的帧交换表对帧进行转发</h4><h5 id="明确转发"><a href="#明确转发" class="headerlink" title="明确转发"></a>明确转发</h5><p>​            交换机知道应当从哪个接口转发该帧（单播、多播、广播）</p><h5 id="盲目转发"><a href="#盲目转发" class="headerlink" title="盲目转发"></a>盲目转发</h5><p>​            交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</p><h5 id="明确丢弃"><a href="#明确丢弃" class="headerlink" title="明确丢弃"></a>明确丢弃</h5><p>​            交换机知道不应该转发该帧，将其丢弃</p><h4 id="帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下"><a href="#帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下" class="headerlink" title="帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下"></a>帧交换表中的每条记录都有自己的有效时间，到期删除，原因如下</h4><p>​        交换机的接口改接了另一台主机<br>​        <strong>等待后续补充</strong></p><hr><h3 id="3-10以太网交换机的生成树协议STP"><a href="#3-10以太网交换机的生成树协议STP" class="headerlink" title="3.10以太网交换机的生成树协议STP"></a>3.10以太网交换机的生成树协议STP</h3><h4 id="添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路"><a href="#添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路" class="headerlink" title="添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路"></a>添加冗余链路可以提高以太网的可靠性，但是冗余链路会形成网络环路</h4><h5 id="网络环路会带来的问题"><a href="#网络环路会带来的问题" class="headerlink" title="网络环路会带来的问题"></a>网络环路会带来的问题</h5><h6 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h6><p>​                大量消耗网络资源，使得网络无法正常转发其他数据帧</p><h6 id="主机收到重复的广播帧"><a href="#主机收到重复的广播帧" class="headerlink" title="主机收到重复的广播帧"></a>主机收到重复的广播帧</h6><p>​                大量消耗主机资源</p><h6 id="交换机的帧交换表震荡（漂移）"><a href="#交换机的帧交换表震荡（漂移）" class="headerlink" title="交换机的帧交换表震荡（漂移）"></a>交换机的帧交换表震荡（漂移）</h6><p>​    交换机使用生成树协议STP，可以在增加冗余链路提高网络可靠性的同时又避免网络环路带来的各种问题<br>​    交换机都能够自动计算并构建出一个逻辑上没有环路的网络，其逻辑拓扑结构必须时树形（无逻辑环路）<br>​    最终生成的树形逻辑拓扑要确保连通整个网络<br>​    当首次连接交换机或网络物理拓扑发生变化时（有可能时人为改变或故障），交换机都将进行生成树的重新计算</p><hr><h3 id="3-11虚拟局域网VLAN"><a href="#3-11虚拟局域网VLAN" class="headerlink" title="3.11虚拟局域网VLAN"></a>3.11虚拟局域网VLAN</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="网络中会频烦出现广播信息"><a href="#网络中会频烦出现广播信息" class="headerlink" title="网络中会频烦出现广播信息"></a>网络中会频烦出现广播信息</h5><p>​            地址解析协议ARP<br>​            路由信息协议RIP<br>​            动态主机配置协议DHCP<br>​            NetBEUI<br>​            IPX&#x2F;SPX<br>​            Apple Talk</p><h5 id="分割广播域方法"><a href="#分割广播域方法" class="headerlink" title="分割广播域方法"></a>分割广播域方法</h5><h6 id="使用路由器（成本较高）"><a href="#使用路由器（成本较高）" class="headerlink" title="使用路由器（成本较高）"></a>使用路由器（成本较高）</h6><h6 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h6><p>​                是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</p><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><h5 id="IEEE-802-1Q帧（也称Dot-One-Q帧）"><a href="#IEEE-802-1Q帧（也称Dot-One-Q帧）" class="headerlink" title="IEEE 802.1Q帧（也称Dot One Q帧）"></a>IEEE 802.1Q帧（也称Dot One Q帧）</h5><h6 id="对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记"><a href="#对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记" class="headerlink" title="对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记"></a>对以太网MAC帧格式进行了扩展，插入4字节的VLAN标记</h6><h6 id="VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN"><a href="#VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN" class="headerlink" title="VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN"></a>VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪个VLAN</h6><p>​                VID取值范围0<del>4095（0</del>2^12-1）<br>​                0和4095都不用来表示VLAN，因此用于表示VLAN的VID的有效取值范围是1~4094</p><h6 id="IEEE-802-1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE-802-1Q帧"><a href="#IEEE-802-1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE-802-1Q帧" class="headerlink" title="IEEE 802.1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE 802.1Q帧"></a>IEEE 802.1Q帧是由交换机来处理，而不是用户主机，用户主机无法识别IEEE 802.1Q帧</h6><p>​                当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称“打标签”<br>​                当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称“去标签”</p><h5 id="交换机的端口类型"><a href="#交换机的端口类型" class="headerlink" title="交换机的端口类型"></a>交换机的端口类型</h5><h6 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h6><p>​                一般用于连接用户计算机<br>​                只能属于一个VLAN<br>​                PVID值与端口所属VLAN的ID相同（默认为1）<br>​                接收处理方法<br>​                    一般只接收“未打标签”的普通以太网MAC帧。根据接收帧的端口PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等<br>​                发送处理方法<br>​                    若帧中的VID与端口的PVID相等，则“去标签”并转发该帧；否则不转发。</p><h6 id="Trunk"><a href="#Trunk" class="headerlink" title="Trunk"></a>Trunk</h6><p>​                一般用于交换机之间或交换机与路由器之间的互连<br>​                可以属于多个VLAN<br>​                用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1<br>​                接收处理方法<br>​                    对VID等于PVID的帧，“去标签”再转发<br>​                    对VID不等于PVID的帧，直接转发<br>​                发送处理方法<br>​                    接收“未打标签”的帧，根据接收帧的端口的PVID帧给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等<br>​                    接收“已打标签的帧”</p><h6 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h6><p>​                绝大部分与Trunk端口相同<br>​                端口发送处理方法（与Trunk不同）<br>​                    查看帧的VID是否再端口的“去标签”列表中<br>​                        存在<br>​                            “去标签”后转发<br>​                        不存在<br>​                            若不存在，则直接转发</p><h5 id="交换机各端口的缺省VLAN-ID"><a href="#交换机各端口的缺省VLAN-ID" class="headerlink" title="交换机各端口的缺省VLAN ID"></a>交换机各端口的缺省VLAN ID</h5><p>​            思科交换机上称为Native VLAN，即本征VLAN<br>​            华为交换机上称为Port VLAN ID，简称为PVID</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2022/04/12/vuex/"/>
      <url>/2022/04/12/vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="Vuex工作原理"><a href="#Vuex工作原理" class="headerlink" title="Vuex工作原理"></a>Vuex工作原理</h3><img src="/2022/04/12/vuex/vuex.png" class=""><h4 id="Vuex三个重要工作区域"><a href="#Vuex三个重要工作区域" class="headerlink" title="Vuex三个重要工作区域"></a>Vuex三个重要工作区域</h4><h5 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a><code>Actions</code></h5><p>​    在<code>Vue Components</code>调用<code>dispatch()</code>要至少传两个传输，第一个参数为<code>object</code>对象，为在Actions中想要调用的函数名称，第二个参数为想要传递的数据。逻辑运算由Actions来进行，可以减少代码的冗余和增加复用性。在Actions可以调用后端接口或发ajax请求等操作，可以处理业务逻辑。在Actions获得的第一个参数为<code>context</code>可以在<code>context</code>调用<code>commit</code>等方法。<strong>尽量不要在Actions修改state中数据，Devtools捕捉不到行为</strong></p><h5 id="Mutations（方法名一般为大写，方便与Actions区分）"><a href="#Mutations（方法名一般为大写，方便与Actions区分）" class="headerlink" title="Mutations（方法名一般为大写，方便与Actions区分）"></a><code>Mutations</code>（方法名一般为大写，方便与Actions区分）</h5><p>​    在<code>Vue Components</code>或<code>Actinos</code>中调用<code>commit()</code>要至少传两个传输，第一个参数为<code>object</code>对象，为在Mutations中想要调用的函数名称，第二个参数为想要传递的数据。此时Mutations所要调用的第一个值为整个<code>state</code>，第二个则为传递过来的数据，在Mutations中调用state里的参数会自动进行调用<code>Mutate</code>函数将State数据进行变换。<strong>函数内部需要return</strong></p><h5 id="State"><a href="#State" class="headerlink" title="State"></a><code>State</code></h5><p>​    state主要存放数据，State中数据改变Vuex会主动调用<code>Render</code>对组件重新进行渲染。</p><h4 id="其他配置项"><a href="#其他配置项" class="headerlink" title="其他配置项"></a>其他配置项</h4><h5 id="getters"><a href="#getters" class="headerlink" title="getters"></a><code>getters</code></h5><p>类似于vue中的<code>computed</code>属性，在<code>getters</code>中调用时可以获取到<code>state</code>中的相关数据。适合逻辑复杂并且需要复用的数据。</p><h5 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a><code>mapState</code></h5><p>可以直接从<code>state</code>中拿数据，增加效率，一般以扩展运算符<code>...</code>形式放在computed中</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的computed调用</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapState<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//注册完毕后可以直接使用插值语法</span><span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//对象写法,因为后方必须带引号无法使用对象简写方式</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法，生成的计算属性名和读取的数据名一致</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a><code>mapGetters</code></h5><p>同上，可以直接从<code>getters</code>中拿数据，增加效率，一般以扩展运算符<code>...</code>形式放在computed中</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的computed调用</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapGetters<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//注册完毕后可以直接使用插值语法</span><span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//对象写法,因为后方必须带引号无法使用对象简写方式</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法，生成的计算属性名和读取的数据名一致</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a><code>mapMutations</code></h5><p>可以不用自己在方法中使用<code>commit</code>来调用<code>Actions</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的methods调用,调用的时候需要传参，要是没有传参会传所触发的事件事件</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapMutations<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//接入mapMutations生成对应方法，方法中会调用commit去联系Mutations</span>    <span class="token comment">//对象写法</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h5 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a><code>mapActions</code></h5><p>可以不用自己在方法中使用<code>commit</code>来调用<code>Actions</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在要使用state的组件中的methods调用,调用的时候需要传参，要是没有传参会传所触发的事件事件</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>mapActions<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//接入mapActions生成对应方法，方法中会调用dispatch去联系mapActions</span>    <span class="token comment">//对象写法</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">example</span><span class="token operator">:</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token literal-property property">example2</span><span class="token operator">:</span><span class="token string">'example2'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">//数组写法</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'example1'</span><span class="token punctuation">,</span><span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h4 id="Vuex工作环境-Vue2版本"><a href="#Vuex工作环境-Vue2版本" class="headerlink" title="Vuex工作环境(Vue2版本)"></a>Vuex工作环境(Vue2版本)</h4><p>目前使用<code>npm i vuex</code>安装的是Vue3版本的Vuex</p><p>使用<code>npm i vuex@3</code>才能安装Vue2版本的Vuex</p><p>安装完成后在根目录创建<code>store</code>文件夹，并创建<code>index.js</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//该文件用于创建Vuex最为核心的store</span><span class="token comment">//引入Vue</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//使用Vuex</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token comment">//准备actions  用于相应组件中的动作</span><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//准备mutations  用于操作数据</span><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//准备state 用于存储数据</span><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//准备getters  用于将state中的数据进行加工</span><span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建store</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    actions<span class="token punctuation">,</span>    mutations<span class="token punctuation">,</span>    state<span class="token punctuation">,</span>    getters<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> store</code></pre><p><strong>注意：import语句会优先执行，Vue.use(Vuex)在main.js中使用会报错</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在vue-cli根目录的main.js中引入Vuex，这样可以全局使用vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//引入store</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>    <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">,</span>    store<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="Vux模块化"><a href="#Vux模块化" class="headerlink" title="Vux模块化"></a>Vux模块化</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//该文件用于创建Vuex最为核心的store</span><span class="token comment">//引入Vue</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment">//使用Vuex</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token comment">//将功能进行模块化封装，可以封装在其他js文件中</span><span class="token keyword">const</span> example1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//想要直接读取数据需要开启命名空间，默认为false</span>    <span class="token literal-property property">namespaced</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">actions</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">state</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">getters</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">mutations</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> example2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//想要直接读取数据需要开启命名空间，默认为false</span>    <span class="token literal-property property">namespaced</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">actions</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">state</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">getters</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">mutations</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建store</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">modules</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token comment">//在store.state会存放除getters外的方法</span>        example1<span class="token punctuation">,</span>        example2    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> store</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络_物理层</title>
      <link href="/2022/04/12/wu-li-ceng/"/>
      <url>/2022/04/12/wu-li-ceng/</url>
      
        <content type="html"><![CDATA[<h3 id="2-1物理层的基本概念"><a href="#2-1物理层的基本概念" class="headerlink" title="2.1物理层的基本概念"></a>2.1物理层的基本概念</h3><h4 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h4><h5 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h5><p>​            双绞线<br>​            同轴电缆<br>​            光纤</p><h5 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h5><p>​            微波通信<br>​                2~40GHz</p><h4 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h4><p>​        机械特性<br>​        电器特性<br>​        功能特性<br>​        过程特性</p><h4 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h4><p>​    物理层考虑是怎样才能在连接各种计算机的传输媒体上传输数据比特流</p><p>​    物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务</p><hr><h3 id="2-2物理层下的传输媒体"><a href="#2-2物理层下的传输媒体" class="headerlink" title="2.2物理层下的传输媒体"></a>2.2物理层下的传输媒体</h3><h4 id="导引型传输媒体-1"><a href="#导引型传输媒体-1" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><h6 id="基带同轴电缆（50Ω）"><a href="#基带同轴电缆（50Ω）" class="headerlink" title="基带同轴电缆（50Ω）"></a>基带同轴电缆（50Ω）</h6><p>​                数字传输，过去用于局域网</p><h6 id="宽带同轴电缆（75Ω）"><a href="#宽带同轴电缆（75Ω）" class="headerlink" title="宽带同轴电缆（75Ω）"></a>宽带同轴电缆（75Ω）</h6><p>​                模拟传输，目前主要用于有线电视</p><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><h6 id="无屏蔽双绞线UTP"><a href="#无屏蔽双绞线UTP" class="headerlink" title="无屏蔽双绞线UTP"></a>无屏蔽双绞线UTP</h6><h6 id="屏蔽双绞线STP"><a href="#屏蔽双绞线STP" class="headerlink" title="屏蔽双绞线STP"></a>屏蔽双绞线STP</h6><h6 id="绞合的作用"><a href="#绞合的作用" class="headerlink" title="绞合的作用"></a>绞合的作用</h6><p>​                抵御部分来自外界的电磁波干扰<br>​                减少相邻导线的电磁干扰</p><h5 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>​                通信容量大（25000~30000GHz的带宽）<br>​                传输损耗小，远距离传输时更加经济<br>​                抗雷电和电磁干扰性能好<br>​                无串音干扰，保密性好，不易被窃听<br>​                体积小，重量轻<br>​        电力线</p><h5 id="非导引型传输媒体-1"><a href="#非导引型传输媒体-1" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h5><p>​        无线电波<br>​        微波<br>​        红外线<br>​        可见光</p><hr><h3 id="2-3传输方式"><a href="#2-3传输方式" class="headerlink" title="2.3传输方式"></a>2.3传输方式</h3><h4 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h4><h4 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h4><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><h5 id="外同步"><a href="#外同步" class="headerlink" title="外同步"></a>外同步</h5><p>​            在收发双方之间添加一条单独的时钟信号线</p><h5 id="内同步"><a href="#内同步" class="headerlink" title="内同步"></a>内同步</h5><p>​            发送端将时钟同步信号编码到发送数据中一起传输</p><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><p>​        字节之间异步<br>​        字节中的每个比特仍然要同步</p><h4 id="单向通信（单工）"><a href="#单向通信（单工）" class="headerlink" title="单向通信（单工）"></a>单向通信（单工）</h4><h4 id="双向交替通信（半双工）"><a href="#双向交替通信（半双工）" class="headerlink" title="双向交替通信（半双工）"></a>双向交替通信（半双工）</h4><h4 id="双向同时通信（全双工）"><a href="#双向同时通信（全双工）" class="headerlink" title="双向同时通信（全双工）"></a>双向同时通信（全双工）</h4><hr><h3 id="2-4编码与调制"><a href="#2-4编码与调制" class="headerlink" title="2.4编码与调制"></a>2.4编码与调制</h3><h4 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h4><p>​        在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p><h4 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h4><h5 id="不归零编码"><a href="#不归零编码" class="headerlink" title="不归零编码"></a>不归零编码</h5><p>​            存在同步问题</p><h5 id="归零编码"><a href="#归零编码" class="headerlink" title="归零编码"></a>归零编码</h5><p>​            自同步，编码效率低</p><h5 id="曼切斯特编码"><a href="#曼切斯特编码" class="headerlink" title="曼切斯特编码"></a>曼切斯特编码</h5><h5 id="差分曼切斯特编码"><a href="#差分曼切斯特编码" class="headerlink" title="差分曼切斯特编码"></a>差分曼切斯特编码</h5><hr><h3 id="2-5信道的极限容量"><a href="#2-5信道的极限容量" class="headerlink" title="2.5信道的极限容量"></a>2.5信道的极限容量</h3><h4 id="造成信号失真的因素"><a href="#造成信号失真的因素" class="headerlink" title="造成信号失真的因素"></a>造成信号失真的因素</h4><p>​        码元传输速率<br>​        信号传输距离<br>​        噪声干扰<br>​        传输媒体质量</p><h4 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h4><h5 id="理想低通信道的最高码元传输速率"><a href="#理想低通信道的最高码元传输速率" class="headerlink" title="理想低通信道的最高码元传输速率"></a>理想低通信道的最高码元传输速率</h5><h5 id="理想带通信道的最高码元传输速率"><a href="#理想带通信道的最高码元传输速率" class="headerlink" title="理想带通信道的最高码元传输速率"></a>理想带通信道的最高码元传输速率</h5><h5 id="波特率与比特率的关系"><a href="#波特率与比特率的关系" class="headerlink" title="波特率与比特率的关系"></a>波特率与比特率的关系</h5><p>$$<br>码元传输速率又成为波特率，调制速率、波形速率或符号速率。它与比特率有一定的关系。\\<br>当1个码元只携带1比特的信息量时，波特率（码元&#x2F;秒）与比特率（比特&#x2F;秒）在数值上相等\\<br>当1个码元携带n个比特的信息量时，数值则乘以n\\<br>$$</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>​            实际的通信所能传输的最高码元速率，要明显低于奈氏准则给出的上限值</p><h4 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h4><p>​        信道的极限信息传输速率<br>$$<br>c&#x3D; W \cdot  \log_2(1+\frac{S}{N} )\\<br>c:信道的极限信息传输速率（单位为b&#x2F;s）\\<br>W: 信道带宽（Hz）\\<br>S: 信道内所传输信号的平均功率\\<br>N: 信道内的高斯噪声功率\\<br>\frac{S}{N}: 信噪比，使用分贝（dB）作为度量单位。\\<br>信噪比（dB） &#x3D; 10 \cdot \log_{10}(\frac{S}{N})\\<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因特网概述</title>
      <link href="/2022/04/11/yin-te-wang-gai-shu/"/>
      <url>/2022/04/11/yin-te-wang-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-1因特网概述："><a href="#1-1因特网概述：" class="headerlink" title="1.1因特网概述："></a>1.1因特网概述：</h3><h4 id="因特网发展的三个阶段："><a href="#因特网发展的三个阶段：" class="headerlink" title="因特网发展的三个阶段："></a>因特网发展的三个阶段：</h4><p>1969年：从单个网络ARPANET向互联网发展</p><p>1985年：逐步建成三级结构的因特网</p><p>1993年：逐步形成了多层次ISP（internet service provider）结构的因特网</p><h5 id="国内三大提供商（第43次统计报告）总共出口宽带数"><a href="#国内三大提供商（第43次统计报告）总共出口宽带数" class="headerlink" title="国内三大提供商（第43次统计报告）总共出口宽带数"></a>国内三大提供商（第43次统计报告）总共出口宽带数</h5><p>中国电信国际出口宽带数：4537680（Mbps）</p><p>中国联通国际出口宽带数：2234738(Mbps)</p><p>中国移动国际出口宽带数：1997000(Mbps)</p><h4 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h4><h5 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h5><p>由所有连接在因特网上的主机组成（包括但不仅限于下几个）</p><ol><li>电脑</li><li>手机</li><li>平板</li><li>笔记本</li></ol><h5 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h5><p>由大量网络和连接这些网络的路由器组成，为边缘部分提供服务（包括但不仅限于下几个）<br>    1.路由器<br>    2.大量网络</p><hr><h3 id="1-2三种交换方式"><a href="#1-2三种交换方式" class="headerlink" title="1.2三种交换方式"></a>1.2三种交换方式</h3><h4 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h4><h5 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h5><p>​        建立连接（分配通信资源）<br>​        通信（一直占用通信资源）<br>​        释放连接（归还通信资源）</p><h5 id="比特流直达终点"><a href="#比特流直达终点" class="headerlink" title="比特流直达终点"></a>比特流直达终点</h5><h5 id="电路交换的优点："><a href="#电路交换的优点：" class="headerlink" title="电路交换的优点："></a>电路交换的优点：</h5><p>​        通信时延小<br>​        有序传输<br>​        没有冲突<br>​        适用范围广<br>​        实时性强<br>​        控制简单</p><h5 id="电路交换的缺点："><a href="#电路交换的缺点：" class="headerlink" title="电路交换的缺点："></a>电路交换的缺点：</h5><p>​        建立连接时间长<br>​        线路独占，使用效率低<br>​        灵活性差<br>​        难以规格化</p><h4 id="分组交换（Packet-Switch）"><a href="#分组交换（Packet-Switch）" class="headerlink" title="分组交换（Packet Switch）"></a>分组交换（Packet Switch）</h4><h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5><p>​        构造分组<br>​        发送分组</p><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><p>​        缓存分组<br>​        转发分组</p><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><p>​        接受分组<br>​        还原报文</p><h5 id="报文前加上首部（简称包）"><a href="#报文前加上首部（简称包）" class="headerlink" title="报文前加上首部（简称包）"></a>报文前加上首部（简称包）</h5><p>​        整个报文存储转发</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>​        无需建立连接<br>​        线路利用率高<br>​        简化了存储管理<br>​        加速传输<br>​        减少出错概率和重发数据量</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>​        引起了转发时延<br>​        需要传输额外的信息量<br>​        对于数据报服务，存在失序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</p><h4 id="报文交换（Message-Switching）"><a href="#报文交换（Message-Switching）" class="headerlink" title="报文交换（Message Switching）"></a>报文交换（Message Switching）</h4><h5 id="报文进行分组并前加上首部"><a href="#报文进行分组并前加上首部" class="headerlink" title="报文进行分组并前加上首部"></a>报文进行分组并前加上首部</h5><p>​        分组存储转发</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>​        无需建立连接<br>​        动态分配线路<br>​        提高线路可靠性<br>​        提高线路利用率<br>​        提供多目标服务</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>​        引起了转发时延<br>​        需要较大存储缓存空间<br>​        需要传输额外的信息量</p><hr><h3 id="1-3计算机网络的分类"><a href="#1-3计算机网络的分类" class="headerlink" title="1.3计算机网络的分类"></a>1.3计算机网络的分类</h3><h4 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h4><p>​        电路交换网络<br>​        报文交换网络<br>​        分组交换网络</p><h4 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h4><p>​        公用网<br>​        专用网</p><h4 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h4><p>​        有线网络<br>​        无线网络</p><h4 id="按覆盖范围分类"><a href="#按覆盖范围分类" class="headerlink" title="按覆盖范围分类"></a>按覆盖范围分类</h4><h5 id="广域网WAN"><a href="#广域网WAN" class="headerlink" title="广域网WAN"></a>广域网WAN</h5><p>​            覆盖范围几十公里到几千公里</p><h5 id="城域网MAN"><a href="#城域网MAN" class="headerlink" title="城域网MAN"></a>城域网MAN</h5><p>​            覆盖范围5至50公里</p><h5 id="局域网LAN"><a href="#局域网LAN" class="headerlink" title="局域网LAN"></a>局域网LAN</h5><p>​            在较小的范围内（如实验室、教学楼）</p><h5 id="个域网PAN"><a href="#个域网PAN" class="headerlink" title="个域网PAN"></a>个域网PAN</h5><p>​            覆盖范围大约为10米</p><h4 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h4><h5 id="总线型网络"><a href="#总线型网络" class="headerlink" title="总线型网络"></a>总线型网络</h5><h6 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h6><p>​                建网容易<br>​                增减结点方便<br>​                节省线路</p><h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><p>​                重负载时通信效率不高<br>​                总线任意一处出现故障，则全网瘫痪</p><h5 id="星型网络"><a href="#星型网络" class="headerlink" title="星型网络"></a>星型网络</h5><h6 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h6><p>​                便于网络的集中控制和管理</p><h6 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h6><p>​                成本高，中央设备对故障敏感</p><h5 id="环型网络"><a href="#环型网络" class="headerlink" title="环型网络"></a>环型网络</h5><p>​            环中信号是单向传输</p><h5 id="网状型网络"><a href="#网状型网络" class="headerlink" title="网状型网络"></a>网状型网络</h5><h6 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h6><p>​                可靠性高</p><h6 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h6><p>​                控制复杂、线路成本高</p><hr><h3 id="1-4性能指标"><a href="#1-4性能指标" class="headerlink" title="1.4性能指标"></a>1.4性能指标</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><h5 id="比特"><a href="#比特" class="headerlink" title="比特"></a>比特</h5><p>是计算机中的数据量单位</p><p>​<br>$$<br>8bit &#x3D; 1Byte\\<br>            1KB &#x3D; 2^{10}B\\<br>            1MB &#x3D; K×KB &#x3D; 2^{20}B\\<br>            1GB &#x3D; K×MB &#x3D; 2^{30}B\\<br>            1TB &#x3D; K×GB &#x3D; 2^{40}B\\<br>            厂家中的1GB为10^9<br>$$</p><h5 id="速率-1"><a href="#速率-1" class="headerlink" title="速率"></a>速率</h5><p>是连接在计算机网络上的主机在数字信道上传送比特的速率，也成为比特率或数据率</p><p>​<br>$$ {速率}<br>1bit&#x2F;s\\<br>            1kb&#x2F;s &#x3D; 10^3 b&#x2F;s\\<br>            1Mb&#x2F;s &#x3D; k×kb&#x2F;s &#x3D; 10^6 b&#x2F;s\<br>            1Gb&#x2F;s &#x3D; k×Mb&#x2F;s &#x3D; 10^9 b&#x2F;s\\<br>            1Tb&#x2F;s &#x3D; k×Gb&#x2F;s &#x3D; 10^{12} b&#x2F;s\\<br>$$</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><h5 id="模拟信号系统中的意义"><a href="#模拟信号系统中的意义" class="headerlink" title="模拟信号系统中的意义"></a>模拟信号系统中的意义</h5><p>​            信号所包含的各种不同频率成分所占据的频率范围<br>​<br>$$<br>kHz\\<br>                MHz\\<br>                GHz\\<br>$$</p><h5 id="计算机网络中的意义"><a href="#计算机网络中的意义" class="headerlink" title="计算机网络中的意义"></a>计算机网络中的意义</h5><p>​            表示网络的通信线路所能传送数据的能力<br>$$<br>kb&#x2F;s<br>                Mb&#x2F;s<br>                Gb&#x2F;s<br>$$</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>​        表示在单位时间内通过某个网络（或信道、接口）的数据量<br>​        吞吐量受网络的带宽或额定速率的限制</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><h5 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h5><p>​            分组长度（b）&#x2F;发送速率（b&#x2F;s）</p><h5 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h5><p>​<br>$$<br>        信道长度（m）&#x2F;电磁波传播速率（m&#x2F;s）\\<br>                自由空间:<br>                    3×10^8 m&#x2F;s\\<br>                铜线:<br>                    2.3×10^8 m&#x2F;s\\<br>                光纤:<br>                    2.0×10^8 m&#x2F;s\\<br>$$</p><h5 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h5><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>​<br>$$<br>    传播时延×带宽<br>$$</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>​        源主机收到目的主机的确认需要的时间</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>​<br>$$<br>                        信道利用率\\<br>                        网络利用率\\<br>        网络当前的时延 &#x3D; 网络空闲时的时延 &#x2F; (1 - 利用率)\\<br>$$</p><h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><hr><h3 id="1-5计算机网络体系结构"><a href="#1-5计算机网络体系结构" class="headerlink" title="1.5计算机网络体系结构"></a>1.5计算机网络体系结构</h3><h4 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h4><h5 id="OSI体系结构"><a href="#OSI体系结构" class="headerlink" title="OSI体系结构"></a>OSI体系结构</h5><p>​            应用层<br>​            表示层<br>​            会话层<br>​            运输层<br>​            网络层<br>​            数据链路层<br>​            物理层</p><h5 id="TCP-x2F-IP体系结构"><a href="#TCP-x2F-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h5><h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p>​                HTTP协议<br>​                SMTP协议<br>​                DNS协议<br>​                RTP协议<br>​                等等</p><h6 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h6><p>​                TCP协议<br>​                UDP协议</p><h6 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h6><p>​                IP协议<br>​            网络接口层</p><h5 id="原理体系结构"><a href="#原理体系结构" class="headerlink" title="原理体系结构"></a>原理体系结构</h5><p>​            应用层<br>​            运输层<br>​            网络层<br>​            数据链路层<br>​            物理层</p><h4 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h4><h5 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h5><p>​            通过应用进程间的交互来完成特定的网络应用</p><h5 id="运输层-1"><a href="#运输层-1" class="headerlink" title="运输层"></a>运输层</h5><p>​            如何解决进程之间基于网络的通信问题<br>​            出现传输错误时，如何处理</p><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>​            如何标识各网络以及网络中的各主机<br>​            路由器如何转发分组，如何进行路由选择</p><h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>​            如何标识网络中的各主机<br>​            如何从信号所表示的一串比特流中区分出地址和数据<br>​            如何协调各主机争用总线</p><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>​            使用怎样的信号表示比特0和1</p><h4 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h4><h5 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h5><p>​            应用层<br>​                HTTP报文<br>​            运输层<br>​                HTTP TCP报文段<br>​            网络层<br>​                HTTP TCP IP数据报<br>​            数据链路层<br>​                ETH HTTP TCP IP ETH帧<br>​            物理层<br>​                比特流</p><h5 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h5><p>​            网络层<br>​                HTTP TCP IP数据报<br>​            数据链路层<br>​                ETH HTTP TCP IP ETH帧<br>​            物理层<br>​                比特流</p><h5 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h5><p>​            发送端同理，发送端自顶向下，接收端逐步解析</p><h4 id="计算机网络体系结构结构的专用术语"><a href="#计算机网络体系结构结构的专用术语" class="headerlink" title="计算机网络体系结构结构的专用术语"></a>计算机网络体系结构结构的专用术语</h4><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>​            任何可发送或接受信息的硬件或软件进程</p><h5 id="协议（水平）"><a href="#协议（水平）" class="headerlink" title="协议（水平）"></a>协议（水平）</h5><p>​            语法<br>​                定义所交换信息的格式<br>​            语义<br>​                定义收发双方要完成的操作<br>​            同步<br>​                定义收发双方的时序关系</p><h5 id="服务（垂直）"><a href="#服务（垂直）" class="headerlink" title="服务（垂直）"></a>服务（垂直）</h5><p>​            下面的协议对上面的实体时透明的</p><h5 id="协议数据单元PDU"><a href="#协议数据单元PDU" class="headerlink" title="协议数据单元PDU"></a>协议数据单元PDU</h5><p>​            对等层次之间传送的数据包</p><h5 id="服务数据单元SDU"><a href="#服务数据单元SDU" class="headerlink" title="服务数据单元SDU"></a>服务数据单元SDU</h5><p>​            同一系统内，层与层之间交换的数据包</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建与应用主题</title>
      <link href="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/"/>
      <url>/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h3><p>1.<strong><a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></strong>(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</p><p>2.<strong><a href="http://git-scm.com/">Git (git-scm.com)</a></strong></p><p>3.<strong>淘宝镜像（非必要）</strong><code>npm config set registry https://registry.npm.taobao.org</code> </p><p>​        用了淘宝镜像可以更快下载资源包。</p><p>​        使用<code>npm config get registry</code>来查看是否配置完成。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/config.png" class=""><p>​        显示地址说明配置完成。</p><p>4.安装hexo</p><p><a href="https://hexo.io/zh-cn/">Hexo</a>官网地址(更详细的安装配置等可以看官方文档)</p><p>使用<code>npm install hexo-cli -g</code>可将hexo全局配置。</p><p>使用<code>npx hexo</code>可以来查看hexo是否安装成功。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexoC.png" class=""><p>出现相关命令则安装成功。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="hexo初始化"><a href="#hexo初始化" class="headerlink" title="hexo初始化"></a>hexo初始化</h3><p>到任意磁盘位置创建一个文件夹并打开cmd使用<code>hexo init</code>命令对目标文件夹初始化（这里以D:\blog为例）</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexoI.png" class=""><p>检查文件夹是否有以下几种文件：</p><img src="Hexo搭建与应用主题.assets/hexodocument.png" style="zoom:60%;" /><p>没有报错则初始化成功。(如果有问题大部分是node.js版本或git未安装导致)</p><p>在控制台使用<code>hexo s</code>可以在本地查看blog效果如何，如果有页面显示说明已成功安装了hexo。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexos.png" class=""><p>在cmd页面使用<code>ctrl+c</code>可以结束本地端口运行。</p><h3 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h3><p>这里主要先搭建github仓库远程上传代码，先在git将仓库建好。</p><p>进入github首页点右上角<code>sign in</code>登录，然后在<code>Repositories</code>中new一个新仓库</p><img src="Hexo搭建与应用主题.assets/githubr.png" style="zoom:60%;" /><p>Repository name 以自己的<code>github账号名.github.io</code>来命名，没有其他要求点击<code>create respository</code>创建仓库即可。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/githubpath.png" class=""><p>将自己仓库的HTTPS地址复制下来（因为我已经建过blog仓库这里就没以<code>github账号名.github.io</code>来命名了，可以看上一张图的第一个仓库来作为参考）</p><p><strong>仓库建完成后在cmd中使用<code>npm install hexo-deployer-git --save</code>来安装插件。</strong></p><p>然后<strong>相关配置</strong>需要打开<code>_config.yml</code>文件，详细信息需要看文档进行配置。</p><p>这里先配置<code>Deployment</code>（位置在最底下）</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexodeploy.png" class=""><p><code>repo</code>放刚刚复制的github仓库地址，保存后在自己文件夹cmd使用<code>hexo clean</code>清除缓存文件（<code>db.json</code>）和已生成静态文件（<code>public</code>），后使用<code>hexo g</code>生成静态文件。（最好在每次上传仓库前重复以上两个步骤）</p><p>然后<code>hexo d</code>来将本地部署到github中</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexode.png" class=""><p>出现自己github仓库地址后，刷新网页。</p><img src="Hexo搭建与应用主题.assets/gitweb.png" style="zoom:60%;" /><p>出现文件说明上传成功，可以通过标蓝的地址名来进行线上访问（不过由于在国内有时候会访问不上，可以Netlify等网络托管平台来进行布置）</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/gitwebsee.png" class=""><p>（这里我是以我原先布置的blog来进行展示）</p><img src="Hexo搭建与应用主题.assets/web.png" style="zoom:60%;" /><p>看来类似这个页面就是已经部署成功了。</p><h3 id="配置主题-这里以matery主题为例"><a href="#配置主题-这里以matery主题为例" class="headerlink" title="配置主题(这里以matery主题为例)"></a>配置主题(这里以matery主题为例)</h3><p>在自己blog文件夹的themes路径下下输入<code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code>从github上clone项目到themes文件夹中</p><img src="Hexo搭建与应用主题.assets/hexocp.png" style="zoom:60%;" /><p>主题配置在源文件夹<code>_config.yml</code>文件的theme中。</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/hexods.png" class=""><p>将<code>landscape</code>替换成要更换的主题，即<code>hexo-theme-matery</code></p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/changeTheme.png" class=""><p>然后在cmd使用<code>hexo s</code>来进行本地查看是否生效</p><img src="/2022/04/11/hexo-da-jian-yu-ying-yong-zhu-ti/themesee.png" class=""><p>发现页面更换了就说明已经使用了主题，相关更多的配置可以在<code>hexo-theme-matery</code>的作者文档中进行查看，也可以去源作者<a href="https://github.com/blinkfox/hexo-theme-matery">blinkfox</a>中了解更多！</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
